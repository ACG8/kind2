(* This file is part of the Kind 2 model checker.

   Copyright (c) 2015 by the Board of Trustees of the University of Iowa

   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License.  You
   may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0 

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied. See the License for the specific language governing
   permissions and limitations under the License. 

*)

(* WARNING: DO NOT EDIT THE .ML FILE --- CHANGES WILL BE OVERWRITTEN 

   Do not edit the .ml file but rather the .ml.in file, the .ml file
   is generated from the .ml.in file after each run of the configure
   script.

*)

open Lib

(*

type ('a, 'b) flag =
  { longname : string;
    shortname : string option;
    mutable value : 'a;
    of_arg : 'a -> 'b -> 'a;
    pp : Format.formatter -> 'a -> unit }
    

type int_flag = (int, int) flag 

type float_flag = (float, float) flag 

type bool_flag = (bool, bool) flag

type unit_flag = (unit, bool) flag 

type 'a string_flag = ('a, string) flag



type smtsolver = [ `Z3_SMTLIB | `Z3_API | `CVC4_SMTLIB | `CVC4_API | `Yices ]

let smtsolver_of_string = function
  | "Z3" -> `Z3_SMTLIB
  | "Z3_SMTLIB" -> `Z3_SMTLIB
  | "Z3_API" -> `Z3_API
  | "CVC4" -> `CVC4_SMTLIB
  | "CVC4_SMTLIB" -> `CVC4_SMTLIB
  | "CVC4_API" -> `CVC4_API
  | "Yices" -> `Yices
  | _ -> raise (Invalid_argument "smtsolver_of_string")

let pp_print_smtsolver ppf = 
  let p = Format.fprintf ppf in 
  function 
    | `Z3_SMTLIB -> p "Z3_SMTLIB"
    | `Z3_API -> p "Z3_API"
    | `CVC4_SMTLIB -> p "CVC4_SMTLIB"
    | `CVC4_API -> p "CVC4_API"
    | `Yices -> p "Yices"

let smtsolver_flag = 
  { longname = "smtsolver";
    shortname = None;
    value = `Z3_SMTLIB;
    of_arg = (function _ -> smtsolver_of_string);
    pp = pp_print_smtsolver }


let kind_module_of_string = function
  | "IC3" -> `IC3
  | "BMC" -> `BMC
  | "IND" -> `IND
  | "INVGEN" -> `INVGEN
  | "interpreter" -> `Interpreter
  | _ -> raise (Invalid_argument "smtsolver_of_string")


let pp_print_kind_module ppf = 
  let p = Format.fprintf ppf in 
  function
    | `IC3 -> p "IC3"
    | `BMC -> p "BMC"
    | `IND -> p "IND"
    | `INVGEN -> p "INVGEN"
    | `Interpreter -> p "interpreter"


let enable_flag = 
  { longname = "enable";
    shortname = Some "e";
    value = [];
    of_arg = (function curval -> (function arg -> kind_module_of_string arg :: curval));
    pp = (pp_print_list pp_print_kind_module ",@ ") }

*)


(* ********************************************************************** *)
(* Types and defaults for flags                                            *)
(* ********************************************************************** *)

(* TODO: write camlp4 code for this 
  
   type <X> = <X1> | <X2> arg <O> default <X2> action <F> doc <D>
      
   becomes 
   
   type <X> = <X1> | <X2>

   let <X>_of_string = function
     | "<X1>" -> <X1>
     | "<X2>" -> <X2>
     | _ raise (Arg.bad "Bad value for -<O>")

   let string_of_<X> = function 
     | <X1> -> "<X1>"
     | <X2> -> "<X2>"

   let <X>_values = "<X1>, <X2>"

   let <X>_default = <X2>

   let <O>_spec = 
     ("-<O>", 
      String <F>, 
      Format.sprintf <D> <X>_values <X>_default)

*)
      

(*   type <X> = <X1> | <X2> arg <O> default <X2> action <F> doc <D> *)

(*   type smtsolver = Z3_SMTLIB | CVC4_SMTLIB arg smtsolver default CVC4_SMTLIB action smtsolver_action doc " choose SMT solver (available: %s, default: %s" *)
  
(* ********** *) 

let timeout_wall_default = 0. 

(* ********** *) 

let timeout_virtual_default = 0. 

(* ********** *) 

type smtsolver = [ `Z3_SMTLIB | `CVC4_SMTLIB | `MathSat5_SMTLIB | `Yices_SMTLIB | `Yices_native | `detect ]
    
let smtsolver_of_string = function
  | "Z3" -> `Z3_SMTLIB
  | "CVC4" -> `CVC4_SMTLIB
  | "MathSat5" -> `MathSat5_SMTLIB
  | "Yices2" -> `Yices_SMTLIB
  | "Yices" -> `Yices_native
  | _ -> raise (Arg.Bad "Bad value for --smtsolver")

let string_of_smtsolver = function 
  | `Z3_SMTLIB -> "Z3"
  | `CVC4_SMTLIB -> "CVC4"
  | `Yices_SMTLIB -> "Yices2"
  | `Yices_native -> "Yices"
  | `MathSat5_SMTLIB -> "MathSat5"
  | `detect -> "detect"

let smtsolver_values = "Z3, CVC4, MathSat5, Yices, Yices2"

let smtsolver_default = `detect

(* ********** *) 

type smtlogic = [ `None | `detect | `Logic of string ]

let smtlogic_values = [ `None ; `detect ; `Logic ("\"logic\"") ]

let smtlogic_of_string = function
  | "none" | "None" -> `None
  | "detect" | "Detect" -> `detect
  | s -> `Logic s

let string_of_smtlogic = function
  | `None -> "none"
  | `detect -> "detect"
  | `Logic s -> s

let smtlogic_default = `None

(* ********** *) 

type z3_bin = string 

let z3_bin_of_string s = s

let string_of_z3_bin s = s 

let z3_bin_default = "z3"

(* ********** *) 

type smt_check_sat_assume = bool

let smt_check_sat_assume_of_string s = s

let string_of_smt_check_sat_assume s = s 

let smt_check_sat_assume_default = true

(* ********** *) 

type smt_short_names = bool

let smt_short_names_of_string s = s

let string_of_smt_short_names s = s 

let smt_short_names_default = true

(* ********** *) 

type cvc4_bin = string 

let cvc4_bin_of_string s = s

let string_of_cvc4_bin s = s 

let cvc4_bin_default = "cvc4"

(* ********** *) 

type mathsat5_bin = string 

let mathsat5_bin_of_string s = s

let string_of_mathsat5_bin s = s 

let mathsat5_bin_default = "mathsat"

(* ********** *) 

type yices_bin = string 

let yices_bin_of_string s = s

let string_of_yices_bin s = s 

let yices_bin_default = "yices"


(* ********** *) 

type yices2smt2_bin = string 

let yices2smt2_bin_of_string s = s

let string_of_yices2smt2_bin s = s 

let yices2smt2_bin_default = "yices-smt2"

(* ********** *) 

type smt_trace = bool

let smt_trace_default = false

(* ********** *) 

type smt_trace_dir = string

let smt_trace_dir_default = Sys.getcwd ()

(* ********** *) 

(* type kind_module = [ `IC3 | `BMC | `IND | `INVGEN ] *)

type enable = kind_module list 

let kind_module_of_string = function
  | "IC3" -> `IC3
  | "BMC" -> `BMC
  | "IND" -> `IND
  | "INVGEN" -> `INVGEN
  | "INVGENOS" -> `INVGENOS
  | "C2I" -> `C2I
  | "interpreter" -> `Interpreter
  | unexpected -> Arg.Bad (
      Format.sprintf "Unexpected value \"%s\" for flag --enable" unexpected
    ) |> raise

let string_of_kind_module = function
  | `IC3 -> "IC3"
  | `BMC -> "BMC"
  | `IND -> "IND"
  | `INVGEN -> "INVGEN"
  | `INVGENOS -> "INVGENOS"
  | `C2I -> "C2I"
  | `Interpreter -> "interpreter"

let string_of_enable = function
  | head :: tail ->
    ( List.fold_left
        ( fun s m -> s ^ ", " ^ (string_of_kind_module m) )
        ("[" ^ (string_of_kind_module head))
        tail )
    ^ "]"
  | [] -> "[]"

let enable_values = [
  `IC3 ; `BMC ; `IND ; `INVGEN ; `INVGENOS ; `C2I ; `Interpreter
] |> List.map string_of_kind_module |> String.concat ", "

let enable_default_init = []
let disable_default_init = []

let enable_default_after = [ `BMC; `IND; `IC3; `INVGEN; `INVGENOS ; `C2I ]

(* ********** *) 

type check_version = bool

let check_version_default = false

(* ********** *) 

type bmc_max = int
    
let bmc_max_default = 0

(* ********** *) 

type bmc_check_unroll = bool
    
let bmc_check_unroll_default = true

(* ********** *) 

type ind_compress = bool
    
let ind_compress_default = false

(* ********** *) 

type ind_compress_equal = bool
    
let ind_compress_equal_default = true

(* ********** *) 

type ind_compress_same_succ = bool
    
let ind_compress_same_succ_default = false

(* ********** *) 

type ind_compress_same_pred = bool
    
let ind_compress_same_pred_default = false

(* ********** *) 

type ind_lazy_invariants = bool
    
let ind_lazy_invariants_default = false

(* ********** *) 

(* type ind_print_inductive_cex = bool
    
let ind_print_inductive_cex_default = true *)

(* ********** *) 

type ic3_check_inductive = bool
    
let string_of_ic3_check_inductive = string_of_bool

let ic3_check_inductive_default = true

(* ********** *) 

type ic3_print_to_file = string option
    
let ic3_print_to_file_default = None

(* ********** *) 

type ic3_inductively_generalize = int
    
let string_of_ic3_inductively_generalize = string_of_int

let ic3_inductively_generalize_default = 1

(* ********** *) 

type ic3_block_in_future = bool
    
let string_of_ic3_block_in_future = string_of_bool

let ic3_block_in_future_default = true

(* ********** *) 

type ic3_block_in_future_first = bool
    
let string_of_ic3_block_in_future_first = string_of_bool

let ic3_block_in_future_first_default = true

(* ********** *) 

type ic3_fwd_prop_non_gen = bool
    
let string_of_ic3_fwd_prop_non_gen = string_of_bool

let ic3_fwd_prop_non_gen_default = true

(* ********** *) 

type ic3_fwd_prop_ind_gen = bool
    
let string_of_ic3_fwd_prop_ind_gen = string_of_bool

let ic3_fwd_prop_ind_gen_default = true

(* ********** *) 

type ic3_fwd_prop_subsume = bool
    
let string_of_ic3_fwd_prop_subsume = string_of_bool

let ic3_fwd_prop_subsume_default = true

(* ********** *) 

type ic3_use_invgen = bool
    
let string_of_ic3_use_invgen = string_of_bool

let ic3_use_invgen_default = true

(* ********** *) 

type ic3_qe = [ `Z3 | `Z3_impl | `Z3_impl2 | `Cooper ]
    
let ic3_qe_of_string = function
  | "Z3" -> `Z3
  | "Z3-impl" -> `Z3_impl
  | "Z3-impl2" -> `Z3_impl2
  | "cooper" -> `Cooper
  | _ -> raise (Arg.Bad "Bad value for --ic3_qe")

let string_of_ic3_qe = function 
  | `Z3 -> "Z3"
  |  `Z3_impl -> "Z3-impl"
  |  `Z3_impl2 -> "Z3-impl2"
  | `Cooper -> "cooper"

let ic3_qe_values = "Z3, Z3-impl, Z3-impl-2, cooper"

let ic3_qe_default = `Cooper

(* ********** *) 

type ic3_extract = [ `First | `Vars ]
    
let ic3_extract_of_string = function
  | "first" -> `First
  | "vars" -> `Vars
  | _ -> raise (Arg.Bad "Bad value for --ic3_extract")

let string_of_ic3_extract = function 
  | `First -> "first"
  | `Vars -> "vars"

let ic3_extract_values = "first, vars"

let ic3_extract_default = `First


(* ********** *) 

type ic3_abstr = [ `None | `IA ] 

let ic3_abstr_of_string = function
| "None" -> `None
| "IA" -> `IA
| _ -> raise (Arg.Bad "Bad value for --ic3_abstr")

let string_of_ic3_abstr = function
| `IA -> "IA"
| `None -> "None"

let ic3_abstr_values = "IA, None"

let ic3_abstr_default = `None

(* ********** *)

type modular = bool
let modular_values = "true, false"
let modular_default = false

type compositional = bool
let compositional_values = "true, false"
let compositional_default = false

(* ********** *) 
 
type cooper_order_var_by_elim = bool 
     
let cooper_order_var_by_elim_values = "true, false"
 
let cooper_order_var_by_elim_default = false
 
(* ********** *) 
 
type cooper_general_lbound = bool
     
let cooper_general_lbound_values = "true, false"
 
let cooper_general_lbound_default = false


(* ********** *)

(* testgen things. *)

type testgen_active = bool
let testgen_active_default = false

type testgen_lustrec = string option
let testgen_lustrec_default = None

type testgen_out_dir = string
let testgen_out_dir_default = "."

type testgen_len = int
let testgen_len_default = 5


(* ********** *)

(* INVGEN things. *)

type invgengraph_prune_trivial = bool

let invgengraph_prune_trivial_default = true

type invgengraph_max_succ = int

let invgengraph_max_succ_default = 1

type invgengraph_lift_candidates = bool

let invgengraph_lift_candidates_default = false

type invgengraph_mine_trans = bool

let invgengraph_mine_trans_default = true

type invgengraph_renice = int

let invgengraph_renice_default = 0


(* ********** *)

(* C2I things. *)

type c2i_dnf_size = int
let c2i_dnf_size_default = 3

type c2i_int_cube_size = int
let c2i_int_cube_size_default = 3

type c2i_real_cube_size = int
let c2i_real_cube_size_default = 3

type c2i_modes = bool
let c2i_modes_default = true

(* ********** *) 

type interpreter_input_file = string 

let interpreter_input_file_of_string s = s

let string_of_interpreter_input_file s = s 

let interpreter_input_file_default = ""

(* ********** *) 

type interpreter_steps = int 

let interpreter_steps_default = 0

(* ********** *) 

type input_format = [ `Lustre | `Horn | `Native ]
    
let input_format_of_string = function
  | "lustre" -> `Lustre
  | "horn" -> `Horn
  | "native" -> `Native
  | _ -> raise (Arg.Bad "Bad value for --input-format")

let string_of_input_format = function 
  | `Lustre -> "lustre"
  | `Horn -> "horn"
  | `Native -> "native"

let input_format_values = "lustre, native"

let input_format_default = `Lustre

(* ********** *) 

type lustre_main = string option

let lustre_main_of_string s = Some s

let string_of_lustre_main = function None -> "(none)" | Some s -> s

let lustre_main_default = None

(* ********** *) 

type lustre_flatten_arrays = bool

let string_of_lustre_flatten_arrays = string_of_bool

let lustre_flatten_arrays_default = false

(* ********** *) 

let debug_default = []

(* ********** *) 

let debug_log_default = None

(* ********** *) 

let log_level_default = L_warn

(* ********** *) 

let log_format_xml_default = false

(* ********** *) 

(* All flags *)
type flags = 
  { mutable timeout_wall : float;
    mutable timeout_virtual : float;
    mutable smtsolver : smtsolver;
    mutable smtlogic : smtlogic;
    mutable z3_bin : z3_bin;
    mutable smt_check_sat_assume : smt_check_sat_assume;
    mutable smt_short_names : smt_short_names;
    mutable cvc4_bin : cvc4_bin;
    mutable mathsat5_bin : mathsat5_bin;
    mutable yices_bin : yices_bin;
    mutable yices2smt2_bin : yices2smt2_bin;
    mutable smt_trace : smt_trace;
    mutable smt_trace_dir : smt_trace_dir;
    mutable enable : enable ;
    mutable disable : enable ;
    mutable check_version : check_version;
    mutable bmc_max : bmc_max;
    mutable bmc_check_unroll : bmc_check_unroll;
    mutable ind_compress : ind_compress;
    mutable ind_compress_equal : ind_compress_equal;
    mutable ind_compress_same_succ : ind_compress_same_succ;
    mutable ind_compress_same_pred : ind_compress_same_pred;
    mutable ind_lazy_invariants : ind_lazy_invariants;
    (* mutable ind_print_inductive_cex : ind_print_inductive_cex; *)
    mutable ic3_qe : ic3_qe;
    mutable ic3_extract : ic3_extract;
    mutable ic3_check_inductive : ic3_check_inductive;
    mutable ic3_print_to_file : ic3_print_to_file;
    mutable ic3_inductively_generalize : ic3_inductively_generalize;
    mutable ic3_block_in_future : ic3_block_in_future;
    mutable ic3_block_in_future_first : ic3_block_in_future_first;
    mutable ic3_fwd_prop_non_gen : ic3_fwd_prop_non_gen;
    mutable ic3_fwd_prop_ind_gen : ic3_fwd_prop_ind_gen;
    mutable ic3_fwd_prop_subsume : ic3_fwd_prop_subsume;
    mutable ic3_use_invgen : ic3_use_invgen;
    mutable ic3_abstr : ic3_abstr;
    mutable modular : modular;
    mutable compositional : compositional;
    mutable cooper_order_var_by_elim : cooper_order_var_by_elim;
    mutable cooper_general_lbound : cooper_general_lbound;
    mutable testgen_active : testgen_active;
    mutable testgen_lustrec : testgen_lustrec;
    mutable testgen_out_dir : testgen_out_dir;
    mutable testgen_len : testgen_len;
    mutable invgengraph_prune_trivial : invgengraph_prune_trivial;
    mutable invgengraph_max_succ : invgengraph_max_succ;
    mutable invgengraph_lift_candidates : invgengraph_lift_candidates;
    mutable invgengraph_mine_trans : invgengraph_mine_trans;
    mutable invgengraph_renice : invgengraph_renice;
    mutable c2i_dnf_size : c2i_dnf_size;
    mutable c2i_int_cube_size : c2i_int_cube_size;
    mutable c2i_real_cube_size : c2i_real_cube_size;
    mutable c2i_modes : c2i_modes;
    mutable interpreter_input_file : interpreter_input_file;
    mutable interpreter_steps : interpreter_steps;
    mutable lustre_main : lustre_main;
    mutable lustre_flatten_arrays : lustre_flatten_arrays;
    mutable debug : string list;
    mutable debug_log : string option;
    mutable log_level : log_level;
    mutable log_format_xml : bool;
    mutable input_format : input_format;
    mutable input_file : string option }
    
(* Defaults for all flags *)
let flags = 
  { timeout_wall = timeout_wall_default;
    timeout_virtual = timeout_virtual_default;
    smtsolver = smtsolver_default;
    smtlogic = smtlogic_default;
    z3_bin = z3_bin_default;
    smt_check_sat_assume = smt_check_sat_assume_default;
    smt_short_names = smt_short_names_default;
    cvc4_bin = cvc4_bin_default;
    mathsat5_bin = mathsat5_bin_default;
    yices_bin = yices_bin_default;
    yices2smt2_bin = yices2smt2_bin_default;
    smt_trace = smt_trace_default;
    smt_trace_dir = smt_trace_dir_default;
    enable = enable_default_init;
    disable = disable_default_init;
    check_version = check_version_default;
    bmc_max = bmc_max_default;
    bmc_check_unroll = bmc_check_unroll_default;
    ind_compress = ind_compress_default;
    ind_compress_equal = ind_compress_equal_default;
    ind_compress_same_succ = ind_compress_same_succ_default;
    ind_compress_same_pred = ind_compress_same_pred_default;
    ind_lazy_invariants = ind_lazy_invariants_default;
    (* ind_print_inductive_cex = ind_print_inductive_cex_default; *)
    ic3_qe = ic3_qe_default;
    ic3_extract = ic3_extract_default;
    ic3_check_inductive = ic3_check_inductive_default;
    ic3_print_to_file = ic3_print_to_file_default;
    ic3_inductively_generalize = ic3_inductively_generalize_default;
    ic3_fwd_prop_non_gen = ic3_fwd_prop_non_gen_default;
    ic3_fwd_prop_ind_gen = ic3_fwd_prop_ind_gen_default;
    ic3_block_in_future = ic3_block_in_future_default;
    ic3_block_in_future_first = ic3_block_in_future_first_default;
    ic3_fwd_prop_subsume = ic3_fwd_prop_subsume_default;
    ic3_use_invgen = ic3_use_invgen_default;
    ic3_abstr = ic3_abstr_default;
    compositional = compositional_default;
    modular = modular_default;
    cooper_order_var_by_elim = cooper_order_var_by_elim_default;
    cooper_general_lbound = cooper_general_lbound_default;
    testgen_active = testgen_active_default;
    testgen_lustrec = testgen_lustrec_default;
    testgen_out_dir = testgen_out_dir_default;
    testgen_len = testgen_len_default;
    invgengraph_prune_trivial = invgengraph_prune_trivial_default;
    invgengraph_max_succ = invgengraph_max_succ_default;
    invgengraph_lift_candidates = invgengraph_lift_candidates_default;
    invgengraph_mine_trans = invgengraph_mine_trans_default;
    invgengraph_renice = invgengraph_renice_default;
    c2i_dnf_size = c2i_dnf_size_default;
    c2i_int_cube_size = c2i_int_cube_size_default;
    c2i_real_cube_size = c2i_real_cube_size_default;
    c2i_modes = c2i_modes_default;
    interpreter_input_file = interpreter_input_file_default;
    interpreter_steps = interpreter_steps_default;
    lustre_main = lustre_main_default;
    lustre_flatten_arrays = lustre_flatten_arrays_default;
    debug = debug_default;
    debug_log = debug_log_default;
    log_level = log_level_default;
    log_format_xml = log_format_xml_default;
    input_format = input_format_default;
    input_file = None } 

(* ********** *) 

let timeout_wall_action o = flags.timeout_wall <- o  

let timeout_wall_spec = 
  ("--timeout_wall", 
   Arg.Float timeout_wall_action, 
   Format.sprintf "wallclock timeout (default: %1.f)" timeout_wall_default)

(* ********** *) 

let timeout_virtual_action o = flags.timeout_virtual <- o  

let timeout_virtual_spec = 
  ("--timeout_virtual", 
   Arg.Float timeout_virtual_action, 
   Format.sprintf "CPU timeout (default: %1.f)" timeout_virtual_default)

(* ********** *) 

let smtsolver_action o = flags.smtsolver <- (smtsolver_of_string o)
  
let smtsolver_spec = 
  ("--smtsolver", 
   Arg.String smtsolver_action, 
   Format.sprintf "choose SMT solver (available: %s, default: %s)"
                  smtsolver_values (string_of_smtsolver smtsolver_default))

(* ********** *) 

let smtlogic_action o = flags.smtlogic <- (smtlogic_of_string o)
  
let smtlogic_spec = 
  ("--smtlogic", 
   Arg.String smtlogic_action, 
   "select logic for SMT solvers (\"none\" for no logic (default), and \
    \"detect\" to detect with the input system, other SMTLIB logics will be \
    passed to the solver)")

(* ********** *) 

let z3_bin_action o = flags.z3_bin <- (z3_bin_of_string o)
  
let z3_bin_spec = 
  ("--z3_bin", 
   Arg.String z3_bin_action, 
   Format.sprintf "executable of Z3 solver (default: %s)"
                  (string_of_z3_bin z3_bin_default))

(* ********** *) 

let smt_check_sat_assume_action o = flags.smt_check_sat_assume <- o
  
let smt_check_sat_assume_spec = 
  ("--smt_check_sat_assume", 
   Arg.Bool smt_check_sat_assume_action, 
   Format.sprintf
     "Use check-sat with assumptions, or simulate with push/pop \
      when false (default: %B)"
     smt_check_sat_assume_default)

(* ********** *) 

let smt_short_names_action o = flags.smt_short_names <- o
  
let smt_short_names_spec = 
  ("--smt_short_names", 
   Arg.Bool smt_short_names_action, 
   Format.sprintf
     "Send short variables names to SMT solver, send full names if false (default: %B)"
     smt_short_names_default)

(* ********** *) 

let cvc4_bin_action o = flags.cvc4_bin <- (cvc4_bin_of_string o)
  
let cvc4_bin_spec = 
  ("--cvc4_bin", 
   Arg.String cvc4_bin_action, 
   Format.sprintf "executable of CVC4 solver (default: %s)"
                  (string_of_cvc4_bin cvc4_bin_default))

(* ********** *) 

let mathsat5_bin_action o = flags.mathsat5_bin <- (mathsat5_bin_of_string o)
  
let mathsat5_bin_spec = 
  ("--mathsat5_bin", 
   Arg.String mathsat5_bin_action, 
   Format.sprintf "executable of MathSAT5 solver (default: %s)"
                  (string_of_mathsat5_bin mathsat5_bin_default))

(* ********** *) 

let yices_bin_action o = flags.yices_bin <- (yices_bin_of_string o)
  
let yices_bin_spec = 
  ("--yices_bin", 
   Arg.String yices_bin_action, 
   Format.sprintf "executable of Yices solver (default: %s)"
                  (string_of_yices_bin yices_bin_default))

(* ********** *) 

let yices2smt2_bin_action o =
  flags.yices2smt2_bin <- (yices2smt2_bin_of_string o)
  
let yices2smt2_bin_spec = 
  ("--yices2_bin", 
   Arg.String yices2smt2_bin_action, 
   Format.sprintf "executable of Yices2 SMT2 solver (default: %s)"
                  (string_of_yices2smt2_bin yices2smt2_bin_default))

(* ********** *) 

let smt_trace_action o = flags.smt_trace <- true
  
let smt_trace_spec = 
  ("--smt_trace", 
   Arg.Unit smt_trace_action, 
   Format.sprintf "Write all SMT commands to files")

(* ********** *) 

let smt_trace_dir_action o = flags.smt_trace_dir <- o
  
let smt_trace_dir_spec = 
  ("--smt_trace_dir", 
   Arg.String smt_trace_dir_action, 
   Format.sprintf "Directory for trace logs of SMT commands (default: %s)"
                  smt_trace_dir_default)

(* ********** *) 

let enable_action o = 

  (* Ensure the each module is at most once in flags.enable *)
  let mdl = kind_module_of_string o in
  if not (List.mem mdl flags.enable) then flags.enable <- mdl :: flags.enable
  
let enable_spec = 
  ("--enable", 
   Arg.String enable_action, 
   Format.sprintf "enable Kind module (available: %s, default: %s)"
                  enable_values (string_of_enable enable_default_after))

(* ********** *) 

let disable_action o = 

  (* Ensure the each module is at most once in flags.disable *)
  let mdl = kind_module_of_string o in
  if not (List.mem mdl flags.disable) then
    flags.disable <- mdl :: flags.disable
  
let disable_spec = 
  ("--disable", 
   Arg.String disable_action,
   Format.sprintf "disable Kind module (available: %s, default enabled: %s)"
                  enable_values (string_of_enable enable_default_after))

(* ********** *) 

let check_version_action () = flags.check_version <- true
  
let check_version_spec = 
  ("--version", 
   Arg.Unit check_version_action, 
   Format.sprintf "Output version information and exit")

(* ********** *) 

let bmc_max_action o = flags.bmc_max <- o
  
let bmc_max_spec = 
  ("--bmc_max", 
   Arg.Int bmc_max_action, 
   Format.sprintf "(BMC, IND) Maximal number of iterations (default: %d, unlimited: 0)" bmc_max_default)

(* ********** *) 

let bmc_check_unroll_action o = flags.bmc_check_unroll <- o
  
let bmc_check_unroll_spec = 
  ("--bmc_check_unroll", 
   Arg.Bool bmc_check_unroll_action, 
   Format.sprintf "(BMC) Check that the unrolling alone is satisfiable (default: %b)" bmc_check_unroll_default)

(* ********** *) 

let ind_compress_action o = flags.ind_compress <- o
  
let ind_compress_spec = 
  ("--ind_compress", 
   Arg.Bool ind_compress_action, 
   Format.sprintf "(IND) Compress inductive counterexamples (default: %B)"
                  ind_compress_default)

(* ********** *) 

let ind_compress_equal_action o = flags.ind_compress_equal <- o
  
let ind_compress_equal_spec = 
  ("--ind_compress_equal", 
   Arg.Bool ind_compress_equal_action, 
   Format.sprintf "(IND) Compress inductive counterexamples for states equal \
                   modulo inputs (default: %B)" ind_compress_equal_default)

(* ********** *) 

let ind_compress_same_succ_action o = flags.ind_compress_same_succ <- o
  
let ind_compress_same_succ_spec = 
  ("--ind_compress_same_succ", 
   Arg.Bool ind_compress_same_succ_action, 
   Format.sprintf "(IND) Compress inductive counterexamples for states \
                   with same successors (default: %B)"
                  ind_compress_same_succ_default)

(* ********** *) 

let ind_compress_same_pred_action o = flags.ind_compress_same_pred <- o
  
let ind_compress_same_pred_spec = 
  ("--ind_compress_same_pred", 
   Arg.Bool ind_compress_same_pred_action, 
   Format.sprintf "(IND) Compress inductive counterexamples for states \
                   with same predecessors (default: %B)"
                  ind_compress_same_pred_default)

(* ********** *) 

let ind_lazy_invariants_action o = flags.ind_lazy_invariants <- o
  
let ind_lazy_invariants_spec = 
  ("--ind_lazy_invariants", 
   Arg.Bool ind_lazy_invariants_action, 
   Format.sprintf "(IND) Asserts invariants lazily (default: %B)" ind_lazy_invariants_default)

(* ********** *) 
(* 
let ind_print_inductive_cex_action o = flags.ind_print_inductive_cex <- o
  
let ind_print_inductive_cex_spec = 
  ("--ind_print_inductive_cex", 
   Arg.Bool ind_print_inductive_cex_action, 
   Format.sprintf "(IND) Print inductive counterexamples (default: %B)"
                  ind_print_inductive_cex_default) *)

(* ********** *) 

let ic3_qe_action o = flags.ic3_qe <- (ic3_qe_of_string o)
  
let ic3_qe_spec = 
  ("--ic3_qe", 
   Arg.String ic3_qe_action, 
   Format.sprintf "(IC3) choose quantifier elimination algorithm \
                   (available: %s, default: %s)"
                  ic3_qe_values (string_of_ic3_qe ic3_qe_default))

(* ********** *) 

let ic3_extract_action o = flags.ic3_extract <- (ic3_extract_of_string o)
  
let ic3_extract_spec = 
  ("--ic3_extract", 
   Arg.String ic3_extract_action, 
   Format.sprintf "(IC3) Heuristics for extraction of implicant \
                   (available: %s, default: %s)"
                  ic3_extract_values
                  (string_of_ic3_extract ic3_extract_default))

(* ********** *) 

let ic3_check_inductive_action o = flags.ic3_check_inductive <- o
  
let ic3_check_inductive_spec = 
  ("--ic3_check_inductive", 
   Arg.Bool ic3_check_inductive_action, 
   Format.sprintf "(IC3) Check inductiveness of blocking clauses (default: %s)"
                  (string_of_ic3_check_inductive ic3_check_inductive_default))

(* ********** *) 

let ic3_print_to_file_action o = 
  flags.ic3_print_to_file <- Some o
  
let ic3_print_to_file_spec = 
  ("--ic3_print_to_file", 
   Arg.String ic3_print_to_file_action, 
   Format.sprintf "(IC3) Output file for blocking clauses (default: stdout)")

(* ********** *) 

let ic3_inductively_generalize_action o = flags.ic3_inductively_generalize <- o
  
let ic3_inductively_generalize_spec = 
  ("--ic3_inductively_generalize", 
   Arg.Int ic3_inductively_generalize_action, 
   Format.sprintf "(IC3) Inductively generalize blocking clauses before forward propagation (0 = none, 1 = normal IG, 2 = IG with ordering) (default: %s)" (string_of_ic3_inductively_generalize ic3_inductively_generalize_default))

(* ********** *) 

let ic3_block_in_future_action o = flags.ic3_block_in_future <- o
  
let ic3_block_in_future_spec = 
  ("--ic3_block_in_future", 
   Arg.Bool ic3_block_in_future_action, 
   Format.sprintf "(IC3) Block counterexample in future frames (default: %s)"
                  (string_of_ic3_block_in_future ic3_block_in_future_default))

(* ********** *) 
 
let ic3_block_in_future_first_action o = flags.ic3_block_in_future_first <- o
  
let ic3_block_in_future_first_spec = 
  ("--ic3_block_in_future_first", 
   Arg.Bool ic3_block_in_future_first_action, 
   Format.sprintf "(IC3) Block counterexample in future frames first before returning to frame (default: %s)"
                  (string_of_ic3_block_in_future_first ic3_block_in_future_first_default))

(* ********** *) 
 
let ic3_fwd_prop_non_gen_action o = flags.ic3_fwd_prop_non_gen <- o
  
let ic3_fwd_prop_non_gen_spec = 
  ("--ic3_fwd_prop_non_gen", 
   Arg.Bool ic3_fwd_prop_non_gen_action, 
   Format.sprintf "(IC3) Also propagate clauses before generalization (default: %s)"
                  (string_of_ic3_fwd_prop_non_gen ic3_fwd_prop_non_gen_default))

(* ********** *) 
 
let ic3_fwd_prop_ind_gen_action o = flags.ic3_fwd_prop_ind_gen <- o
  
let ic3_fwd_prop_ind_gen_spec = 
  ("--ic3_fwd_prop_ind_gen", 
   Arg.Bool ic3_fwd_prop_ind_gen_action, 
   Format.sprintf "(IC3) Inductively generalize all clauses after forward propagation (default: %s)"
                  (string_of_ic3_fwd_prop_ind_gen ic3_fwd_prop_ind_gen_default))

(* ********** *) 
 
let ic3_fwd_prop_subsume_action o = flags.ic3_fwd_prop_subsume <- o
  
let ic3_fwd_prop_subsume_spec = 
  ("--ic3_fwd_prop_subsume", 
   Arg.Bool ic3_fwd_prop_subsume_action, 
   Format.sprintf "(IC3) Subsumption in forward propagation (default: %s)"
                  (string_of_ic3_fwd_prop_subsume ic3_fwd_prop_subsume_default))
  
(* ********** *) 

let testgen_active_action o = flags.testgen_active <- o
                                       
let testgen_active_spec = 
  ("--testgen", 
   Arg.Bool testgen_active_action,
   Format.sprintf
     "@[<v 7>@,(default: %b)@ \
      Activates test generation.@]"
     testgen_active_default)
  
(* ********** *) 

let testgen_lustrec_action o = flags.testgen_lustrec <- Some o
                                       
let testgen_lustrec_spec = 
  ("--testgen_lustrec", 
   Arg.String testgen_lustrec_action,
   Format.sprintf
     "@[<v 7>@,(default: %s)@ \
      Sets the command for the lustreC compiler and activates@ \
      oracle compilation.@]"
     (match testgen_lustrec_default with | Some def -> def | _ -> "inactive"))
  
(* ********** *) 

let testgen_out_dir_action o = flags.testgen_out_dir <- o
                                       
let testgen_out_dir_spec = 
  ("--testgen_out", 
   Arg.String testgen_out_dir_action,
   Format.sprintf
     "@[<v 7>@,(default: %s)@ \
      The directory to write test generation files into.@]"
     testgen_out_dir_default)
  
(* ********** *) 
  
let testgen_len_action o = flags.testgen_len <- o
                                       
let testgen_len_spec = 
  ("--testgen_len", 
   Arg.Int testgen_len_action,
   Format.sprintf
     "@[<v 7>@,(default: %d)@ \
      Maximimum length for test generation.@]"
     testgen_len_default)

(* ********** *) 
 
let ic3_use_invgen_action o = flags.ic3_use_invgen <- o
  
let ic3_use_invgen_spec = 
  ("--ic3_use_invgen", 
   Arg.Bool ic3_use_invgen_action, 
   Format.sprintf "(IC3) Use invariants from invariant generators (default: %s)"
                  (string_of_ic3_use_invgen ic3_use_invgen_default))

(* ********** *) 

let ic3_abstr_action o = flags.ic3_abstr <- (ic3_abstr_of_string o)
  
let ic3_abstr_spec = 
  ("--ic3_abstr", 
   Arg.String ic3_abstr_action, 
   Format.sprintf "(IC3) choose method of abstraction in IC3 \"
                   (available: %s, default: %s)"
                  ic3_abstr_values (string_of_ic3_abstr ic3_abstr_default))
(* ********** *) 
 
let modular_action o = flags.modular <- o
                                          
let modular_spec = 
  ("--modular", 
   Arg.Bool modular_action, 
   Format.sprintf
    "bottom-up analysis of each node (available: %s, default: %B)"
    modular_values
    modular_default)
(* ********** *) 
 
let compositional_action o = flags.compositional <- o
                                          
let compositional_spec = 
  ("--compositional", 
   Arg.Bool compositional_action, 
   Format.sprintf
    "abstract subnodes with a contract (available: %s, default: %B)"
    compositional_values
    compositional_default)

(* ********** *)
 
let cooper_order_var_by_elim_action o = flags.cooper_order_var_by_elim <- o
                                          
let cooper_order_var_by_elim_spec = 
  ("--cooper_order_var_by_elim", 
   Arg.Bool cooper_order_var_by_elim_action, 
   Format.sprintf "(Cooper QE) Order variables in polynomials by order of \
                   elimination (available: %s, default: %B)"
                  cooper_order_var_by_elim_values
                  cooper_order_var_by_elim_default)
  
(* ********** *) 
  
let cooper_general_lbound_action o = flags.cooper_general_lbound <- o
                                       
let cooper_general_lbound_spec = 
  ("--cooper_general_lbound", 
   Arg.Bool cooper_general_lbound_action, 
   Format.sprintf "(Cooper QE) Choose lower bounds containing variables (available: %s, default: %B)" cooper_general_lbound_values cooper_general_lbound_default)
  
(* ********** *) 
  
let invgengraph_prune_trivial_action o = flags.invgengraph_prune_trivial <- o
                                       
let invgengraph_prune_trivial_spec = 
  ("--invgen_prune_trivial", 
   Arg.Bool invgengraph_prune_trivial_action,
   Format.sprintf
     "Invariant generation will only look for top node invariants (default: %B)."
     invgengraph_prune_trivial_default)
  
let invgengraph_max_succ_action o = flags.invgengraph_max_succ <- o
                                       
let invgengraph_max_succ_spec = 
  ("--invgen_max_succ", 
   Arg.Int invgengraph_max_succ_action,
   Format.sprintf
     "Maximal number of successive iterations for subsystems (default: %d)."
     invgengraph_max_succ_default)
  
let invgengraph_lift_candidates_action o = flags.invgengraph_lift_candidates <- o
                                       
let invgengraph_lift_candidates_spec = 
  ("--invgen_lift_candidates", 
   Arg.Bool invgengraph_lift_candidates_action,
   Format.sprintf
     "Invariant generation will only look for top node invariants (default: %B)."
     invgengraph_lift_candidates_default)
  
let invgengraph_mine_trans_action o = flags.invgengraph_mine_trans <- o
                                       
let invgengraph_mine_trans_spec = 
  ("--invgen_mine_trans", 
   Arg.Bool invgengraph_mine_trans_action,
   Format.sprintf
     "Invariant generation will extract candidate terms from the transition predicate (default: %B)."
     invgengraph_mine_trans_default)

let invgengraph_renice_action o = flags.invgengraph_renice <- o
                                       
let invgengraph_renice_spec = 
  ("--invgen_renice", 
   Arg.Int invgengraph_renice_action,
   "Renice invariant generation process. Give a positive argument to lower priority.")
  
(* ********** *) 

let c2i_dnf_size_action o = flags.c2i_dnf_size <- o
                                       
let c2i_dnf_size_spec = 
  ("--c2i_dnf", 
   Arg.Int c2i_dnf_size_action,
   Format.sprintf
    "Number of disjuncts in the DNF constructed by C2I (default %d)."
    c2i_dnf_size_default)

let c2i_int_cube_size_action o = flags.c2i_int_cube_size <- o
                                       
let c2i_int_cube_size_spec = 
  ("--c2i_int_cubes", 
   Arg.Int c2i_int_cube_size_action,
   Format.sprintf
    "Number of int cubes in the DNF constructed by C2I (default %d)."
    c2i_int_cube_size_default)

let c2i_real_cube_size_action o = flags.c2i_real_cube_size <- o
                                       
let c2i_real_cube_size_spec = 
  ("--c2i_real_cubes", 
   Arg.Int c2i_real_cube_size_action,
   Format.sprintf
    "Number of real cubes in the DNF constructed by C2I (default %d)."
    c2i_real_cube_size_default)

let c2i_modes_action o = flags.c2i_modes <- o
                                       
let c2i_modes_spec = 
  ("--c2i_modes", 
   Arg.Bool c2i_modes_action,
   Format.sprintf
    "Activates mode subcandidates. Subsumes c2i_dnf_size (default %b)."
    c2i_modes_default)
  
(* ********** *) 

let interpreter_input_file_action o = flags.interpreter_input_file <- o
                                       
let interpreter_input_file_spec = 
  ("--interpreter_input_file", 
   Arg.String interpreter_input_file_action, 
   Format.sprintf "(Interpreter) Read input from file")

(* ********** *) 

let interpreter_steps_action o = flags.interpreter_steps <- o
                                       
let interpreter_steps_spec = 
  ("--interpreter_steps", 
   Arg.Int interpreter_steps_action, 
   Format.sprintf "(Interpreter) Run number of steps, override the number of \
                   steps given in the input file")

(* ********** *) 

let lustre_main_action o = flags.lustre_main <- Some o
                                       
let lustre_main_spec = 
  ("--lustre_main", 
   Arg.String lustre_main_action, 
   Format.sprintf "Use the given node as top node in Lustre input \
                   (default: --%%MAIN annotation)")

(* ********** *) 

let lustre_flatten_arrays_action o = flags.lustre_flatten_arrays <- o
                                       
let lustre_flatten_arrays_spec = 
  ("--lustre_flatten_arrays", 
   Arg.Bool lustre_flatten_arrays_action, 
   Format.sprintf
     "Flatten arrays to one stream per element. If false, use quantified definitions. \
      (default: %B)"
     lustre_flatten_arrays_default)

(* ********** *) 

let debug_action o = flags.debug <- o :: flags.debug 
  
let debug_spec = 
  ("--debug", 
   Arg.String debug_action, 
   Format.sprintf "enable debug output for a section, give one --debug option \
                   for each section to be enabled")

(* ********** *) 

let debug_log_action o = flags.debug_log <- Some o
  
let debug_log_spec = 
  ("--debug-log", 
   Arg.String debug_log_action, 
   Format.sprintf "output debug messages to file (default: stdout)")

(* ********** *) 

let log_level_action o () = flags.log_level <- o
  
let log_level_off_spec = 
  ("-qq", 
   Arg.Unit (log_level_action L_off), 
   Format.sprintf "Disable output completely")

let log_level_fatal_spec = 
  ("-q", 
   Arg.Unit (log_level_action L_fatal), 
   Format.sprintf "Disable output, fatal errors only")

let log_level_error_spec = 
  ("-s", 
   Arg.Unit (log_level_action L_error), 
   Format.sprintf "Silence output, errors only")

let log_level_info_spec = 
  ("-v", 
   Arg.Unit (log_level_action L_info), 
   Format.sprintf "Output informational messages")

let log_level_debug_spec = 
  ("-vv", 
   Arg.Unit (log_level_action L_debug), 
   Format.sprintf "Output informational and debug messages")

let log_level_trace_spec = 
  ("-vvv", 
   Arg.Unit (log_level_action L_trace), 
   Format.sprintf "Output informational, debug and trace messages")

(* ********** *) 

let log_format_xml_action o () = flags.log_format_xml <- o

let log_format_xml_spec = 
  ("-xml", 
   Arg.Unit (log_format_xml_action true), 
   Format.sprintf "Output in XML format")

(* ********** *) 

let input_format_action o = flags.input_format <- (input_format_of_string o)
  
let input_format_spec = 
  ("--input-format", 
   Arg.String input_format_action, 
   Format.sprintf "Format of input file (available: %s, default: %s)"
                  input_format_values
                  (string_of_input_format input_format_default))


(* ********************************************************************** *)
(* Pretty-printing of flags                                               *)
(* ********************************************************************** *)


(* ********************************************************************** *)
(* Accessor functions for flags                                           *)
(* ********************************************************************** *)

let timeout_wall () = flags.timeout_wall

let timeout_virtual () = flags.timeout_virtual

let smtsolver () = flags.smtsolver 

let smtlogic () = flags.smtlogic 

let z3_bin () = flags.z3_bin

let smt_check_sat_assume () = flags.smt_check_sat_assume

let smt_short_names () = flags.smt_short_names

let cvc4_bin () = flags.cvc4_bin

let mathsat5_bin () = flags.mathsat5_bin

let yices_bin () = flags.yices_bin

let yices2smt2_bin () = flags.yices_bin

let smt_trace () = flags.smt_trace

let smt_trace_dir () = flags.smt_trace_dir

let enable () = flags.enable 

let check_version () = flags.check_version 

let bmc_max () = flags.bmc_max 

let bmc_check_unroll () = flags.bmc_check_unroll 

let ind_compress () = flags.ind_compress 

let ind_compress_equal () = flags.ind_compress_equal 

let ind_compress_same_succ () = flags.ind_compress_same_succ 

let ind_compress_same_pred () = flags.ind_compress_same_pred 

let ind_lazy_invariants () = flags.ind_lazy_invariants

(* let ind_print_inductive_cex () = flags.ind_print_inductive_cex  *)

let ic3_qe () = flags.ic3_qe 

let set_ic3_qe f = flags.ic3_qe <- f

let ic3_extract () = flags.ic3_extract 

let ic3_check_inductive () = flags.ic3_check_inductive 

let ic3_inductively_generalize () = true

let ic3_print_to_file () = flags.ic3_print_to_file

let ic3_inductively_generalize () = flags.ic3_inductively_generalize

let ic3_block_in_future () = flags.ic3_block_in_future 

let ic3_block_in_future_first () = flags.ic3_block_in_future_first 

let ic3_fwd_prop_non_gen () = flags.ic3_fwd_prop_non_gen 

let ic3_fwd_prop_ind_gen () = flags.ic3_fwd_prop_ind_gen 

let ic3_fwd_prop_subsume () = flags.ic3_fwd_prop_subsume 

let ic3_use_invgen () = flags.ic3_use_invgen 

let ic3_abstr () = flags.ic3_abstr

let set_ic3_abstr f = flags.ic3_abstr <- f

let modular () = flags.modular

let compositional () = flags.compositional

let cooper_order_var_by_elim () = flags.cooper_order_var_by_elim

let cooper_general_lbound () = flags.cooper_general_lbound

let testgen_active () = flags.testgen_active

let testgen_lustrec () = flags.testgen_lustrec

let testgen_out_dir () = flags.testgen_out_dir

let testgen_len () = flags.testgen_len

let invgengraph_prune_trivial () = flags.invgengraph_prune_trivial

let invgengraph_max_succ () = flags.invgengraph_max_succ

let invgengraph_lift_candidates () = flags.invgengraph_lift_candidates

let invgengraph_mine_trans () = flags.invgengraph_mine_trans

let invgengraph_renice () = flags.invgengraph_renice

let c2i_dnf_size () = flags.c2i_dnf_size

let c2i_int_cube_size () = flags.c2i_int_cube_size

let c2i_real_cube_size () = flags.c2i_real_cube_size

let c2i_modes () = flags.c2i_modes

let interpreter_input_file () = flags.interpreter_input_file

let interpreter_steps () = flags.interpreter_steps

let lustre_main () = flags.lustre_main

let lustre_flatten_arrays () = flags.lustre_flatten_arrays

let debug () = flags.debug

let debug_log () = flags.debug_log

let log_level () = flags.log_level

let log_format_xml () = flags.log_format_xml

let input_format () = flags.input_format 

let input_file () = match flags.input_file with 
  | Some f -> f 
  | None -> failwith "No input file given"


(* ********************************************************************** *)
(* Parsing of command-line options into flags                             *)
(* ********************************************************************** *)

let usage_msg = 
  Format.sprintf 
    "Usage: %s [options] FILE@\nProve properties in Lustre program FILE@\n" 
    (Filename.basename Sys.executable_name)

let rec help_action () = raise (Arg.Help (Arg.usage_string speclist usage_msg))

and speclist = 
  [

    (* Wallclock timeout *)
    timeout_wall_spec;

    (* CPU timeout *)
    timeout_virtual_spec;

    (* Set SMT solver *)
    smtsolver_spec;

    (* Set SMT logic *)
    smtlogic_spec;

    (* Set executable for Z3 solver *)
    z3_bin_spec;

    (* Use check-sat with assumptions or simulate with push/pop *)
    smt_check_sat_assume_spec;

    (* Send short names to SMT solver *)
    smt_short_names_spec;

    (* Set executable for CVC4 solver *)
    cvc4_bin_spec;

    (* Set executable for MathSAT5 solver *)
    mathsat5_bin_spec;

    (* Set executable for Yices solver *)
    yices_bin_spec;

    (* Set executable for Yices2 SMT2 solver *)
    yices2smt2_bin_spec;

    (* Write all SMT commands to files *)
    smt_trace_spec;

    (* Directory for  trace logs of SMT commands *)
    smt_trace_dir_spec;

    (* Set enabled modules *)
    enable_spec;
    disable_spec;

    (* Output version information and exit *)
    check_version_spec;

    (* Maximal number of iterations in BMC *)
    bmc_max_spec;

    (* Check that the unrolling alone is satisfiable in BMC *)
    bmc_check_unroll_spec;

    (* Compress inductive counterexamples *)
    ind_compress_spec;

    (* Compress inductive counterexamples when states are equal modulo
       input *)
    ind_compress_equal_spec;

    (* Compress inductive counterexamples when states have same successors *)
    ind_compress_same_succ_spec;

    (* Compress inductive counterexamples when states have same predecessors *)
    ind_compress_same_pred_spec;

    (* Compress inductive counterexamples when states have same predecessors *)
    ind_lazy_invariants_spec;

    (* Print inductive counterexamples *)
    (* ind_print_inductive_cex_spec; *)

    (* Set QE in IC3 *)
    ic3_qe_spec;

    (* Heuristic for extraction of implicant *)
    ic3_extract_spec;

    (* Check inductiveness of blocking clauses *)
    ic3_check_inductive_spec;

    (* File for inductive of blocking clauses *)
    ic3_print_to_file_spec;

    (* Inductively generalize the blocking clause before forward propagating *)
    ic3_inductively_generalize_spec;

    (* Block counterexample in future frames *)
    ic3_block_in_future_spec;

    (* Block counterexample in future frames first before returning to frame *)
    ic3_block_in_future_first_spec;

    (* Also propagate clauses before generalization *)
    ic3_fwd_prop_non_gen_spec;

    (* Inductively generalize all clauses after forward propagation *)
    ic3_fwd_prop_ind_gen_spec;

    (* Subsumption in forward propagation *)
    ic3_fwd_prop_subsume_spec;

    (* Use invariants from invariant generators *)
    ic3_use_invgen_spec;

    (* Abstraction in IC3 *)
    ic3_abstr_spec;

    (* Modular. *)
    modular_spec ;
    (* Compositional. *)
    compositional_spec ;

    (* Set option in Cooper QE*)
    cooper_order_var_by_elim_spec;
    cooper_general_lbound_spec;

    (* Set testgen options. *)
    testgen_active_spec;
    testgen_lustrec_spec;
    testgen_out_dir_spec;
    testgen_len_spec;

    (* Set invgen options. *)
    invgengraph_prune_trivial_spec;
    invgengraph_max_succ_spec;
    invgengraph_lift_candidates_spec;
    invgengraph_mine_trans_spec;
    invgengraph_renice_spec;

    (* Set C2I options. *)
    c2i_dnf_size_spec ;
    c2i_int_cube_size_spec ;
    c2i_real_cube_size_spec ;
    c2i_modes_spec ;

    (* Read input from file *)
    interpreter_input_file_spec;

    (* Run number of steps, override the number of steps given in the
       input file *)
    interpreter_steps_spec;

    (* Main node in Lustre input *)
    lustre_main_spec;

    (* Flatten arrays to one stream per element *)
    lustre_flatten_arrays_spec;

    (* Enable debug output *)
    debug_spec;

    (* Enable debug output *)
    debug_log_spec;

    (* Set verbosity of output *)
    log_level_error_spec;
    log_level_fatal_spec;
    log_level_off_spec;
    log_level_info_spec;
    log_level_debug_spec;
    log_level_trace_spec;

    (* Set output format to XML *)
    log_format_xml_spec;

    (* Set input format *)
    input_format_spec;

    (* Display help *)
    ("-help", 
     Arg.Unit help_action, 
     " Display this list of options");
    ("--help", 
     Arg.Unit help_action, 
     "Display this list of options");
    ("-h", 
     Arg.Unit help_action, 
     "    Display this list of options")
  ]
    

let anon_action s = 
  match flags.input_file with 
    | None -> flags.input_file <- Some s
    | Some _ -> raise (Arg.Bad "More than one input file given")

let set_smtsolver = function 

  | `Z3_SMTLIB as smtsolver -> 

    (function z3_bin -> 
      flags.smtsolver <- smtsolver; 
      flags.z3_bin <- z3_bin)

  | `CVC4_SMTLIB as smtsolver -> 

    (function cvc4_bin -> 
      flags.smtsolver <- smtsolver; 
      flags.cvc4_bin <- cvc4_bin)

  | `MathSat5_SMTLIB as smtsolver -> 

    (function mathsat5_bin -> 
      flags.smtsolver <- smtsolver; 
      flags.mathsat5_bin <- mathsat5_bin)

  | `Yices_native as smtsolver -> 

    (function yices_bin -> 
      flags.smtsolver <- smtsolver; 
      flags.yices_bin <- yices_bin)

  | `Yices_SMTLIB as smtsolver -> 

    (function yices2smt2_bin -> 
      flags.smtsolver <- smtsolver; 
      flags.yices2smt2_bin <- yices2smt2_bin)

  | `detect -> (function _ -> ())

       
let parse_argv () = 
  
  (* Parse command-line arguments *)
  Arg.parse speclist anon_action usage_msg;
  
  (* Output version information only? *)
  if check_version () then 
    (Format.printf "%t@." pp_print_version; exit 0);
    
  (* Set default value if unchanged *)
  if flags.enable = enable_default_init then
    flags.enable <- enable_default_after;

  (* Remove disabled modules. *)
  flags.enable <- flags.enable |> List.filter (fun mdl ->
    List.mem mdl flags.disable |> not
  ) ;

  Format.printf "enabled: %a@.@."
    (pp_print_list (fun fmt mdl ->
        Format.fprintf fmt "%a" pp_print_kind_module mdl
      ) " ") flags.enable ;

  (* Fail if input file not set *)
  match flags.input_file with 
    | None -> 
      Format.printf 
        "%s: No input file given@\n" Sys.argv.(0);
      Arg.usage speclist usage_msg;
      exit 2
    | Some _ -> ()
      
(* 
   Local Variables:
   compile-command: "make -C .. -k"
   tuareg-interactive-program: "./kind2.top -I ./_build -I ./_build/SExpr"
   indent-tabs-mode: nil
   End: 
*)
