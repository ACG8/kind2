(* This file is part of the Kind 2 model checker.

   Copyright (c) 2015 by the Board of Trustees of the University of Iowa

   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License.  You
   may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied. See the License for the specific language governing
   permissions and limitations under the License.

*)

(* WARNING: DO NOT EDIT THE .ML FILE --- CHANGES WILL BE OVERWRITTEN

   Do not edit the .ml file but rather the .ml.in file, the .ml file
   is generated from the .ml.in file after each run of the configure
   script.

*)

open Lib

(*

type ('a, 'b) flag =
  { longname : string;
    shortname : string option;
    mutable value : 'a;
    of_arg : 'a -> 'b -> 'a;
    pp : Format.formatter -> 'a -> unit }


type int_flag = (int, int) flag

type float_flag = (float, float) flag

type bool_flag = (bool, bool) flag

type unit_flag = (unit, bool) flag

type 'a string_flag = ('a, string) flag



type smtsolver = [ `Z3_SMTLIB | `Z3_API | `CVC4_SMTLIB | `CVC4_API | `Yices ]

let smtsolver_of_string = function
  | "Z3" -> `Z3_SMTLIB
  | "Z3_SMTLIB" -> `Z3_SMTLIB
  | "Z3_API" -> `Z3_API
  | "CVC4" -> `CVC4_SMTLIB
  | "CVC4_SMTLIB" -> `CVC4_SMTLIB
  | "CVC4_API" -> `CVC4_API
  | "Yices" -> `Yices
  | _ -> raise (Invalid_argument "smtsolver_of_string")

let pp_print_smtsolver ppf =
  let p = Format.fprintf ppf in
  function
    | `Z3_SMTLIB -> p "Z3_SMTLIB"
    | `Z3_API -> p "Z3_API"
    | `CVC4_SMTLIB -> p "CVC4_SMTLIB"
    | `CVC4_API -> p "CVC4_API"
    | `Yices -> p "Yices"

let smtsolver_flag =
  { longname = "smtsolver";
    shortname = None;
    value = `Z3_SMTLIB;
    of_arg = (function _ -> smtsolver_of_string);
    pp = pp_print_smtsolver }


let kind_module_of_string = function
  | "IC3" -> `IC3
  | "BMC" -> `BMC
  | "IND" -> `IND
  | "INVGEN" -> `INVGEN
  | "interpreter" -> `Interpreter
  | _ -> raise (Invalid_argument "smtsolver_of_string")


let pp_print_kind_module ppf =
  let p = Format.fprintf ppf in
  function
    | `IC3 -> p "IC3"
    | `BMC -> p "BMC"
    | `IND -> p "IND"
    | `INVGEN -> p "INVGEN"
    | `Interpreter -> p "interpreter"


let enable_flag =
  { longname = "enable";
    shortname = Some "e";
    value = [];
    of_arg = (function curval -> (function arg -> kind_module_of_string arg :: curval));
    pp = (pp_print_list pp_print_kind_module ",@ ") }

*)


(* ********************************************************************** *)
(* Types and defaults for flags                                            *)
(* ********************************************************************** *)

(* TODO: write camlp4 code for this

   type <X> = <X1> | <X2> arg <O> default <X2> action <F> doc <D>
  
   becomes

   type <X> = <X1> | <X2>

   let <X>_of_string = function
     | "<X1>" -> <X1>
     | "<X2>" -> <X2>
     | _ raise (Arg.bad "Bad value for -<O>")

   let string_of_<X> = function
     | <X1> -> "<X1>"
     | <X2> -> "<X2>"

   let <X>_values = "<X1>, <X2>"

   let <X>_default = <X2>

   let <O>_spec =
     ("-<O>",
      String <F>,
      Format.sprintf <D> <X>_values <X>_default)

*)
  

(*   type <X> = <X1> | <X2> arg <O> default <X2> action <F> doc <D> *)

(*   type smtsolver = Z3_SMTLIB | CVC4_SMTLIB arg smtsolver default CVC4_SMTLIB action smtsolver_action doc " choose SMT solver (available: %s, default: %s" *)


(* Strings recognized as the bool value [true]. *)
let true_strings = [ "true" ; "on" ; "t" ; "1" ]
(* Strings recognized as the bool value [false]. *)
let false_strings = [ "false" ; "off" ; "f" ; "0" ]
(* String to bool. *)
let bool_of_string s =
  if List.mem s true_strings then true
  else if List.mem s false_strings then false
  else Arg.Bad (
    Format.asprintf
      "expected boolean (%a, %a), but got %s"
      (pp_print_list Format.pp_print_string ", ") true_strings
      (pp_print_list Format.pp_print_string ", ") false_strings
      s
  ) |> raise
(* Parses a bool and sets a reference. *)
let bool_arg reference = Arg.String (
  fun s -> reference := bool_of_string s
)


(* Global flags. *)
module Global = struct

  (* All the flag specification of this module. *)
  let all_specs = ref []
  let add_specs specs = all_specs := !all_specs @ specs
  let add_spec spec = add_specs [spec]


  (* Input flag. *)
  let input_file_default = None
  let input_file = ref input_file_default
  let set_input_file f = input_file := Some f
  let input_file () = !input_file


  (* Version flag. *)
  let check_version_default = false

  let check_version = ref check_version_default
  let _ = add_spec (
    "--version",
    Arg.Set check_version,
    Format.sprintf "Output version information and exit"
  )
  let check_version () = !check_version


  (* Main lustre node. *)
  let lus_main_of_string s = Some s
  let string_of_lus_main = function
    | None -> "(none)"
    | Some s -> s
  let lus_main_default = None

  let lus_main = ref lus_main_default
  let _ = add_spec (
    "--lus_main",
    Arg.String (fun str -> lus_main := Some str),
    Format.sprintf
      "Use the given node as top node in Lustre input \
      (default: \"--%%MAIN\" annotation in source if any, last node otherwise)"
  )
  let lus_main () = !lus_main


  (* Input format. *)
  type input_format = [
    `Lustre | `Horn | `Native
  ]
  let input_format_of_string = function
    | "lustre" -> `Lustre
    | "horn" -> `Horn
    | "native" -> `Native
    | _ -> raise (Arg.Bad "Bad value for --input-format")
  let string_of_input_format = function
    | `Lustre -> "lustre"
    | `Horn -> "horn"
    | `Native -> "native"
  let input_format_values = [
    `Lustre ; `Native
  ] |> List.map string_of_input_format |> String.concat ", "
  let input_format_default = `Lustre

  let input_format = ref input_format_default
  let _ = add_spec (
    "--input-format",
    Arg.String (fun str -> input_format := input_format_of_string str),
    Format.sprintf
      "Format of input file (available: %s, default: %s)"
      input_format_values
      (string_of_input_format input_format_default)
  )
  let input_format () = !input_format


  (* Output directory. *)
  let output_dir_default = "kind2"
  let output_dir = ref output_dir_default
  let _ = add_spec (
    "--output_dir",
    Arg.Set_string output_dir,
    Format.sprintf
      "output directory for SMT traces, compilation, testgen and \
      certification (default: %s)"
      output_dir_default
  )
  let output_dir () = !output_dir

  (* Active debug sections. *)
  let debug_default = []
  let debug_ref = ref debug_default
  let _ = add_spec (
    "--debug",
    Arg.String (fun str -> debug_ref := str :: !debug_ref),
    Format.sprintf
      "enable debug output for a section, give one --debug option \
      for each section to be enabled"
  )
  let debug () = !debug_ref


  (* Debug messages to file. *)
  let debug_log_default = None
  let debug_log = ref debug_log_default
  let _ = add_spec (
    "--debug-log",
    Arg.String (fun str -> debug_log := Some str),
    Format.sprintf "output debug messages to file (default: stdout)"
  )
  let debug_log () = ! debug_log


  (* Log level. *)
  let log_level_default = L_warn
  let log_level = ref log_level_default
  let _ = add_specs ([
    ( "-qq",
      Arg.Unit (fun () -> log_level := L_off),
      Format.sprintf "Disable output completely"
    ) ;
    ( "-q",
      Arg.Unit (fun () -> log_level := L_fatal),
      Format.sprintf "Disable output, fatal errors only"
    ) ;
    ( "-s",
      Arg.Unit (fun () -> log_level := L_error),
      Format.sprintf "Silence output, errors only"
    ) ;
    ( "-v",
      Arg.Unit (fun () -> log_level := L_info),
      Format.sprintf "Output informational messages"
    ) ;
    ( "-vv",
      Arg.Unit (fun () -> log_level := L_debug),
      Format.sprintf "Output informational and debug messages"
    ) ;
    ( "-vvv",
      Arg.Unit (fun () -> log_level := L_trace),
      Format.sprintf "Output informational, debug and trace messages"
    )
  ])
  let log_level () = !log_level


  (* XML log. *)
  let log_format_xml_default = false
  let log_format_xml = ref log_format_xml_default
  let _ = add_spec (
    "-xml",
    Arg.Set log_format_xml,
    Format.sprintf "Output in XML format"
  )
  let log_format_xml () = !log_format_xml


  (* Timeout. *)
  let timeout_wall_default = 0.
  let timeout_wall = ref timeout_wall_default
  let _ = add_specs ([
    ( "--timeout",
      Arg.Set_float timeout_wall,
      Format.sprintf
        "wallclock timeout in seconds (default: %1.f)"
        timeout_wall_default
    ) ;
    ( "--timeout_wall",
      Arg.Set_float timeout_wall,
      Format.sprintf "for legacy, same as \"--timeout\""
    )
  ])
  let timeout_wall () = !timeout_wall


  (* Modules enabled. *)
  type enable = kind_module list
  let kind_module_of_string = function
    | "IC3" -> `IC3
    | "BMC" -> `BMC
    | "IND" -> `IND
    | "IND2" -> `IND2
    | "INVGEN" -> `INVGEN
    | "INVGENOS" -> `INVGENOS
    | "C2I" -> `C2I
    | "interpreter" -> `Interpreter
    | unexpected -> Arg.Bad (
      Format.sprintf "Unexpected value \"%s\" for flag --enable" unexpected
    ) |> raise
  let string_of_kind_module = function
    | `IC3 -> "IC3"
    | `BMC -> "BMC"
    | `IND -> "IND"
    | `IND2 -> "IND2"
    | `INVGEN -> "INVGEN"
    | `INVGENOS -> "INVGENOS"
    | `C2I -> "C2I"
    | `Interpreter -> "interpreter"
  let string_of_enable = function
    | head :: tail -> (
      List.fold_left
        ( fun s m -> s ^ ", " ^ (string_of_kind_module m) )
        ("[" ^ (string_of_kind_module head))
        tail
      ) ^ "]"
    | [] -> "[]"
  let enable_values = [
    `IC3 ; `BMC ; `IND ; `IND2 ; `INVGEN ; `INVGENOS ; `C2I ; `Interpreter
  ] |> List.map string_of_kind_module |> String.concat ", "

  let enable_default_init = []
  let disable_default_init = []

  let enable_default_after = [
    `BMC ; `IND ; `IND2 ; `IC3 ; `INVGEN ; `INVGENOS
  ]
  let enabled = ref enable_default_init
  let disabled = ref disable_default_init
  let finalize_enabled () =
    (* If [enabled] is unchanged, set it do default after init. *)
    if !enabled = enable_default_init then (
      enabled := enable_default_after
    ) ;
    (* Remove disabled modules. *)
    enabled := !enabled |> List.filter (
      fun mdl -> List.mem mdl !disabled |> not
    )
  let _ = add_spec (
    "--enable",
    Arg.String (
      fun str ->
        let mdl = kind_module_of_string str in
        if List.mem mdl !enabled |> not
        then enabled := mdl :: !enabled
    ),
    Format.sprintf
      "enable Kind module (available: %s, default: %s)"
      enable_values
      (string_of_enable enable_default_after)
  )
  let enabled () = !enabled

  (* Modules disabled. *)
  let _ = add_spec (
    "--disable",
    Arg.String (
      fun str ->
        let mdl = kind_module_of_string str in
        if List.mem mdl !disabled |> not
        then disabled := mdl :: !disabled
    ),
    Format.sprintf "disable Kind module (available: %s, default enabled: %s)"
      enable_values (string_of_enable enable_default_after)
  )
  let disabled () = !disabled


  (* Modular mode. *)
  let modular_default = false
  let modular = ref modular_default
  let _ = add_spec (
    "--modular",
    bool_arg modular,
    Format.sprintf
      "bottom-up analysis of each node (default: %B)"
      modular_default
  )
  let modular () = !modular


  (* Reject unguarded pre's in Lustre file. *)
  let lus_strict_default = false
  let lus_strict = ref lus_strict_default
  let _ = add_spec (
    "--lus_strict",
    bool_arg lus_strict,
    Format.sprintf
      "Strict mode in Lustre: uninitialized pre and undefined \
      local variables are not allowed when this flag is present."
  )
  let lus_strict () = !lus_strict

  let lus_compile_default = false
  let lus_compile = ref lus_compile_default
  let _ = add_spec (
    "--lus_compile",
    bool_arg lus_compile,
    Format.sprintf
      "@[<v 7>@,(default: %b)@ \
      Activates compiling to Rust, deactivates everything else.@]"
      lus_compile_default
  )
  let lus_compile () = !lus_compile


  (* Returns all the flag specification of this module. *)
  let all_specs () = !all_specs
end

(* Re-exports. *)
type enable = Global.enable
type input_format = Global.input_format



(* Options related to the underlying SMT solver. *)
module Smt = struct

  (* All the flag specification of this module. *)
  let all_specs = ref []
  let add_specs specs = all_specs := !all_specs @ specs
  let add_spec spec = add_specs [spec]

  (* Active SMT solver. *)
  type solver = [
    | `Z3_SMTLIB
    | `CVC4_SMTLIB
    | `MathSat5_SMTLIB
    | `Yices_SMTLIB
    | `Yices_native
    | `detect
  ]
  let solver_of_string = function
    | "Z3" -> `Z3_SMTLIB
    | "CVC4" -> `CVC4_SMTLIB
    | "MathSat5" -> `MathSat5_SMTLIB
    | "Yices2" -> `Yices_SMTLIB
    | "Yices" -> `Yices_native
    | _ -> Arg.Bad "Bad value for --smtsolver" |> raise
  let string_of_solver = function
    | `Z3_SMTLIB -> "Z3"
    | `CVC4_SMTLIB -> "CVC4"
    | `Yices_SMTLIB -> "Yices2"
    | `Yices_native -> "Yices"
    | `MathSat5_SMTLIB -> "MathSat5"
    | `detect -> "detect"
  let solver_values = "Z3, CVC4, MathSat5, Yices, Yices2"
  let solver_default = `detect
  let solver = ref solver_default
  let _ = add_spec (
    "--smtsolver",
    Arg.String (fun str -> solver := solver_of_string str),
    Format.sprintf
      "choose SMT solver (available: %s, default: %s)"
      solver_values
      (string_of_solver solver_default)
  )
  let set_solver s = solver := s
  let solver () = !solver

  (* Active SMT logic. *)
  type logic = [
    `None | `detect | `Logic of string
  ]
  let logic_values = [
    `None ; `detect ; `Logic ("\"logic\"")
  ]
  let logic_of_string = function
    | "none" | "None" -> `None
    | "detect" | "Detect" -> `detect
    | s -> `Logic s
  let string_of_logic = function
    | `None -> "none"
    | `detect -> "detect"
    | `Logic s -> s
  let logic_default = `None
  let logic = ref logic_default
  let _ = add_spec (
    "--smtlogic",
    Arg.String (fun str -> logic := logic_of_string str),
    "select logic for SMT solvers (\"none\" for no logic (default), and \
     \"detect\" to detect with the input system, other SMTLIB logics will be \
     passed to the solver)"
  )
  let logic () = !logic

  (* Activates check-sat with assumptions when supported. *)
  let check_sat_assume_of_string s = s
  let string_of_check_sat_assume s = s
  let check_sat_assume_default = true
  let check_sat_assume = ref check_sat_assume_default
  let _ = add_spec (
    "--smt_check_sat_assume",
    bool_arg check_sat_assume,
    Format.sprintf
      "Use check-sat with assumptions, or simulate with push/pop \
       when false (default: %B)"
      check_sat_assume_default
  )
  let check_sat_assume () = !check_sat_assume

  (* Use short name for variables at SMT level. *)
  let short_names_of_string s = s
  let string_of_short_names s = s
  let short_names_default = true
  let short_names = ref short_names_default
  let _ = add_spec (
    "--smt_short_names",
    bool_arg short_names,
    Format.sprintf
      "Send short variables names to SMT solver, send full names if false \
      (default: %B)"
      short_names_default
  )
  let short_names () = !short_names

  (* Z3 binary. *)
  let z3_bin_of_string s = s
  let string_of_z3_bin s = s
  let z3_bin_default = "z3"
  let z3_bin = ref z3_bin_default
  let _ = add_spec (
    "--z3_bin",
    Arg.Set_string z3_bin,
    Format.sprintf
      "executable of Z3 solver (default: %s)"
      (string_of_z3_bin z3_bin_default)
  )
  let set_z3_bin str = z3_bin := str
  let z3_bin () = ! z3_bin

  (* CVC4 binary. *)
  let cvc4_bin_of_string s = s
  let string_of_cvc4_bin s = s
  let cvc4_bin_default = "cvc4"
  let cvc4_bin = ref cvc4_bin_default
  let _ = add_spec (
    "--cvc4_bin",
    Arg.Set_string cvc4_bin,
    Format.sprintf
      "executable of CVC4 solver (default: %s)"
      (string_of_cvc4_bin cvc4_bin_default)
  )
  let set_cvc4_bin str = cvc4_bin := str
  let cvc4_bin () = !cvc4_bin

  (* Mathsat 5 binary. *)
  let mathsat5_bin_of_string s = s
  let string_of_mathsat5_bin s = s
  let mathsat5_bin_default = "mathsat"
  let mathsat5_bin = ref mathsat5_bin_default
  let _ = add_spec (
    "--mathsat5_bin",
    Arg.Set_string mathsat5_bin,
    Format.sprintf
      "executable of MathSAT5 solver (default: %s)"
      (string_of_mathsat5_bin mathsat5_bin_default)
  )
  let set_mathsat5_bin str = mathsat5_bin := str
  let mathsat5_bin () = !mathsat5_bin

  (* Yices binary. *)
  let yices_bin_of_string s = s
  let string_of_yices_bin s = s
  let yices_bin_default = "yices"
  let yices_bin = ref yices_bin_default
  let _ = add_spec (
    "--yices_bin",
    Arg.Set_string yices_bin,
    Format.sprintf
      "executable of Yices solver (default: %s)"
      (string_of_yices_bin yices_bin_default)
  )
  let set_yices_bin str = yices_bin := str
  let yices_bin () = !yices_bin

  (* Yices 2 binary. *)
  let yices2smt2_bin_of_string s = s
  let string_of_yices2smt2_bin s = s
  let yices2smt2_bin_default = "yices-smt2"
  let yices2smt2_bin = ref yices2smt2_bin_default
  let _ = add_spec (
    "--yices2_bin",
    Arg.Set_string yices2smt2_bin,
    Format.sprintf
      "executable of Yices2 SMT2 solver (default: %s)"
      (string_of_yices2smt2_bin yices2smt2_bin_default)
  )
  let set_yices2smt2_bin str = yices2smt2_bin := str
  let yices2smt2_bin () = !yices2smt2_bin

  (* Activates logging of SMT interactions. *)
  let trace_default = false
  let trace = ref trace_default
  let _ = add_spec (
    "--smt_trace",
    Arg.Set trace,
    Format.sprintf "Write all SMT commands to files"
  )
  let trace () = !trace

  (* Folder to log the SMT traces into. *)
  let trace_dir () =
    Global.output_dir () |> mk_dir ;
    let dir = Global.output_dir () |> Format.sprintf "%s/smt_trace" in
    mk_dir dir ;
    dir


  (* Returns all the flag specification of this module. *)
  let all_specs () = !all_specs

end




(* BMC and k-induction flags. *)
module BmcKind = struct

  (* All the flag specification of this module. *)
  let all_specs = ref []
  let add_specs specs = all_specs := !all_specs @ specs
  let add_spec spec = add_specs [spec]

  let max_default = 0
  let max = ref max_default
  let _ = add_spec (
    "--unroll_max",
    Arg.Set_int max,
    Format.sprintf
      "(BMC, IND) Maximal number of iterations (default: %d, unlimited: 0)"
      max_default
  )
  let max () = !max

  let check_unroll_default = true
  let check_unroll = ref check_unroll_default
  let _ = add_spec (
    "--bmc_check_unroll",
    bool_arg check_unroll,
    Format.sprintf
      "(BMC) Check that the unrolling alone is satisfiable (default: %b)"
      check_unroll_default
  )
  let check_unroll () = !check_unroll

  let print_cex_default = false
  let print_cex = ref print_cex_default
  let _ = add_spec (
    "--ind_print_cex",
    bool_arg print_cex,
    Format.sprintf
      "(IND) Print counterexamples to induction (default: %b)"
      print_cex_default
  )
  let print_cex () = !print_cex

  let compress_default = true
  let compress = ref compress_default
  let _ = add_spec (
    "--ind_compress",
    bool_arg compress,
    Format.sprintf
      "(IND) Compress inductive counterexamples (default: %B)"
      compress_default
  )
  let compress () = !compress

  let compress_equal_default = true
  let compress_equal = ref compress_equal_default
  let _ = add_spec (
    "--ind_compress_equal",
    bool_arg compress_equal,
    Format.sprintf
      "(IND) Compress inductive counterexamples for states equal \
      modulo inputs (default: %B)"
      compress_equal_default
  )
  let compress_equal () = !compress_equal

  let compress_same_succ_default = false
  let compress_same_succ = ref compress_same_succ_default
  let _ = add_spec (
    "--ind_compress_same_succ",
    bool_arg compress_same_succ,
    Format.sprintf
      "(IND) Compress inductive counterexamples for states \
      with same successors (default: %B)"
      compress_same_succ_default
  )
  let compress_same_succ () = !compress_same_succ

  let compress_same_pred_default = false
  let compress_same_pred = ref compress_same_pred_default
  let _ = add_spec (
  "--ind_compress_same_pred",
    bool_arg compress_same_pred,
    Format.sprintf
      "(IND) Compress inductive counterexamples for states \
      with same predecessors (default: %B)"
      compress_same_pred_default
  )
  let compress_same_pred () = !compress_same_pred

  let lazy_invariants_default = false
  let lazy_invariants = ref lazy_invariants_default
  let _ = add_spec (
    "--ind_lazy_invariants",
    bool_arg lazy_invariants,
    Format.sprintf
      "(IND) Asserts invariants lazily (default: %B)"
      lazy_invariants_default
  )
  let lazy_invariants () = !lazy_invariants


  (* Returns all the flag specification of this module. *)
  let all_specs () = !all_specs

end



(* IC3 flags. *)
module IC3 = struct

  (* All the flag specification of this module. *)
  let all_specs = ref []
  let add_specs specs = all_specs := !all_specs @ specs
  let add_spec spec = add_specs [spec]

  let string_of_check_inductive = string_of_bool
  let check_inductive_default = true
  let check_inductive = ref check_inductive_default
  let _ = add_spec (
    "--ic3_check_inductive",
    bool_arg check_inductive,
    Format.sprintf
      "(IC3) Check inductiveness of blocking clauses (default: %s)"
      (string_of_check_inductive check_inductive_default)
  )
  let check_inductive () = !check_inductive

  let print_to_file_default = None
  let print_to_file = ref print_to_file_default
  let _ = add_spec (
    "--ic3_print_to_file",
    Arg.String (fun str -> print_to_file := Some str),
    Format.sprintf
      "(IC3) Output file for blocking clauses (default: stdout)"
  )
  let print_to_file () = !print_to_file

  let string_of_inductively_generalize = string_of_int
  let inductively_generalize_default = 1
  let inductively_generalize = ref inductively_generalize_default
  let _ = add_spec (
    "--ic3_inductively_generalize",
    Arg.Set_int inductively_generalize,
    Format.sprintf
      "(IC3) Inductively generalize blocking clauses before forward \
      propagation (0 = none, 1 = normal IG, 2 = IG with ordering) \
      (default: %s)"
      (string_of_inductively_generalize inductively_generalize_default)
  )
  let inductively_generalize () = !inductively_generalize

  let string_of_block_in_future = string_of_bool
  let block_in_future_default = true
  let block_in_future = ref block_in_future_default
  let _ = add_spec (
    "--ic3_block_in_future",
    bool_arg block_in_future,
    Format.sprintf
      "(IC3) Block counterexample in future frames (default: %s)"
      (string_of_block_in_future block_in_future_default)
  )
  let block_in_future () = !block_in_future

  let string_of_block_in_future_first = string_of_bool
  let block_in_future_first_default = true
  let block_in_future_first = ref block_in_future_first_default
  let _ = add_spec (
    "--ic3_block_in_future_first",
    bool_arg block_in_future_first,
    Format.sprintf
      "(IC3) Block counterexample in future frames first before returning to \
      frame (default: %s)"
      (string_of_block_in_future_first block_in_future_first_default)
  )
  let block_in_future_first () = !block_in_future_first

  let string_of_fwd_prop_non_gen = string_of_bool
  let fwd_prop_non_gen_default = true
  let fwd_prop_non_gen = ref fwd_prop_non_gen_default
  let _ = add_spec (
    "--ic3_fwd_prop_non_gen",
    bool_arg fwd_prop_non_gen,
    Format.sprintf
      "(IC3) Also propagate clauses before generalization (default: %s)"
      (string_of_fwd_prop_non_gen fwd_prop_non_gen_default)
  )
  let fwd_prop_non_gen () = !fwd_prop_non_gen

  let string_of_fwd_prop_ind_gen = string_of_bool
  let fwd_prop_ind_gen_default = true
  let fwd_prop_ind_gen = ref fwd_prop_ind_gen_default
  let _ = add_spec (
    "--ic3_fwd_prop_ind_gen",
    bool_arg fwd_prop_ind_gen,
    Format.sprintf
      "(IC3) Inductively generalize all clauses after forward propagation \
      (default: %s)"
      (string_of_fwd_prop_ind_gen fwd_prop_ind_gen_default)
  )
  let fwd_prop_ind_gen () = !fwd_prop_ind_gen

  let string_of_fwd_prop_subsume = string_of_bool
  let fwd_prop_subsume_default = true
  let fwd_prop_subsume = ref fwd_prop_subsume_default
  let _ = add_spec (
    "--ic3_fwd_prop_subsume",
    bool_arg fwd_prop_subsume,
    Format.sprintf
      "(IC3) Subsumption in forward propagation (default: %s)"
      (string_of_fwd_prop_subsume fwd_prop_subsume_default)
  )
  let fwd_prop_subsume () = !fwd_prop_subsume

  let string_of_use_invgen = string_of_bool
  let use_invgen_default = true
  let use_invgen = ref use_invgen_default
  let _ = add_spec (
    "--ic3_use_invgen",
    bool_arg use_invgen,
    Format.sprintf
      "(IC3) Use invariants from invariant generators (default: %s)"
      (string_of_use_invgen use_invgen_default)
  )
  let use_invgen () = !use_invgen

  type qe = [
    `Z3 | `Z3_impl | `Z3_impl2 | `Cooper
  ]
  let qe_of_string = function
    | "Z3" -> `Z3
    | "Z3-impl" -> `Z3_impl
    | "Z3-impl2" -> `Z3_impl2
    | "cooper" -> `Cooper
    | _ -> raise (Arg.Bad "Bad value for --ic3_qe")
  let string_of_qe = function
    | `Z3 -> "Z3"
    |  `Z3_impl -> "Z3-impl"
    |  `Z3_impl2 -> "Z3-impl2"
    | `Cooper -> "cooper"
  let qe_values = [
    `Z3 ; `Z3_impl ; `Z3_impl2 ; `Cooper
  ] |> List.map string_of_qe |> String.concat ", "
  let qe_default = `Cooper
  let qe = ref qe_default
  let _ = add_spec (
    "--ic3_qe",
    Arg.String (fun str -> qe := qe_of_string str),
    Format.sprintf
      "(IC3) choose quantifier elimination algorithm \
      (available: %s, default: %s)"
      qe_values (string_of_qe qe_default)
  )
  let set_qe q = qe := q
  let qe () = !qe

  type extract = [ `First | `Vars ]
  let extract_of_string = function
    | "first" -> `First
    | "vars" -> `Vars
    | _ -> raise (Arg.Bad "Bad value for --ic3_extract")
  let string_of_extract = function
    | `First -> "first"
    | `Vars -> "vars"
  let extract_values = [
    `First ; `Vars
  ] |> List.map string_of_extract |> String.concat ", "
  let extract_default = `First
  let extract = ref extract_default
  let _ = add_spec (
    "--ic3_extract",
    Arg.String (fun str -> extract := extract_of_string str),
    Format.sprintf
      "(IC3) Heuristics for extraction of implicant \
      (available: %s, default: %s)"
      extract_values (string_of_extract extract_default)
  )
  let extract () = !extract

  type abstr = [ `None | `IA ]
  let abstr_of_string = function
    | "None" -> `None
    | "IA" -> `IA
    | _ -> raise (Arg.Bad "Bad value for --ic3_abstr")
  let string_of_abstr = function
    | `IA -> "IA"
    | `None -> "None"
  let abstr_values = [
    `None ; `IA
  ] |> List.map string_of_abstr |> String.concat ", "
  let abstr_default = `None
  let abstr = ref abstr_default
  let _ = add_spec (
    "--ic3_abstr",
    Arg.String (fun str -> abstr := abstr_of_string str),
    Format.sprintf
      "(IC3) choose method of abstraction in IC3 (available: %s, default: %s)"
      abstr_values (string_of_abstr abstr_default)
  )
  let abstr () = !abstr


  (* Returns all the flag specification of this module. *)
  let all_specs () = !all_specs

end


(* Quantifier elimination module. *)
module QE = struct

  (* All the flag specification of this module. *)
  let all_specs = ref []
  let add_specs specs = all_specs := !all_specs @ specs
  let add_spec spec = add_specs [spec]

  let cooper_order_var_by_elim_default = false
  let cooper_order_var_by_elim = ref cooper_order_var_by_elim_default
  let _ = add_spec (
    "--cooper_order_var_by_elim",
    bool_arg cooper_order_var_by_elim,
    Format.sprintf
      "(Cooper QE) Order variables in polynomials by order of \
      elimination (default: %B)"
      cooper_order_var_by_elim_default
  )
  let cooper_order_var_by_elim () = !cooper_order_var_by_elim

  let cooper_general_lbound_default = false
  let cooper_general_lbound = ref cooper_general_lbound_default
  let _ = add_spec (
    "--cooper_general_lbound",
    bool_arg cooper_general_lbound,
    Format.sprintf
      "(Cooper QE) Choose lower bounds containing variables \
      (default: %B)"
      cooper_general_lbound_default
  )
  let cooper_general_lbound () = !cooper_general_lbound


  (* Returns all the flag specification of this module. *)
  let all_specs () = !all_specs
end




(* Contracts flags. *)
module Contracts = struct

  (* All the flag specification of this module. *)
  let all_specs = ref []
  let add_specs specs = all_specs := !all_specs @ specs
  let add_spec spec = add_specs [spec]

  let compositional_default = false
  let compositional = ref compositional_default
  let _ = add_spec (
    "--compositional",
    bool_arg compositional,
    Format.sprintf
      "abstract subnodes with a contract (default: %B)"
      compositional_default
  )
  let compositional () = !compositional

  let check_modes_default = true
  let check_modes = ref check_modes_default
  let _ = add_spec (
    "--check_modes",
    bool_arg check_modes,
    Format.sprintf
      "checks the modes of a contracts are exhaustive \
      (default: %B, setting to `false` automatically activates `check_implem`)"
      check_modes_default
  )
  let check_modes () = !check_modes

  let check_implem_default = true
  let check_implem = ref check_implem_default
  let _ = add_spec (
    "--check_implem",
    bool_arg check_implem,
    Format.sprintf
      "checks the implementation of nodes \
      (default: %B, setting to `false` automatically activates `check_modes`)"
      check_implem_default
  )
  let check_implem () = !check_implem


  (* Returns all the flag specification of this module. *)
  let all_specs () = !all_specs

end



(* Testgen flags. *)
module Testgen = struct

  (* All the flag specification of this module. *)
  let all_specs = ref []
  let add_specs specs = all_specs := !all_specs @ specs
  let add_spec spec = add_specs [spec]

  let active_default = false
  let active = ref active_default
  let _ = add_spec (
    "--testgen",
    bool_arg active,
    Format.sprintf
      "@[<v 7>@,(default: %b)@ \
      Activates test generation, deactivates everything else.@]"
      active_default
  )
  let active () = !active

  let graph_only_default = false
  let graph_only = ref graph_only_default
  let _ = add_spec (
    "--testgen_graph_only",
    bool_arg graph_only,
    Format.sprintf
     "@[<v 7>@,(default: %b)@ \
     Only draw the graph of reachable modes, do not log testcases.@ \
     Does log errors.@]"
     graph_only_default
  )
  let graph_only () = !graph_only

  let len_default = 5
  let len = ref len_default
  let _ = add_spec (
    "--testgen_len",
    Arg.Set_int len,
    Format.sprintf
      "@[<v 7>@,(default: %d)@ \
      Maximimum length for test generation.@]"
      len_default
  )
  let len () = !len


  (* Returns all the flag specification of this module. *)
  let all_specs () = !all_specs

end


(* Invgen flags. *)
module Invgen = struct

  (* All the flag specification of this module. *)
  let all_specs = ref []
  let add_specs specs = all_specs := !all_specs @ specs
  let add_spec spec = add_specs [spec]

  let prune_trivial_default = true
  let prune_trivial = ref prune_trivial_default
  let _ = add_spec (
    "--invgen_prune_trivial",
    bool_arg prune_trivial,
    Format.sprintf
      "Invariant generation will communicate invariants not implied by the \
      transition relation (default: %B)."
      prune_trivial_default
  )
  let prune_trivial () = !prune_trivial

  let max_succ_default = 1
  let max_succ = ref max_succ_default
  let _ = add_spec (
    "--invgen_max_succ",
    Arg.Int (fun b -> max_succ := b),
    Format.sprintf
      "Maximal number of successive iterations for subsystems (default: %d)."
      max_succ_default
  )
  let max_succ () = !max_succ

  let lift_candidates_default = false
  let lift_candidates = ref lift_candidates_default
  let _ = add_spec (
    "--invgen_lift_candidates",
    bool_arg lift_candidates,
    Format.sprintf
      "Invariant generation will instantiate candidates from sub-nodes\
      (default: %B)."
      lift_candidates_default
  )
  let lift_candidates () = !lift_candidates

  let top_only_default = false
  let top_only = ref top_only_default
  let _ = add_spec (
    "--invgen_top_only",
    bool_arg top_only,
    Format.sprintf
      "Only generate invariants for the top level\
      (default: %B)."
      top_only_default
  )
  let top_only () = !top_only

  let mine_trans_default = true
  let mine_trans = ref mine_trans_default
  let _ = add_spec (
    "--invgen_mine_trans",
    bool_arg mine_trans,
    Format.sprintf
      "Invariant generation will extract candidate terms from the transition \
      predicate (default: %B)."
      mine_trans_default
  )
  let mine_trans () = !mine_trans

  let renice_default = 0
  let renice = ref renice_default
  let _ = add_spec (
    "--invgen_renice",
    Arg.Set_int renice,
    "Renice invariant generation process. Give a positive argument to lower \
    priority."
  )
  let renice () = !renice


  (* Returns all the flag specification of this module. *)
  let all_specs () = !all_specs
end


(* C2I flags. *)
module C2I = struct

  (* All the flag specification of this module. *)
  let all_specs = ref []
  let add_specs specs = all_specs := !all_specs @ specs
  let add_spec spec = add_specs [spec]

  let dnf_size_default = 3
  let dnf_size = ref dnf_size_default
  let _ = add_spec (
    "--c2i_dnf",
    Arg.Set_int dnf_size,
    Format.sprintf
      "Number of disjuncts in the DNF constructed by C2I (default %d)."
      dnf_size_default
  )
  let dnf_size () = !dnf_size

  let int_cube_size_default = 3
  let int_cube_size = ref int_cube_size_default
  let _ = add_spec (
    "--c2i_int_cubes",
    Arg.Set_int int_cube_size,
    Format.sprintf
      "Number of int cubes in the DNF constructed by C2I (default %d)."
      int_cube_size_default
  )
  let int_cube_size () = !int_cube_size

  let real_cube_size_default = 3
  let real_cube_size = ref real_cube_size_default
  let _ = add_spec (
    "--c2i_real_cubes",
    Arg.Set_int real_cube_size,
    Format.sprintf
      "Number of real cubes in the DNF constructed by C2I (default %d)."
      real_cube_size_default
  )
  let real_cube_size () = !real_cube_size

  let modes_default = true
  let modes = ref modes_default
  let _ = add_spec (
    "--c2i_modes",
    bool_arg modes,
    Format.sprintf
      "Activates mode subcandidates. Subsumes c2i_dnf_size (default %b)."
      modes_default
  )
  let modes () = !modes


  (* Returns all the flag specification of this module. *)
  let all_specs () = !all_specs
end


(* Interpreter flags. *)
module Interpreter = struct

  (* All the flag specification of this module. *)
  let all_specs = ref []
  let add_specs specs = all_specs := !all_specs @ specs
  let add_spec spec = add_specs [spec]

  let input_file_default = ""
  let input_file = ref input_file_default
  let _ = add_spec (
    "--interpreter_input_file",
    Arg.Set_string input_file,
    Format.sprintf "(Interpreter) Read input from file"
  )
  let input_file () = !input_file

  let steps_default = 0
  let steps = ref steps_default
  let _ = add_spec (
    "--interpreter_steps",
    Arg.Set_int steps,
    Format.sprintf
      "(Interpreter) Run number of steps, override the number of \
      steps given in the input file (default: %d)"
      steps_default
  )
  let steps () = !steps


  (* Returns all the flag specification of this module. *)
  let all_specs () = !all_specs
end

(* ********** *)

(* All flags *)
type flags = {
  (* C2I flags. *)
  mutable c2i_dnf_size : int ;
  mutable c2i_int_cube_size : int ;
  mutable c2i_real_cube_size : int ;
  mutable c2i_modes : bool ;
  (* Interpreter flags. *)
  mutable interpreter_input_file : string ;
  mutable interpreter_steps : int ;
}

(* Defaults for all flags *)
let flags = {
  (* C2I flags. *)
  c2i_dnf_size = C2I.dnf_size_default ;
  c2i_int_cube_size = C2I.int_cube_size_default ;
  c2i_real_cube_size = C2I.real_cube_size_default ;
  c2i_modes = C2I.modes_default ;
  (* Interpreter flags. *)
  interpreter_input_file = Interpreter.input_file_default;
  interpreter_steps = Interpreter.steps_default;
}


(* ********************************************************************** *)
(* Accessor functions for flags                                           *)
(* ********************************************************************** *)

(* |===| The following functions allow to access global flags directly. *)

let output_dir = Global.output_dir
let enable = Global.enabled
let check_version = Global.check_version
let lus_strict = Global.lus_strict
let modular = Global.modular
let lus_main = Global.lus_main
let debug = Global.debug
let debug_log = Global.debug_log
let log_level = Global.log_level
let log_format_xml = Global.log_format_xml
let input_format = Global.input_format
let timeout_wall = Global.timeout_wall
let input_file () = match Global.input_file () with
  | Some f -> f
  | None -> failwith "No input file given"
let lus_compile = Global.lus_compile

(* Path to subdirectory for a system (in the output directory). *)
let subdir_for scope =
  Format.asprintf
    "%s/%a"
    (output_dir ())
    (pp_print_list Format.pp_print_string "_") scope


(* ********************************************************************** *)
(* Parsing of command-line options into flags                             *)
(* ********************************************************************** *)

let usage_msg =
  Format.sprintf
    "Usage: %s [options] FILE@\nProve properties in Lustre program FILE@\n"
    (Filename.basename Sys.executable_name)

let rec help_action () = raise (Arg.Help (Arg.usage_string speclist usage_msg))

and speclist =
  (* [

    (* Display help *)
    ("-help",
     Arg.Unit help_action,
     " Display this list of options") ;
    ("--help",
     Arg.Unit help_action,
     "Display this list of options") ;
    ("-h",
     Arg.Unit help_action,
     "Display this list of options")

  ] @ *)
  [
    Interpreter.all_specs ;
    C2I.all_specs ;
    Contracts.all_specs ;
    IC3.all_specs ;
    Invgen.all_specs ;
    BmcKind.all_specs ;
    Smt.all_specs ;
    Global.all_specs ;
  ] |> List.fold_left (
    fun l specs -> (specs ()) @ l
  ) []


let anon_action s =
  match Global.input_file () with
    | None -> Global.set_input_file s
    | Some _ -> raise (Arg.Bad "More than one input file given")

let set_smtsolver = function

  | `Z3_SMTLIB as smtsolver ->

    (function z3_bin ->
      Smt.set_solver smtsolver ;
      Smt.set_z3_bin z3_bin )

  | `CVC4_SMTLIB as smtsolver ->

    (function cvc4_bin ->
      Smt.set_solver smtsolver ;
      Smt.set_cvc4_bin cvc4_bin )

  | `MathSat5_SMTLIB as smtsolver ->

    (function mathsat5_bin ->
      Smt.set_solver smtsolver ;
      Smt.set_mathsat5_bin mathsat5_bin )

  | `Yices_native as smtsolver ->

    (function yices_bin ->
      Smt.set_solver smtsolver ;
      Smt.set_yices_bin yices_bin )

  | `Yices_SMTLIB as smtsolver ->

    (function yices2smt2_bin ->
      Smt.set_solver smtsolver ;
      Smt.set_yices2smt2_bin yices2smt2_bin )

  | `detect -> (function _ -> ())

   
let parse_argv () =

  (* Parse command-line arguments *)
  Arg.parse speclist anon_action usage_msg;

  (* Output version information only? *)
  if Global.check_version () then (
    Format.printf "%t@." pp_print_version; exit 0
  ) ;

  (* Finalize the list of enabled module. *)
  Global.finalize_enabled () ;

  (* Fail if input file not set *)
  match Global.input_file () with
  | None ->
    Format.printf
      "%s: No input file given.@\n" Sys.argv.(0);
    Arg.usage speclist usage_msg;
    exit 2
  | Some _ -> ()
  
(*
   Local Variables:
   compile-command: "make -C .. -k"
   tuareg-interactive-program: "./kind2.top -I ./_build -I ./_build/SExpr"
   indent-tabs-mode: nil
   End:
*)
