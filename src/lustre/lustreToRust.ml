(* This file is part of the Kind 2 model checker.

   Copyright (c) 2015 by the Board of Trustees of the University of Iowa

   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License.  You
   may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0 

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied. See the License for the specific language governing
   permissions and limitations under the License. 

*)

open Lib

module N = LustreNode
module Id = LustreIdent
module I = LustreIndex
module E = LustreExpr
module SVar = StateVar
module SVM = StateVar.StateVarMap
module SVS = StateVar.StateVarSet

let parse_bool_fun, parse_int_fun, parse_real_fun = "bool", "int", "real"

let fmt_file_prefix name typ = Format.sprintf "\
//! Binary for lustre node `%s`.
//!
//! Code generated by the Kind 2 model checker.

// Deactiving lint warnings the compiler does not respect.
#![allow(
  non_upper_case_globals, unused_parens
)]

use helpers::* ;

/// Entry point.
pub fn main() {
  use std::process::exit ;
  clap() ;
  let mut reader = InputReader::mk() ;
  let mut test = match %s::read_init(& mut reader) {
    Ok(init) => init,
    Err(e) => {
      println!(\"(Error: {})\", e) ;
      exit(2)
    },
  } ;
  loop {
    match %s.read_next(& mut reader) {
      Ok(next) => test = next,
      Err(e) => {
        println!(\"(Error: {})\", e) ;
        exit(2)
      },
    }
  }
}
" name typ name

let file_static = Format.sprintf "\
/// Types and structures for systems.
pub mod helpers {
  use std::io::{ Stdin, stdin } ;
  use std::process::exit ;

  /// Prints usage.
  pub fn help() {
    println!(\"\") ;
    println!(\"\\
Options:
  -h, --help   | prints this message
  -s, --source | prints the original lustre code
  -t, --type   | prints the signature of the original lustre node
  -n, --name   | prints the name of the top node
Usage:
  Inputs  are  read   as comma separated values on a single line.
  Outputs are printed as comma separated values on a single line.\\
    \") ;
    println!(\"\")
  }

  /// Prints usage, an error, and exits with status `2`.
  pub fn error<T: ::std::fmt::Display>(e: T) {
    help() ;
    println!(\"Error: {}\", e) ;
    println!(\"\") ;
    exit(2)
  }

  /// Handles CLA.
  pub fn clap() {
    use std::env::args ;
    let mut args = args() ;
    // Skipping first argument (name of binary).
    match args.next() {
      Some(_) => (),
      None => unreachable!(),
    } ;
    if let Some(arg) = args.next() {
      match & arg as & str {
        \"-s\" | \"--source\" => {
          println!(\"{}\", super::source) ;
          exit(0)
        },
        \"-h\" | \"--help\" => {
          help() ;
          exit(0)
        },
        \"-t\" | \"--type\" => {
          println!(\"{}\", super::top_sig) ;
          exit(0)
        },
        \"-n\" | \"--name\" => {
          println!(\"{}\", super::name) ;
          exit(0)
        },
        arg => error(
          format!(\"unexpected argument \\\"{}\\\".\", arg)
        ),
      }
    }
  }

  /// Alias for `i64`.
  pub type Int = i64 ;
  /// Alias for `f64`.
  pub type Real = f64 ;
  /// Alias for `bool`.
  pub type Bool = bool ;

  /// Stores an `Stdin` and a buffer to read lines.
  pub struct InputReader {
    /// Standard input.
    stdin: Stdin,
    /// String buffer.
    buff: String,
  }
  impl InputReader {
    /// Creates an input reader.
    pub fn mk() -> Self {
      InputReader {
        stdin: stdin(),
        buff: String::with_capacity(100),
      }
    }
    /// Reads comma separated inputs from standard input.
    pub fn read_inputs(& mut self) -> Result<Vec<String>, String> {
      self.buff.clear() ;
      match self.stdin.read_line(& mut self.buff) {
        Ok(_) => (),
        Err(e) => return Err(
          format!(\"could not read line from stdin: {}\", e)
        ),
      } ;
      let chars = self.buff.trim_left().chars() ;
      let mut buff = String::new() ;
      let mut vec = vec![] ;
      for c in chars {
        match c {
          ' ' | '\\t' => (),
          ',' | '\\n' => {
            vec.push(buff.clone()) ;
            buff.clear()
          },
          _ => buff.push(c),
        }
      } ;
      Ok(vec)
    }
  }

  /// Trait all systems must implement.
  pub trait Sys: Sized {
    /// Type of inputs.
    type Input ;
    /// Type of outputs.
    type Output ;
    /// Number of inputs expected.
    fn arity() -> usize ;
    /// Parses a vector of inputs.
    fn input_of(Vec<String>) -> Result<Self::Input, String> ;
    /// Initial state of the system.
    fn init(Self::Input) -> Result<Self, String> ;
    /// Computes the next step.
    fn next(self, Self::Input) -> Result<Self, String> ;
    /// Reads inputs from standard input, computes initial state, prints output.
    fn read_init(reader: & mut InputReader) -> Result<Self, String> {
      match Self::input_of( try!(reader.read_inputs()) ) {
        Ok(inputs) => {
          let init = try!( Self::init(inputs) ) ;
          println!(\"{}\", init.output_str()) ;
          Ok(init)
        },
        Err(s) => Err(s),
      }
    }
    /// Reads inputs from standard input, computes next step, prints output.
    fn read_next(self, reader: & mut InputReader) -> Result<Self, String> {
      match Self::input_of( try!(reader.read_inputs()) ) {
        Ok(inputs) => {
          let next = try!( self.next(inputs) ) ;
          println!(\"{}\", next.output_str()) ;
          Ok(next)
        },
        Err(s) => Err(s),
      }
    }
    /// Output of the system.
    fn output(& self) -> Self::Output ;
    /// String representation of the output.
    fn output_str(& self) -> String ;
  }
}

/// Parsing functions.
pub mod parse {
  use helpers::{ Int, Real, Bool } ;
  use std::fmt::Display ;
  use std::str::FromStr ;
  /// Generic parser to factor error handling out.
  fn generic<
    Out, Error: Display, F: Fn(& str) -> Result<Out, Error>
  >(s: & str, f: F, typ3: & 'static str) -> Result<Out, String> {
    match f(s) {
      Ok(res) => Ok(res),
      Err(e) => Err(
        format!(\"could not parse \\\"{}\\\" as {}: {}\", s, typ3, e)
      ),
    }
  }
  /// Parses a [`Bool`](../type.Bool.html).
  pub fn %s(s: & str) -> Result<Bool, String> {
    generic(
      s,
      |s| match s {
        \"true\" | \"on\" => Ok(true),
        \"false\" | \"off\" => Ok(false),
        _ => Err(
          format!(\"legal values: true, on, false, off\")
        ),
      },
      \"a bool\"
    )
  }
  /// Parses an [`Int`](../type.Int.html).
  pub fn %s(s: & str) -> Result<Int, String> {
    generic(s, |s| Int::from_str(s), \"an int\")
  }
  /// Parses a [`Real`](../type.Real.html).
  pub fn %s(s: & str) -> Result<Real, String> {
    generic(s, |s| Real::from_str(s), \"a real\")
  }
}
" parse_bool_fun parse_int_fun parse_real_fun

let consts name signature source = Format.sprintf "\
/// Name of the top node.
pub const name: & 'static str = \"%s\" ;

/// Signature of the top lustre node (%s).
pub const top_sig: & 'static str = \"\\
%s\\
\" ;

/// Original lustre code.
pub const source: & 'static str = \"\\
%s\\
\" ;
" name name signature source

type continue =
| T of Term.t
| S of string


(* [wrap_with_sep e s [t1 ; ... ; tn]] creates the list
[[Ss ; T t1 ; S s ; ... ; S s ; tn ; e]]. *)
let wrap_with_sep ending sep kids =
  let ending = [ S ending ] in
  let rec loop kids lst = match kids with
    | [] -> List.rev_append lst ending
    | [kid] -> (S sep) :: (T kid) :: ending |> List.rev_append lst
    | kid :: kids -> (T kid) :: (S sep) :: lst |> loop kids
  in
  loop kids []

let fmt_var pref fmt var =
  if Var.is_state_var_instance var then (
    let off = Var.offset_of_state_var_instance var |> Numeral.to_int in
    let from = match off with
      | 0 -> "self."
      | 1 -> ""
      | _ ->
        Format.asprintf "unexpected var %a" Var.pp_print_var var
        |> failwith
    in
    Var.state_var_of_state_var_instance var
    |> SVar.name_of_state_var
    |> Format.fprintf fmt "%s%s%s" from pref
  ) else if Var.is_const_state_var var then (
    Var.state_var_of_state_var_instance var
    |> SVar.name_of_state_var
    |> Format.fprintf fmt "self.%s%s" pref
  ) else
    Format.asprintf "unexpected var %a" Var.pp_print_var var
    |> failwith

(* Goes down a term, printing what it can until it reaches a leaf. Then, calls
[fmt_term_up] on the continuation. *)
let rec fmt_term_down svar_pref next fmt term =
Format.printf "term down: %a@.@." Term.pp_print_term term ;
match Term.destruct term with
| Term.T.App (sym, kid :: kids) -> (
  let node = Symbol.node_of_symbol sym in
  match node with
  (* Unary. *)
  | `NOT ->
    Format.fprintf fmt "(! " ;
    assert (kids = []) ;
    fmt_term_down svar_pref ([ S ")" ] :: next) fmt kid
  (* Binary. *)
  | `EQ
  | `MOD
  | `LEQ
  | `LT
  | `GEQ
  | `GT
  | `IMPLIES -> (
    match kids with
    | [rhs] ->
      let op =
        match node with
        | `EQ -> " == "
        | `MOD -> " % "
        | `LEQ -> " <= "
        | `LT -> " < "
        | `GEQ -> " >= "
        | `GT -> " > "
        | `IMPLIES -> " => "
        | _ -> failwith "unreachable"
      in
      Format.fprintf fmt "(" ;
      fmt_term_down svar_pref (
        [ S op ; T rhs ; S ")" ] :: next
      ) fmt kid
    | [] -> failwith "implication of one kid"
    | _ ->
      Format.sprintf "implication of %d kids" ((List.length kids) + 1)
      |> failwith
  )
  (* Ternary. *)
  | `ITE -> (
    let i, t, e = match kids with
      | [ t ; e ] -> kid, t, e
      | _ -> failwith "illegal ite"
    in
    Format.fprintf fmt "( if " ;
    fmt_term_down svar_pref (
      [ S " {@ " ; T t ; S "@ } else {" ; T e ; S "@ }" ] :: next
    ) fmt kid
  )
  (* N-ary. *)
  | `MINUS
  | `PLUS
  | `TIMES
  | `DIV
  | `OR
  | `XOR
  | `AND ->
    let op =
      match node with
      | `MINUS -> " - "
      | `PLUS -> " + "
      | `TIMES -> " * "
      | `DIV -> " / "
      | `OR -> " | "
      | `XOR -> " ^ "
      | `AND -> " & "
      | _ -> failwith "unreachable"
    in
    Format.fprintf fmt "(" ;
    fmt_term_down svar_pref (
      (wrap_with_sep ")" op kids) :: next
    ) fmt kid
  | `DISTINCT
  | `INTDIV
  | `ABS
  | _ ->
    Format.asprintf "unsupported symbol %a" Symbol.pp_print_symbol sym
    |> failwith
  (*
  | `TO_REAL
  | `TO_INT
  | `IS_INT
  (* Illegal. *)
  | `NUMERAL of Numeral.t
  | `DECIMAL of Decimal.t
  | `TRUE
  | `FALSE -> Format.fprintf fmt "illegal" *)
)
| Term.T.App (sym, []) -> failwith "application with no kids"
| Term.T.Var var ->
  fmt_var svar_pref fmt var ;
  fmt_term_up svar_pref fmt next
| Term.T.Const sym ->
  ( match Symbol.node_of_symbol sym with
    | `NUMERAL n -> Format.fprintf fmt "%a" Numeral.pp_print_numeral n
    | `DECIMAL d -> Format.fprintf fmt "%a" Decimal.pp_print_decimal d
    | `TRUE -> Format.fprintf fmt "true"
    | `FALSE -> Format.fprintf fmt "false"
    | _ -> Format.asprintf "Const %a" Symbol.pp_print_symbol sym |> failwith
  ) ;
  fmt_term_up svar_pref fmt next
| Term.T.Attr (kid,_) -> fmt_term_down svar_pref [] fmt kid

(* Goes up a continuation. Prints the strings it finds and calls
[fmt_term_down] on terms. *)
and fmt_term_up svar_pref fmt = function
| (next :: nexts) :: tail -> (
  let tail = nexts :: tail in
  match next with
  | S str ->
    Format.fprintf fmt "%s" str ;
    fmt_term_up svar_pref fmt tail
  | T term ->
    fmt_term_down svar_pref tail fmt term
)
| [] :: tail -> fmt_term_up svar_pref fmt tail
| [] -> ()

(* Formatter for terms as rust expressions. *)
let fmt_term svar_pref = fmt_term_down svar_pref []




(* Formatter for types as rust expressions. *)
let fmt_type fmt t = match Type.node_of_type t with
| Type.Bool -> Format.fprintf fmt "Bool"
| Type.Int
| Type.IntRange _ -> Format.fprintf fmt "Int"
| Type.Real -> Format.fprintf fmt "Real"
| _ ->
  Format.asprintf "type %a is not supported" Type.pp_print_type t
  |> failwith

(* Rust-level parsing function for a type. *)
let parser_for t = match Type.node_of_type t with
| Type.Bool -> parse_bool_fun
| Type.Int
| Type.IntRange _ -> parse_int_fun
| Type.Real -> parse_real_fun
| _ ->
  Format.asprintf "type %a is not supported" Type.pp_print_type t
  |> failwith


(* Orders equations topologicaly based on the [expr_init] or [expr_next]
expression of the right-hand side of the equation. *)
let order_equations init_or_expr inputs equations =
  (* Checks if [svar] is defined in a list of equations or is an input. *)
  let is_defined sorted svar =
    List.exists (fun (_, svar') -> svar == svar') inputs
    || List.exists (fun (svar', _, _) -> svar == svar') sorted
  in
  (* Sorts equations. *)
  let rec loop count later to_do sorted = match to_do with
    | ((_, _, rhs) as eq) :: to_do ->
      let later, sorted =
        if
          init_or_expr rhs
          |> E.cur_term_of_expr (Numeral.succ E.base_offset)
          (* Extract svars. *)
          |> Term.state_vars_at_offset_of_term (Numeral.succ E.base_offset)
          (* All svars must be defined in [sorted]. *)
          |> SVS.for_all (is_defined sorted)
        then later, eq :: sorted else eq :: later, sorted
      in
      loop count later to_do sorted
    | [] -> (
      let count = count + 1 in
      if count <= List.length equations then
        match later with
        | [] -> List.rev sorted
        | _ -> loop count [] later sorted
      else (
        Format.printf
          "Some equations use undefined variables:@.  @[<v 2>%a@]@.@." (
            pp_print_list (N.pp_print_node_equation false) "@ "
          ) later ;
        failwith "could not compile system"
      )
    )
  in
  loop 0 [] equations []


(* Unsafe string representation of an ident, used for rust identifiers. *)
let mk_id_legal = Id.string_of_ident false
(* Same as [mk_id_legal] but capitalizes the first letter to fit rust
conventions for type naming. *)
let mk_id_type id = mk_id_legal id |> String.capitalize
(* Prefix for all state variables. *)
let svar_pref = "svar_"

(* Compiles a node to rust, writes it to a formatter. *)
let node_to_rust fmt (
  { N.inputs ; N.outputs ; N.equations ; N.state_var_source_map } as node
) =
  let equations =
    equations |> List.filter (fun (svar, _, _) ->
      SVM.mem svar state_var_source_map
    )
  in
  let name = mk_id_legal node.N.name in
  let typ = mk_id_type node.N.name in
  Format.printf "compiling node \"%s\"@.@." name ;

  Format.fprintf fmt "\
    /// Stores the state for node `%s`.@.\
    struct %s {\
  " name typ ;

  let inputs, outputs = I.bindings inputs, I.bindings outputs in

  (* Input type. *)
  inputs
  |> List.iter (fun (_, svar) ->
    Format.fprintf fmt "@.  /// Source (input): `%a`.@.  pub %s%s: %a,"
      SVar.pp_print_state_var svar
      svar_pref
      (SVar.name_of_state_var svar)
      fmt_type (SVar.type_of_state_var svar)
  ) ;

  Format.fprintf fmt "@." ;

  equations |> List.iter (fun (svar, _, _) ->
    Format.fprintf
      fmt "@.  /// Source (local): `%a`.@.  pub %s%s: %a,"
      SVar.pp_print_state_var svar
      svar_pref
      (SVar.name_of_state_var svar)
      fmt_type (SVar.type_of_state_var svar)
  ) ;

  Format.fprintf fmt "@.}@.@.impl Sys for %s {@." typ ;

  (* Input type. *)
  inputs
  |> Format.fprintf fmt "  type Input = (@.    @[<v>%a@]@.  ) ;@." (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "%a, // %s%s (%a)"
        fmt_type (SVar.type_of_state_var svar)
        svar_pref
        (SVar.name_of_state_var svar)
        SVar.pp_print_state_var svar
    ) "@ "
  ) ;

  (* Output type. *)
  outputs
  |> Format.fprintf fmt "  type Output = (@.    @[<v>%a@]@.  ) ;@." (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "%a, // %s%s (%a)"
        fmt_type (SVar.type_of_state_var svar)
        svar_pref
        (SVar.name_of_state_var svar)
        SVar.pp_print_state_var svar
    ) "@ "
  ) ;

  (* Arity. *)
  List.length inputs
  |> Format.fprintf fmt "  fn arity() -> usize { %d }@." ;

  (* Input parsing. *)
  let input_cpt = ref 0 in
  Format.fprintf fmt "  \
      @[<v>\
        fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {@   \
          @[<v>\
            match vec.len() {@   \
              @[<v>\
                n if n == Self::arity() => {@   \
                  @[<v>\
                    Ok( (%a,) )\
                  @]@ \
                },@ \
                n => Err(@   \
                  @[<v>\
                    format!(@   \
                      \"arity mismatch, expected {} but got {}: {:?}\",@   \
                      Self::arity(), n, vec@ \
                    )@ \
                  @]@ \
                ),\
              @]@ \
            }\
          @]@ \
        }\
      @]@.@.\
    "
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "try!( parse::%s(& vec[%d]) )" (
          SVar.type_of_state_var svar
          |> parser_for
        ) ! input_cpt ;
        input_cpt := 1 + !input_cpt
      ) "@ "
    ) inputs ;

  (* Init. *)
  let input_cpt = ref 0 in
  let eqs_init =
    order_equations (fun expr -> expr.E.expr_init) inputs equations
  in
  Format.fprintf fmt "  \
      fn init(input: Self::Input) -> Result<Self, String> {@.    \
        @[<v>\
          // Retrieving inputs.@ \
          %a@ @ \
          // Computing initial state.@ \
          %a@ @ \
          // Returning initial state.@ \
          Ok( %s {@   @[<v>// Inputs.@ %a@ @ // Locals.@ %a@]@ } )\
        @]@.  \
      }@.@.\
    "
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "let %s%s = input.%d ;"
          svar_pref
          (SVar.name_of_state_var svar) !input_cpt ;
        input_cpt := 1 + !input_cpt
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt (svar, _, expr) ->
        expr.E.expr_init
        |> E.base_term_of_expr (Numeral.succ E.base_offset)
        |> Format.fprintf fmt "let %s%s = %a ;"
          svar_pref
          (SVar.name_of_state_var svar)
          (fmt_term svar_pref)
      ) "@ "
    ) eqs_init
    typ
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "%s: %s," name name
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt (svar, _, expr) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "%s: %s," name name
      ) "@ "
    ) eqs_init ;

  (* Next. *)
  let input_cpt = ref 0 in
  let eqs_next =
    order_equations (fun expr -> expr.E.expr_step) inputs equations
  in
  Format.fprintf fmt "  \
      fn next(self, input: Self::Input) -> Result<Self, String> {@.    \
        @[<v>\
          // Retrieving inputs.@ \
          %a@ @ \
          // Computing next state.@ \
          %a@ @ \
          // Returning next state.@ \
          Ok( %s {@   @[<v>// Inputs.@ %a@ @ // Locals.@ %a@]@ } )\
        @]@.  \
      }@.@.\
    "
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "let %s%s = input.%d ;"
          svar_pref
          (SVar.name_of_state_var svar) !input_cpt ;
        input_cpt := 1 + !input_cpt
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt (svar, _, expr) ->
        expr.E.expr_step
        |> E.cur_term_of_expr (Numeral.succ E.base_offset)
        |> Format.fprintf fmt "let %s%s = %a ;"
          svar_pref
          (SVar.name_of_state_var svar)
          (fmt_term svar_pref)
      ) "@ "
    ) eqs_next
    typ
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "%s: %s," name name
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt (svar, _, expr) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "%s: %s," name name
      ) "@ "
    ) eqs_next ;

  (* Output. *)
  outputs
  |> Format.fprintf fmt "  \
    fn output(& self) -> Self::Output {(@.    \
      @[<v>%a@],@.  \
    )}@.\
  " (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "self.%s%s" svar_pref (SVar.name_of_state_var svar)
    ) ",@ "
  ) ;

  (* Output to string. *)
  Format.fprintf fmt "  \
    @[<v>\
      fn output_str(& self) -> String {@   \
        @[<v>\
          format!(@   \
            @[<v>\"%a\",@ %a@]@ \
          )\
        @]@ \
      }\
    @]@.\
  " (
    pp_print_list (fun fmt _ -> Format.fprintf fmt "{}") ",@ "
  ) outputs (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "self.%s%s" svar_pref (SVar.name_of_state_var svar)
    ) ",@ "
  ) outputs ;

  Format.fprintf fmt "}@.@." ;

  ()

let top_to_rust target subs top =
  (* Opening writer to file. *)
  let out_channel = open_out target in
  let fmt = Format.formatter_of_out_channel out_channel in

  let top_name, top_type = mk_id_legal top.N.name, mk_id_type top.N.name in

  Format.printf "compiling for top node \"%s\"@.@." top_name ;

  (* Write prefix and static stuff. *)
  Format.fprintf
    fmt "%s@.@.%s@.@.%s@.@."
    (fmt_file_prefix top_name top_type)
    (consts "unimplemented" "unimplemented" "unimplemented")
    file_static ;

  ( try
      node_to_rust fmt top ;
      subs |> List.iter ( fun sub -> node_to_rust fmt sub ) ;
    with e ->
      Printexc.to_string e |> Format.printf "caught exception: %s@.@."
  ) ;


  Format.fprintf fmt "@.@." ;

  (* Flush and close file writer. *)
  close_out out_channel



let test () =
  Format.printf "|===| ToRust@.|@." ;

  let term_1 = Term.t_true in
  Format.printf "| %a: %a@." Term.pp_print_term term_1 (fmt_term "") term_1 ;
  let term_2 = Term.mk_not Term.t_true in
  Format.printf "| %a: %a@." Term.pp_print_term term_2 (fmt_term "") term_2 ;
  let term_3 = Term.mk_implies [ term_1 ; term_2 ] in
  Format.printf "| %a: %a@." Term.pp_print_term term_3 (fmt_term "") term_3 ;
  let term_4 = Term.mk_and [ term_1 ; term_2 ; term_3 ] in
  Format.printf "| %a: %a@." Term.pp_print_term term_4 (fmt_term "") term_4 ;

  Format.printf "|@.|===|@.@." ;