(* This file is part of the Kind 2 model checker.

   Copyright (c) 2015 by the Board of Trustees of the University of Iowa

   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License.  You
   may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0 

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied. See the License for the specific language governing
   permissions and limitations under the License. 

*)

open Lib

module N = LustreNode
module Id = LustreIdent
module I = LustreIndex
module E = LustreExpr
module SVar = StateVar
module SVM = StateVar.StateVarMap
module SVS = StateVar.StateVarSet

let parse_bool_fun, parse_int_fun, parse_real_fun = "bool", "int", "real"

let fmt_file_prefix name typ = Format.sprintf "\
//! Binary for lustre node `%s`.
//!
//! Code generated by the Kind 2 model checker.

// Deactiving lint warnings the compiler does not respect.
#![allow(
  non_upper_case_globals, unused_parens
)]

use helpers::* ;

/// Entry point.
fn main() {
  use std::process::exit ;
  clap() ;
  let mut reader = InputReader::mk() ;
  let mut state = match %s::read_init(& mut reader) {
    Ok(init) => init,
    Err(e) => {
      println!(\"(Error: {})\", e) ;
      exit(2)
    },
  } ;
  loop {
    match state.read_next(& mut reader) {
      Ok(next) => state = next,
      Err(e) => {
        println!(\"(Error: {})\", e) ;
        exit(2)
      },
    }
  }
}
" name typ

let file_static = Format.sprintf "\
/// Types and structures for systems.
pub mod helpers {
  use std::io::{ Stdin, stdin } ;
  use std::process::exit ;

  /// Prints usage.
  pub fn help() {
    println!(\"\") ;
    println!(\"\\
Options:
  -h, --help   | prints this message
Usage:
  Inputs  are  read   as comma separated values on a single line.
  Outputs are printed as comma separated values on a single line.\\
    \") ;
    println!(\"\")
  }

  /// Prints usage, an error, and exits with status `2`.
  pub fn error<T: ::std::fmt::Display>(e: T) {
    help() ;
    println!(\"Error: {}\", e) ;
    println!(\"\") ;
    exit(2)
  }

  /// Handles CLA.
  pub fn clap() {
    use std::env::args ;
    let mut args = args() ;
    // Skipping first argument (name of binary).
    match args.next() {
      Some(_) => (),
      None => unreachable!(),
    } ;
    if let Some(arg) = args.next() {
      match & arg as & str {
        \"-h\" | \"--help\" => {
          help() ;
          exit(0)
        },
        // \"-s\" | \"--source\" => {
        //   println!(\"{}\", super::source) ;
        //   exit(0)
        // },
        // \"-t\" | \"--type\" => {
        //   println!(\"{}\", super::top_sig) ;
        //   exit(0)
        // },
        // \"-n\" | \"--name\" => {
        //   println!(\"{}\", super::name) ;
        //   exit(0)
        // },
        arg => error(
          format!(\"unexpected argument \\\"{}\\\".\", arg)
        ),
      }
    }
  }

  /// Alias for `i64`.
  pub type Int = i64 ;
  /// Alias for `f64`.
  pub type Real = f64 ;
  /// Alias for `bool`.
  pub type Bool = bool ;

  /// Stores an `Stdin` and a buffer to read lines.
  pub struct InputReader {
    /// Standard input.
    stdin: Stdin,
    /// String buffer.
    buff: String,
  }
  impl InputReader {
    /// Creates an input reader.
    pub fn mk() -> Self {
      InputReader {
        stdin: stdin(),
        buff: String::with_capacity(100),
      }
    }
    /// Reads comma separated inputs from standard input.
    pub fn read_inputs(& mut self) -> Result<Vec<String>, String> {
      self.buff.clear() ;
      match self.stdin.read_line(& mut self.buff) {
        Ok(_) => (),
        Err(e) => return Err(
          format!(\"could not read line from stdin: {}\", e)
        ),
      } ;
      let chars = self.buff.trim_left().chars() ;
      let mut buff = String::new() ;
      let mut vec = vec![] ;
      for c in chars {
        match c {
          ' ' | '\\t' => (),
          ',' | '\\n' => {
            vec.push(buff.clone()) ;
            buff.clear()
          },
          _ => buff.push(c),
        }
      } ;
      Ok(vec)
    }
  }

  /// Trait all systems must implement.
  pub trait Sys: Sized {
    /// Type of inputs.
    type Input ;
    /// Type of outputs.
    type Output ;
    /// Number of inputs expected.
    fn arity() -> usize ;
    /// Parses a vector of inputs.
    fn input_of(Vec<String>) -> Result<Self::Input, String> ;
    /// Initial state of the system.
    fn init(Self::Input) -> Result<Self, String> ;
    /// Computes the next step.
    fn next(self, Self::Input) -> Result<Self, String> ;
    /// Reads inputs from standard input, computes initial state, prints output.
    fn read_init(reader: & mut InputReader) -> Result<Self, String> {
      match Self::input_of( try!(reader.read_inputs()) ) {
        Ok(inputs) => {
          let init = try!( Self::init(inputs) ) ;
          println!(\"{}\", init.output_str()) ;
          Ok(init)
        },
        Err(s) => Err(s),
      }
    }
    /// Reads inputs from standard input, computes next step, prints output.
    fn read_next(self, reader: & mut InputReader) -> Result<Self, String> {
      match Self::input_of( try!(reader.read_inputs()) ) {
        Ok(inputs) => {
          let next = try!( self.next(inputs) ) ;
          println!(\"{}\", next.output_str()) ;
          Ok(next)
        },
        Err(s) => Err(s),
      }
    }
    /// Output of the system.
    fn output(& self) -> Self::Output ;
    /// String representation of the output.
    fn output_str(& self) -> String ;
  }
}

/// Parsing functions.
pub mod parse {
  use helpers::{ Int, Real, Bool } ;
  use std::fmt::Display ;
  use std::str::FromStr ;
  /// Generic parser to factor error handling out.
  fn generic<
    Out, Error: Display, F: Fn(& str) -> Result<Out, Error>
  >(s: & str, f: F, typ3: & 'static str) -> Result<Out, String> {
    match f(s) {
      Ok(res) => Ok(res),
      Err(e) => Err(
        format!(\"could not parse \\\"{}\\\" as {}: {}\", s, typ3, e)
      ),
    }
  }
  /// Parses a [`Bool`](../type.Bool.html).
  pub fn %s(s: & str) -> Result<Bool, String> {
    generic(
      s,
      |s| match s {
        \"true\" | \"on\" => Ok(true),
        \"false\" | \"off\" => Ok(false),
        _ => Err(
          format!(\"legal values: true, on, false, off\")
        ),
      },
      \"a bool\"
    )
  }
  /// Parses an [`Int`](../type.Int.html).
  pub fn %s(s: & str) -> Result<Int, String> {
    generic(s, |s| Int::from_str(s), \"an int\")
  }
  /// Parses a [`Real`](../type.Real.html).
  pub fn %s(s: & str) -> Result<Real, String> {
    generic(s, |s| Real::from_str(s), \"a real\")
  }
}
" parse_bool_fun parse_int_fun parse_real_fun

(* let consts name signature source = Format.sprintf "\
/// Name of the top node.
pub const name: & 'static str = \"%s\" ;

/// Signature of the top lustre node (%s).
pub const top_sig: & 'static str = \"\\
%s\\
\" ;

/// Original lustre code.
pub const source: & 'static str = \"\\
%s\\
\" ;
" name name signature source *)

type continue =
| T of Term.t
| S of string


(* [wrap_with_sep e s [t1 ; ... ; tn]] creates the list
[[Ss ; T t1 ; S s ; ... ; S s ; tn ; e]]. *)
let wrap_with_sep ending sep kids =
  let ending = [ S ending ] in
  let rec loop kids lst = match kids with
    | [] -> List.rev_append lst ending
    | [kid] -> (S sep) :: (T kid) :: ending |> List.rev_append lst
    | kid :: kids -> (T kid) :: (S sep) :: lst |> loop kids
  in
  loop kids []

let fmt_var pref fmt var =
  if Var.is_state_var_instance var then (
    let off = Var.offset_of_state_var_instance var |> Numeral.to_int in
    let from = match off with
      | 0 -> "self."
      | 1 -> ""
      | _ ->
        Format.asprintf "unexpected var %a" Var.pp_print_var var
        |> failwith
    in
    Var.state_var_of_state_var_instance var
    |> SVar.name_of_state_var
    |> Format.fprintf fmt "%s%s%s" from pref
  ) else if Var.is_const_state_var var then (
    Var.state_var_of_state_var_instance var
    |> SVar.name_of_state_var
    |> Format.fprintf fmt "self.%s%s" pref
  ) else
    Format.asprintf "unexpected var %a" Var.pp_print_var var
    |> failwith

(* Goes down a term, printing what it can until it reaches a leaf. Then, calls
[fmt_term_up] on the continuation. *)
let rec fmt_term_down svar_pref next fmt term =
match Term.destruct term with
| Term.T.App (sym, kid :: kids) -> (
  let node = Symbol.node_of_symbol sym in
  match node with
  (* Unary. *)
  | `NOT ->
    Format.fprintf fmt "(! " ;
    assert (kids = []) ;
    fmt_term_down svar_pref ([ S ")" ] :: next) fmt kid
  (* Binary. *)
  | `EQ
  | `MOD
  | `LEQ
  | `LT
  | `GEQ
  | `GT -> (
    match kids with
    | [rhs] ->
      let op =
        match node with
        | `EQ -> " == "
        | `MOD -> " % "
        | `LEQ -> " <= "
        | `LT -> " < "
        | `GEQ -> " >= "
        | `GT -> " > "
        | _ -> failwith "unreachable"
      in
      Format.fprintf fmt "(" ;
      fmt_term_down svar_pref (
        [ S op ; T rhs ; S ")" ] :: next
      ) fmt kid
    | [] -> failwith "implication of one kid"
    | _ ->
      Format.sprintf "implication of %d kids" ((List.length kids) + 1)
      |> failwith
  )
  (* Binary but rewritten. *)
  | `IMPLIES ->
    Term.mk_not kid :: kids
    |> Term.mk_or
    |> fmt_term_down svar_pref next fmt 
  (* Ternary. *)
  | `ITE -> (
    let i, t, e = match kids with
      | [ t ; e ] -> kid, t, e
      | _ -> failwith "illegal ite"
    in
    Format.fprintf fmt "( if " ;
    fmt_term_down svar_pref (
      [ S " { " ; T t ; S " } else {" ; T e ; S " } )" ] :: next
    ) fmt kid
  )
  (* N-ary. *)
  | `MINUS
  | `PLUS
  | `TIMES
  | `DIV
  | `OR
  | `XOR
  | `AND ->
    let op =
      match node with
      | `MINUS -> " - "
      | `PLUS -> " + "
      | `TIMES -> " * "
      | `DIV -> " / "
      | `OR -> " | "
      | `XOR -> " ^ "
      | `AND -> " & "
      | _ -> failwith "unreachable"
    in
    Format.fprintf fmt "(" ;
    fmt_term_down svar_pref (
      (wrap_with_sep ")" op kids) :: next
    ) fmt kid
  | `DISTINCT
  | `INTDIV
  | `ABS
  | _ ->
    Format.asprintf "unsupported symbol %a" Symbol.pp_print_symbol sym
    |> failwith
  (*
  | `TO_REAL
  | `TO_INT
  | `IS_INT
  (* Illegal. *)
  | `NUMERAL of Numeral.t
  | `DECIMAL of Decimal.t
  | `TRUE
  | `FALSE -> Format.fprintf fmt "illegal" *)
)
| Term.T.App (sym, []) -> failwith "application with no kids"
| Term.T.Var var ->
  fmt_var svar_pref fmt var ;
  fmt_term_up svar_pref fmt next
| Term.T.Const sym ->
  ( match Symbol.node_of_symbol sym with
    | `NUMERAL n -> Format.fprintf fmt "%a" Numeral.pp_print_numeral n
    | `DECIMAL d -> Format.fprintf fmt "%a" Decimal.pp_print_decimal d
    | `TRUE -> Format.fprintf fmt "true"
    | `FALSE -> Format.fprintf fmt "false"
    | _ -> Format.asprintf "Const %a" Symbol.pp_print_symbol sym |> failwith
  ) ;
  fmt_term_up svar_pref fmt next
| Term.T.Attr (kid,_) -> fmt_term_down svar_pref [] fmt kid

(* Goes up a continuation. Prints the strings it finds and calls
[fmt_term_down] on terms. *)
and fmt_term_up svar_pref fmt = function
| (next :: nexts) :: tail -> (
  let tail = nexts :: tail in
  match next with
  | S str ->
    Format.fprintf fmt "%s" str ;
    fmt_term_up svar_pref fmt tail
  | T term ->
    fmt_term_down svar_pref tail fmt term
)
| [] :: tail -> fmt_term_up svar_pref fmt tail
| [] -> ()

(* Formatter for terms as rust expressions. *)
let fmt_term svar_pref = fmt_term_down svar_pref []




(* Formatter for types as rust expressions. *)
let fmt_type fmt t = match Type.node_of_type t with
| Type.Bool -> Format.fprintf fmt "Bool"
| Type.Int
| Type.IntRange _ -> Format.fprintf fmt "Int"
| Type.Real -> Format.fprintf fmt "Real"
| _ ->
  Format.asprintf "type %a is not supported" Type.pp_print_type t
  |> failwith

(* Rust-level parsing function for a type. *)
let parser_for t = match Type.node_of_type t with
| Type.Bool -> parse_bool_fun
| Type.Int
| Type.IntRange _ -> parse_int_fun
| Type.Real -> parse_real_fun
| _ ->
  Format.asprintf "type %a is not supported" Type.pp_print_type t
  |> failwith


(* Unsafe string representation of an ident, used for rust identifiers. *)
let mk_id_legal = Id.string_of_ident false
(* Same as [mk_id_legal] but capitalizes the first letter to fit rust
conventions for type naming. *)
let mk_id_type id = mk_id_legal id |> String.capitalize
(* Prefix for all state variables. *)
let svar_pref = "svar_"



type equation =
| Eq of N.equation
| Call of (int * N.node_call)

let id_of_call cnt { N.call_node_name } =
  Format.sprintf "%s_%d" (mk_id_legal call_node_name) cnt

let pp_print_equation fmt = function
| Eq eq -> N.pp_print_node_equation false fmt eq
| Call (cnt, call) ->
  Format.fprintf fmt "%a (%d)" (N.pp_print_call false) call cnt


(* Orders equations topologicaly based on the [expr_init] or [expr_next]
expression of the right-hand side of the equation. *)
let order_equations init_or_expr inputs equations =
  (* Checks if [svar] is defined in a list of equations or is an input. *)
  let is_defined sorted svar =
    List.exists (fun (_, svar') -> svar == svar') inputs
    || List.exists (function
      | Eq (svar', _, _) -> svar == svar'
      | Call (_, { N.call_outputs }) ->
        I.bindings call_outputs |> List.exists (
          fun (_, svar') -> svar == svar'
        )
    ) sorted
  in
  (* Sorts equations. *)
  let rec loop count later to_do sorted = match to_do with
    (* Equation. *)
    | (Eq (_, _, rhs)) as eq :: to_do ->
      let later, sorted =
        if
          init_or_expr rhs
          |> E.cur_term_of_expr (Numeral.succ E.base_offset)
          (* Extract svars. *)
          |> Term.state_vars_at_offset_of_term (Numeral.succ E.base_offset)
          (* All svars must be defined. *)
          |> SVS.for_all (is_defined sorted)
        then later, eq :: sorted else eq :: later, sorted
      in
      loop count later to_do sorted
    (* Node call. *)
    | (
      Call (
        _, { N.call_inputs ; N.call_outputs ; N.call_defaults }
      ) as eq
    ) :: to_do ->
      if call_defaults != None then (
        Format.printf "Compilating of condacts is not supported.@.@." ;
        failwith "could not compile system"
      ) ;
      let later, sorted =
        if
          I.bindings call_inputs
          (* All input svar must be defined. *)
          |> List.for_all (fun (_, svar) -> is_defined sorted svar)
        then later, eq :: sorted else eq :: later, sorted
      in
      loop count later to_do sorted
    (* Done. *)
    | [] -> (
      let count = count + 1 in
      if count <= (List.length equations) + 1 then
        match later with
        | [] -> List.rev sorted
        | _ -> loop count [] later sorted
      else (
        Format.printf
          "Some equations use undefined variables:@.  @[<v 2>%a@]@.@." (
            pp_print_list pp_print_equation "@ "
          ) later ;
        failwith "could not compile system"
      )
    )
  in
  loop 0 [] equations []



(* Compiles a node to rust, writes it to a formatter. *)
let node_to_rust is_top fmt (
  {
    N.inputs ; N.outputs ; N.locals ;
    N.equations ; N.state_var_source_map ; N.calls = real_calls ;
    N.asserts ; N.contract
  } as node
) =
  let calls, _ =
    real_calls |> List.fold_left (
      fun (l,cpt) c -> Call (cpt, c) :: l, cpt + 1
    ) ([], 0)
  in
  let equations =
    equations |> List.fold_left (fun eqs ( (svar, _, _) as eq ) ->
      (* if SVM.mem svar state_var_source_map
      then (Eq eq) :: eqs else eqs *)
      Eq eq :: eqs
    ) calls
  in
  let name = mk_id_legal node.N.name in
  let typ = mk_id_type node.N.name in

  let inputs, outputs, locals =
    I.bindings inputs, I.bindings outputs,
    locals |> List.map I.bindings |> List.flatten
    (* |> List.fold_left (fun locs index ->
      ( I.bindings index |> List.filter (fun (_, svar) ->
        SVM.mem svar state_var_source_map
        ) |> List.rev_append
      ) locs
    ) [] *)
  in

  Format.fprintf fmt "\
    /// Stores the state for %s `%s`.@.\
    ///@.\
    /// # Inputs@.\
    ///@.\
    /// | Lustre identifier | type |@.\
    /// |:------:|:-----|@.\
    /// %a@.\
    ///@.\
    /// # Outputs@.\
    ///@.\
    /// | Lustre identifier | type |@.\
    /// |:------:|:-----|@.\
    /// %a@.\
    ///@.\
    /// # Sub systems@.\
    ///@.\
    /// %a\
    ///@.\
    /// # Assertions@.\
    ///@.\
    /// %a\
    ///@.\
    /// # Assumptions@.\
    ///@.\
    %a\
    ///@.\
    pub struct %s {\
  " (if is_top then "**top node**" else "sub-node") name
  ( pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "| `%s` | %a |"
        (SVar.name_of_state_var svar)
        fmt_type (SVar.type_of_state_var svar)
    ) "@./// "
  ) inputs
  ( pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "| `%s` | %a |"
        (SVar.name_of_state_var svar)
        fmt_type (SVar.type_of_state_var svar)
    ) "@./// "
  ) outputs
  ( fun fmt -> function
    | [] -> Format.fprintf fmt "No subsystems for this system.@."
    | calls ->
      Format.fprintf fmt
        "\
          | Lustre identifier | Struct | Inputs | Outputs | Position |@.\
          /// |:---:|:---:|:---:|:---:|:---:|@.\
          /// %a@.\
        " (
            pp_print_list (fun fmt {
              N.call_pos ; N.call_node_name ; N.call_inputs ; N.call_outputs
            } ->
              Format.fprintf fmt
                "\
                  | `%s` @?\
                  | [%s](struct.%s.html) @?\
                  | %a @?\
                  | %a @?\
                  | %a |\
                "
                (mk_id_legal call_node_name)
                (mk_id_type call_node_name)
                (mk_id_type call_node_name)
                (pp_print_list (fun fmt (_, svar) ->
                    SVar.name_of_state_var svar
                    |> Format.fprintf fmt "`%s`"
                  ) ", "
                ) (I.bindings call_inputs)
                (pp_print_list (fun fmt (_, svar) ->
                    SVar.name_of_state_var svar
                    |> Format.fprintf fmt "`%s`"
                  ) ", "
                ) (I.bindings call_outputs)
                pp_print_position call_pos
            ) "@./// "
          ) calls
  ) real_calls
  ( fun fmt -> function
    | [] -> Format.fprintf fmt "No assertions for this system.@."
    | asserts ->
      Format.fprintf fmt "%a@." (
        pp_print_list (fun fmt expr ->
          Format.fprintf fmt
            "- `%a`"
            (E.pp_print_lustre_expr false) expr
        ) "@ /// "
      ) asserts
  ) asserts
  ( fun fmt -> function
    | None -> Format.fprintf fmt "/// No assumptions for this system.@."
    | Some { LustreContract.assumes } ->
      Format.fprintf fmt
        "\
          /// | State variable | Position | Number |@.\
          /// |:------:|:-----:|:-----:|@.\
          /// %a@.\
        "
        ( pp_print_list (fun fmt {
            LustreContract.pos ; LustreContract.num ; LustreContract.svar
          } ->
            Format.fprintf fmt
              "| `%s` @?| %a @?| %d |"
              (SVar.name_of_state_var svar)
              pp_print_position pos
              num
          ) "@ /// "
        ) (List.rev assumes)
  ) contract
  typ ;

  (* Fields. *)
  inputs
  |> List.iter (fun (_, svar) ->
    Format.fprintf fmt "@.  /// Input: `%a`@.  pub %s%s: %a,"
      SVar.pp_print_state_var svar
      svar_pref
      (SVar.name_of_state_var svar)
      fmt_type (SVar.type_of_state_var svar)
  ) ;

  Format.fprintf fmt "@." ;

  outputs
  |> List.iter (fun (_, svar) ->
    Format.fprintf fmt "@.  /// Output: `%a`@.  pub %s%s: %a,"
      SVar.pp_print_state_var svar
      svar_pref
      (SVar.name_of_state_var svar)
      fmt_type (SVar.type_of_state_var svar)
  ) ;

  Format.fprintf fmt "@." ;

  locals |> List.iter (fun (_, svar) ->
    let source =
      try
        Format.asprintf ", %a"
          N.pp_print_state_var_source (
            SVM.find svar state_var_source_map
          )
      with Not_found -> ""
    in
    Format.fprintf
      fmt "@.  /// Local%s: `%a`@.  pub %s%s: %a,"
      source
      SVar.pp_print_state_var svar
      svar_pref
      (SVar.name_of_state_var svar)
      fmt_type (SVar.type_of_state_var svar)
  ) ;

  Format.fprintf fmt "@." ;

  calls |> List.iter (function
    | Call (cnt, ({ N.call_pos ; N.call_node_name } as call)) ->
      Format.fprintf
        fmt "@.  /// Call to `%a` (%a).@.  pub %s: %s,"
        (Id.pp_print_ident false) call_node_name
        pp_print_position call_pos
        (id_of_call cnt call)
        (mk_id_type call_node_name)
    | _ -> failwith "unreachable"
  ) ;

  Format.fprintf fmt "@.}@.@.impl Sys for %s {@." typ ;

  (* Input type. *)
  inputs
  |> Format.fprintf fmt "  type Input = (@.    @[<v>%a@]@.  ) ;@." (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "%a, // %s%s (%a)"
        fmt_type (SVar.type_of_state_var svar)
        svar_pref
        (SVar.name_of_state_var svar)
        SVar.pp_print_state_var svar
    ) "@ "
  ) ;

  (* Output type. *)
  outputs
  |> Format.fprintf fmt "  type Output = (@.    @[<v>%a@]@.  ) ;@." (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "%a, // %s%s (%a)"
        fmt_type (SVar.type_of_state_var svar)
        svar_pref
        (SVar.name_of_state_var svar)
        SVar.pp_print_state_var svar
    ) "@ "
  ) ;

  (* Arity. *)
  List.length inputs
  |> Format.fprintf fmt "  fn arity() -> usize { %d }@." ;

  (* Input parsing. *)
  let input_cpt = ref 0 in
  Format.fprintf fmt "  \
      @[<v>\
        fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {@   \
          @[<v>\
            match vec.len() {@   \
              @[<v>\
                n if n == Self::arity() => {@   \
                  @[<v>\
                    Ok( (@   @[<v>%a@],@ ) )\
                  @]@ \
                },@ \
                n => Err(@   \
                  @[<v>\
                    format!(@   \
                      \"arity mismatch, expected {} but got {}: {:?}\",@   \
                      Self::arity(), n, vec@ \
                    )@ \
                  @]@ \
                ),\
              @]@ \
            }\
          @]@ \
        }\
      @]@.@.\
    "
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "try!( parse::%s(& vec[%d]) )" (
          SVar.type_of_state_var svar
          |> parser_for
        ) ! input_cpt ;
        input_cpt := 1 + !input_cpt
      ) ", @ "
    ) inputs ;

  (* Init. *)
  let input_cpt = ref 0 in
  let eqs_init =
    order_equations (fun expr -> expr.E.expr_init) inputs equations
  in
  Format.fprintf fmt "  \
      fn init(input: Self::Input) -> Result<Self, String> {@.    \
        @[<v>\
          // |===| Retrieving inputs.@ \
          %a@ @ \
          // |===| Computing initial state.@ \
          %a@ @ \
          // |===| Checking assertions.@ \
          %a@ @ \
          // |===| Checking assumptions.@ \
          %a@ @ \
          // |===| Returning initial state.@ \
          Ok( %s {@   \
            @[<v>\
              // |===| Inputs.@ %a@ @ \
              // |===| Outputs.@ %a@ @ \
              // |===| Locals.@ %a@ @ \
              // |===| Calls.@ %a\
            @]@ \
          } )\
        @]@.  \
      }@.@.\
    "
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "let %s%s = input.%d ;"
          svar_pref
          (SVar.name_of_state_var svar) !input_cpt ;
        input_cpt := 1 + !input_cpt
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt -> function
        | Eq (svar, _, expr) ->
          expr.E.expr_init
          |> E.base_term_of_expr (Numeral.succ E.base_offset)
          |> Format.fprintf fmt "let %s%s = %a ;"
            svar_pref
            (SVar.name_of_state_var svar)
            (fmt_term svar_pref)
        | Call (
          cnt, ({ N.call_node_name ; N.call_inputs ; N.call_outputs } as call)
        ) ->
          Format.fprintf fmt
            "\
              let %s = try!( %s::init( (@   @[<v>%a,@]@ ) ) ) ;@ \
              let (@   @[<v>%a,@]@ ) = %s.output() ;@ \
            "
            (id_of_call cnt call)
            (mk_id_type call_node_name)
            ( pp_print_list (fun fmt (_, svar) ->
                Format.fprintf fmt "%s%s"
                  svar_pref (SVar.name_of_state_var svar)
              ) ",@ "
            ) (I.bindings call_inputs)
            ( pp_print_list (fun fmt (_, svar) ->
                Format.fprintf fmt "%s%s"
                  svar_pref (SVar.name_of_state_var svar)
              ) ",@ "
            ) (I.bindings call_outputs)
            (id_of_call cnt call)
      ) "@ "
    ) eqs_init
    ( pp_print_list (fun fmt expr ->
        Format.fprintf fmt
          "// %a@ if ! (@   %a@ ) {@   \
            @[<v>\
              return Err(@   \
                \"assertion failure: %a\".to_string()@ \
              )\
            @]@ \
          } ;"
          (E.pp_print_lustre_expr false) expr
          (fmt_term svar_pref) (
            expr.E.expr_init
            |> E.base_term_of_expr (Numeral.succ E.base_offset)
          )
          (E.pp_print_lustre_expr false) expr
      ) "@ "
    ) asserts
    ( fun fmt -> function
      | None -> ()
      | Some { LustreContract.assumes } ->
        ( pp_print_list (fun fmt {
            LustreContract.pos ; LustreContract.num ; LustreContract.svar
          } ->
            Format.fprintf fmt
              "// Assumption number %d at %a@ if ! %s%s {@   \
                @[<v>\
                  return Err(@   \
                    \"assumption failure: \
                      %a (assumption number %d)\".to_string()@ \
                  )\
                @]@ \
              } ;"
              num
              pp_print_position pos
              svar_pref (SVar.name_of_state_var svar)
              pp_print_position pos
              num
          ) "@ "
        ) fmt (List.rev assumes)
    ) contract
    typ
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "%s: %s," name name
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "%s: %s," name name
      ) "@ "
    ) outputs
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "%s: %s," name name
      ) "@ "
    ) locals
    ( pp_print_list (fun fmt -> function
        | Call (cpt, call) ->
          let name = id_of_call cpt call in
          Format.fprintf fmt "%s: %s," name name
        | _ -> failwith "unreachable"
      ) "@ "
    ) calls ;

  (* Next. *)
  let input_cpt = ref 0 in
  let eqs_next =
    order_equations (fun expr -> expr.E.expr_step) inputs equations
  in
  Format.fprintf fmt "  \
      fn next(mut self, input: Self::Input) -> Result<Self, String> {@.    \
        @[<v>\
          // |===| Retrieving inputs.@ \
          %a@ @ \
          // |===| Computing next state.@ \
          %a@ @ \
          // |===| Checking assertions.@ \
          %a@ @ \
          // |===| Checking assumptions.@ \
          %a@ @ \
          // |===| Updating next state.@ \
          // |===| Inputs.@ %a@ @ \
          // |===| Outputs.@ %a@ @ \
          // |===| Locals.@ %a@ @ \
          // |===| Calls.@ %a@ @ \
          // |===| Return new state.@ Ok( self )\
        @]@.  \
      }@.@.\
    "
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "let %s%s = input.%d ;"
          svar_pref
          (SVar.name_of_state_var svar) !input_cpt ;
        input_cpt := 1 + !input_cpt
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt -> function
        | Eq (svar, _, expr) ->
          expr.E.expr_step
          |> E.cur_term_of_expr (Numeral.succ E.base_offset)
          |> Format.fprintf fmt "let %s%s = %a ;"
            svar_pref
            (SVar.name_of_state_var svar)
            (fmt_term svar_pref)
        | Call (
          cnt, ({ N.call_node_name ; N.call_inputs ; N.call_outputs } as call)
        ) ->
          Format.fprintf fmt
            "\
              let %s = try!( self.%s.next( (@   @[<v>%a,@]@ ) ) ) ;@ \
              let (@   @[<v>%a,@]@ ) = %s.output() ;\
            "
            (id_of_call cnt call)
            (id_of_call cnt call)
            ( pp_print_list (fun fmt (_, svar) ->
                Format.fprintf fmt "%s%s"
                  svar_pref (SVar.name_of_state_var svar)
              ) ",@ "
            ) (I.bindings call_inputs)
            ( pp_print_list (fun fmt (_, svar) ->
                Format.fprintf fmt "%s%s"
                  svar_pref (SVar.name_of_state_var svar)
              ) ",@ "
            ) (I.bindings call_outputs)
            (id_of_call cnt call)
      ) "@ "
    ) eqs_next
    ( pp_print_list (fun fmt expr ->
        Format.fprintf fmt
          "// %a@ if ! (@   %a@ ) {@   \
            @[<v>\
              return Err(@   \
                \"assertion failure: %a\".to_string()@ \
              )\
            @]@ \
          } ;"
          (E.pp_print_lustre_expr false) expr
          (fmt_term svar_pref) (
            expr.E.expr_step
            |> E.base_term_of_expr (Numeral.succ E.base_offset)
          )
          (E.pp_print_lustre_expr false) expr
      ) "@ "
    ) asserts
    ( fun fmt -> function
      | None -> ()
      | Some { LustreContract.assumes } ->
        ( pp_print_list (fun fmt {
            LustreContract.pos ; LustreContract.num ; LustreContract.svar
          } ->
            Format.fprintf fmt
              "// Assumption number %d at %a@ if ! %s%s {@   \
                @[<v>\
                  return Err(@   \
                    \"assumption failure: \
                      %a (assumption number %d)\".to_string()@ \
                  )\
                @]@ \
              } ;"
              num
              pp_print_position pos
              svar_pref (SVar.name_of_state_var svar)
              pp_print_position pos
              num
          ) "@ "
        ) fmt (List.rev assumes)
    ) contract
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "self.%s = %s ;" name name
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "self.%s = %s ;" name name
      ) "@ "
    ) outputs
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "self.%s = %s ;" name name
      ) "@ "
    ) locals
    ( pp_print_list (fun fmt -> function
        | Call (cpt, call) ->
          let name = id_of_call cpt call in
          Format.fprintf fmt "self.%s = %s ;" name name
        | _ -> failwith "unreachable"
      ) "@ "
    ) calls ;

  (* Output. *)
  outputs
  |> Format.fprintf fmt "  \
    fn output(& self) -> Self::Output {(@.    \
      @[<v>%a@],@.  \
    )}@.\
  " (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "self.%s%s" svar_pref (SVar.name_of_state_var svar)
    ) ",@ "
  ) ;

  (* Output to string. *)
  Format.fprintf fmt "  \
    @[<v>\
      fn output_str(& self) -> String {@   \
        @[<v>\
          format!(@   \
            @[<v>\"%a\",@ %a@]@ \
          )\
        @]@ \
      }\
    @]@.\
  " (
    pp_print_list (fun fmt _ -> Format.fprintf fmt "{}") ", \\@ "
  ) outputs (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "self.%s%s" svar_pref (SVar.name_of_state_var svar)
    ) ",@ "
  ) outputs ;

  Format.fprintf fmt "}@.@." ;

  calls |> List.map (
    function
    | Call (_, { N.call_node_name } ) -> call_node_name
    | _ -> failwith "unreachable"
  )

(* Creates a directory if not already present. *)
let mk_dir dir =
  try Unix.mkdir dir 0o740 with Unix.Unix_error(Unix.EEXIST, _, _) -> ()

(* Dumps the default [Cargo.toml] file in a directory. *)
let dump_toml name dir =
  let out_channel = Format.sprintf "%s/Cargo.toml" dir |> open_out in
  let fmt = Format.formatter_of_out_channel out_channel in
  Format.fprintf fmt
    "\
      [package]@.\
      name = \"%s\"@.\
      version = \"1.0.0\"@.\
      authors = [\"Kind 2 <cesare-tinelli@uiowa.edu>\"]@.\
    "
    name ;
  close_out out_channel

let top_to_rust target find_sub top =
  let top_name, top_type = mk_id_legal top.N.name, mk_id_type top.N.name in
  (* Creating project directory if necessary. *)
  mk_dir target ;
  (* Creating source dir. *)
  let src_dir = Format.sprintf "%s/src" target in
  mk_dir src_dir ;
  (* Dump toml configuration file. *)
  dump_toml top_name target ;
  (* Opening writer to file. *)
  let file = Format.sprintf "%s/main.rs" src_dir in
  let out_channel = open_out file in
  let fmt = Format.formatter_of_out_channel out_channel in
  Format.pp_set_margin fmt max_int ;

  (* Write prefix and static stuff. *)
  Format.fprintf
    fmt "%s@.@.%s@.@."
    (fmt_file_prefix top_name top_type)
    (* (consts "unimplemented" "unimplemented" "unimplemented") *)
    file_static ;

  let rec compile is_top compiled = function
    | node :: nodes ->
      let compiled, nodes =
        if Id.Set.mem node.N.name compiled |> not then (
          Id.Set.add node.N.name compiled,
          nodes @ (
            node_to_rust is_top fmt node
            |> List.fold_left (fun l call_id ->
              if Id.Set.mem call_id compiled |> not
              then (Id.to_scope call_id |> find_sub) :: l else l
            ) []
          )
        ) else compiled, nodes
      in
      compile false compiled nodes
    | [] -> ()
  in

  compile true Id.Set.empty [ top ] ;


  Format.fprintf fmt "@.@." ;

  (* Flush and close file writer. *)
  close_out out_channel

