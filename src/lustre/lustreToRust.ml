(* This file is part of the Kind 2 model checker.

   Copyright (c) 2015 by the Board of Trustees of the University of Iowa

   Licensed under the Apache License, Version 2.0 (the "License"); you
   may not use this file except in compliance with the License.  You
   may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0 

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied. See the License for the specific language governing
   permissions and limitations under the License. 

*)

open Lib

module N = LustreNode
module Id = LustreIdent
module I = LustreIndex
module E = LustreExpr
module C = LustreContract
module SVar = StateVar
module SVM = StateVar.StateVarMap
module SVS = StateVar.StateVarSet

(* Name of the parsing functions in the rust [parse] module. *)
let parse_bool_fun, parse_int_fun, parse_real_fun = "bool", "int", "real"

(* Crate documentation for implementation, lint attributes. *)
let fmt_prefix blah name fmt typ = Format.fprintf fmt "\
//! %s for lustre node `%s` (see [%s](struct.%s.html)).
//!
//! Code generated by the [Kind 2 model checker][kind 2].
//!
//! [kind 2]: http://kind2-mc.github.io/kind2/ (The Kind 2 model checker)

// Deactiving lint warnings the transformation does not respect.
#![allow(
  non_upper_case_globals, unused_parens, non_snake_case, non_camel_case_types
)]

use helpers::* ;
" blah name typ typ

(* Specialization of [fmt_prefix] for implementation. *)
let fmt_prefix_implem = fmt_prefix "Implementation"

(* Specialization of [fmt_prefix] for oracles. *)
let fmt_prefix_oracle = fmt_prefix "Oracle"

(* Crate entry point. *)
let fmt_main fmt typ = Format.fprintf fmt "\
/// Entry point.
fn main() {
  use std::process::exit ;
  clap() ;
  let mut reader = InputReader::mk() ;
  let mut state = match %s::read_init(& mut reader) {
    Ok(init) => init,
    Err(e) => {
      println!(\"(Error: {})\", e) ;
      exit(2)
    },
  } ;
  loop {
    match state.read_next(& mut reader) {
      Ok(next) => state = next,
      Err(e) => {
        println!(\"(Error: {})\", e) ;
        exit(2)
      },
    }
  }
}
" typ

(* Helpers modules: cla parsing, types, traits for systems and stdin
parsing. *)
let file_static = Format.sprintf "\
/// Types and structures for systems.
pub mod helpers {
  use std::io::{ Stdin, stdin } ;
  use std::process::exit ;

  /// Prints usage.
  pub fn help() {
    println!(\"\") ;
    println!(\"\\
Options:
  -h, --help   | prints this message
Usage:
  Inputs  are  read   as comma separated values on a single line.
  Outputs are printed as comma separated values on a single line.\\
    \") ;
    println!(\"\")
  }

  /// Prints usage, an error, and exits with status `2`.
  pub fn error<T: ::std::fmt::Display>(e: T) {
    help() ;
    println!(\"Error: {}\", e) ;
    println!(\"\") ;
    exit(2)
  }

  /// Handles CLA.
  pub fn clap() {
    use std::env::args ;
    let mut args = args() ;
    // Skipping first argument (name of binary).
    match args.next() {
      Some(_) => (),
      None => unreachable!(),
    } ;
    if let Some(arg) = args.next() {
      match & arg as & str {
        \"-h\" | \"--help\" => {
          help() ;
          exit(0)
        },
        // \"-s\" | \"--source\" => {
        //   println!(\"{}\", super::source) ;
        //   exit(0)
        // },
        // \"-t\" | \"--type\" => {
        //   println!(\"{}\", super::top_sig) ;
        //   exit(0)
        // },
        // \"-n\" | \"--name\" => {
        //   println!(\"{}\", super::name) ;
        //   exit(0)
        // },
        arg => error(
          format!(\"unexpected argument \\\"{}\\\".\", arg)
        ),
      }
    }
  }

  /// Alias for `i64`.
  pub type Int = i64 ;
  /// Alias for `f64`.
  pub type Real = f64 ;
  /// Alias for `bool`.
  pub type Bool = bool ;

  /// Stores an `Stdin` and a buffer to read lines.
  pub struct InputReader {
    /// Standard input.
    stdin: Stdin,
    /// String buffer.
    buff: String,
  }
  impl InputReader {
    /// Creates an input reader.
    pub fn mk() -> Self {
      InputReader {
        stdin: stdin(),
        buff: String::with_capacity(100),
      }
    }
    /// Reads comma separated inputs from standard input.
    pub fn read_inputs(& mut self) -> Result<Vec<String>, String> {
      self.buff.clear() ;
      match self.stdin.read_line(& mut self.buff) {
        Ok(_) => (),
        Err(e) => return Err(
          format!(\"could not read line from stdin: {}\", e)
        ),
      } ;
      let chars = self.buff.trim_left().chars() ;
      let mut buff = String::new() ;
      let mut vec = vec![] ;
      for c in chars {
        match c {
          ' ' | '\\t' => (),
          ',' | '\\n' => {
            vec.push(buff.clone()) ;
            buff.clear()
          },
          _ => buff.push(c),
        }
      } ;
      Ok(vec)
    }
  }

  /// Trait all systems must implement.
  pub trait Sys: Sized {
    /// Type of inputs.
    type Input ;
    /// Type of outputs.
    type Output ;
    /// Number of inputs expected.
    fn arity() -> usize ;
    /// Parses a vector of inputs.
    fn input_of(Vec<String>) -> Result<Self::Input, String> ;
    /// Initial state of the system.
    fn init(Self::Input) -> Result<Self, String> ;
    /// Computes the next step.
    fn next(self, Self::Input) -> Result<Self, String> ;
    /// Reads inputs from standard input, computes initial state, prints output.
    fn read_init(reader: & mut InputReader) -> Result<Self, String> {
      match Self::input_of( try!(reader.read_inputs()) ) {
        Ok(inputs) => {
          let init = try!( Self::init(inputs) ) ;
          println!(\"{}\", init.output_str()) ;
          Ok(init)
        },
        Err(s) => Err(s),
      }
    }
    /// Reads inputs from standard input, computes next step, prints output.
    fn read_next(self, reader: & mut InputReader) -> Result<Self, String> {
      match Self::input_of( try!(reader.read_inputs()) ) {
        Ok(inputs) => {
          let next = try!( self.next(inputs) ) ;
          println!(\"{}\", next.output_str()) ;
          Ok(next)
        },
        Err(s) => Err(s),
      }
    }
    /// Output of the system.
    fn output(& self) -> Self::Output ;
    /// String representation of the output.
    fn output_str(& self) -> String ;
  }
}

/// Parsing functions.
pub mod parse {
  use helpers::{ Int, Real, Bool } ;
  use std::fmt::Display ;
  use std::str::FromStr ;
  /// Generic parser to factor error handling out.
  fn generic<
    Out, Error: Display, F: Fn(& str) -> Result<Out, Error>
  >(s: & str, f: F, typ3: & 'static str) -> Result<Out, String> {
    match f(s) {
      Ok(res) => Ok(res),
      Err(e) => Err(
        format!(\"could not parse \\\"{}\\\" as {}: {}\", s, typ3, e)
      ),
    }
  }
  /// Parses a [`Bool`](../type.Bool.html).
  pub fn %s(s: & str) -> Result<Bool, String> {
    generic(
      s,
      |s| match s {
        \"true\" | \"on\" => Ok(true),
        \"false\" | \"off\" => Ok(false),
        _ => Err(
          format!(\"legal values: true, on, false, off\")
        ),
      },
      \"a bool\"
    )
  }
  /// Parses an [`Int`](../type.Int.html).
  pub fn %s(s: & str) -> Result<Int, String> {
    generic(s, |s| Int::from_str(s), \"an int\")
  }
  /// Parses a [`Real`](../type.Real.html).
  pub fn %s(s: & str) -> Result<Real, String> {
    generic(s, |s| Real::from_str(s), \"a real\")
  }
}
" parse_bool_fun parse_int_fun parse_real_fun

(* Continuation type for the term-to-Rust printer.
Used to specify what should happen after the next step. *)
type continue =
| T of Term.t (* Next step is to print a term. *)
| S of string (* Next step is to print a string. *)


(* [wrap_with_sep e s [t1 ; ... ; tn]] creates the list
[[Ss ; T t1 ; S s ; ... ; S s ; tn ; e]]. *)
let wrap_with_sep ending sep kids =
  let ending = [ S ending ] in
  let rec loop kids lst = match kids with
    | [] -> List.rev_append lst ending
    | [kid] -> (S sep) :: (T kid) :: ending |> List.rev_append lst
    | kid :: kids -> (T kid) :: (S sep) :: lst |> loop kids
  in
  loop kids []

(* Prints a variable. Prefixes with ["self."] variables unrolled at 0 and
constant variables. *)
let fmt_var pref fmt var =
  if Var.is_state_var_instance var then (
    let off = Var.offset_of_state_var_instance var |> Numeral.to_int in
    let from = match off with
      | 0 -> "self."
      | 1 -> ""
      | _ ->
        Format.asprintf "unexpected var %a" Var.pp_print_var var
        |> failwith
    in
    Var.state_var_of_state_var_instance var
    |> SVar.name_of_state_var
    |> Format.fprintf fmt "%s%s%s" from pref
  ) else if Var.is_const_state_var var then (
    Var.state_var_of_state_var_instance var
    |> SVar.name_of_state_var
    |> Format.fprintf fmt "self.%s%s" pref
  ) else
    Format.asprintf "unexpected var %a" Var.pp_print_var var
    |> failwith

(* Goes down a term, printing what it can until it reaches a leaf. Then, calls
[fmt_term_up] on the continuation. *)
let rec fmt_term_down svar_pref next fmt term =
match Term.destruct term with
| Term.T.App (sym, kid :: kids) -> (
  let node = Symbol.node_of_symbol sym in
  match node with
  (* Unary. *)
  | `NOT ->
    Format.fprintf fmt "(! " ;
    assert (kids = []) ;
    fmt_term_down svar_pref ([ S ")" ] :: next) fmt kid
  (* Binary. *)
  | `EQ
  | `MOD
  | `LEQ
  | `LT
  | `GEQ
  | `GT -> (
    match kids with
    | [rhs] ->
      let op =
        match node with
        | `EQ -> " == "
        | `MOD -> " % "
        | `LEQ -> " <= "
        | `LT -> " < "
        | `GEQ -> " >= "
        | `GT -> " > "
        | _ -> failwith "unreachable"
      in
      Format.fprintf fmt "(" ;
      fmt_term_down svar_pref (
        [ S op ; T rhs ; S ")" ] :: next
      ) fmt kid
    | [] -> failwith "implication of one kid"
    | _ ->
      Format.sprintf "implication of %d kids" ((List.length kids) + 1)
      |> failwith
  )
  (* Binary but rewritten. *)
  | `IMPLIES ->
    Term.mk_not kid :: kids
    |> Term.mk_or
    |> fmt_term_down svar_pref next fmt 
  (* Ternary. *)
  | `ITE -> (
    let i, t, e = match kids with
      | [ t ; e ] -> kid, t, e
      | _ -> failwith "illegal ite"
    in
    Format.fprintf fmt "( if " ;
    fmt_term_down svar_pref (
      [ S " { " ; T t ; S " } else {" ; T e ; S " } )" ] :: next
    ) fmt kid
  )
  (* N-ary. *)
  | `MINUS when kids = [] ->
    Format.fprintf fmt "- " ;
    fmt_term_down svar_pref next fmt kid
  | `MINUS
  | `PLUS
  | `TIMES
  | `DIV
  | `OR
  | `XOR
  | `AND ->
    let op =
      match node with
      | `MINUS -> " - "
      | `PLUS -> " + "
      | `TIMES -> " * "
      | `DIV -> " / "
      | `OR -> " | "
      | `XOR -> " ^ "
      | `AND -> " & "
      | _ -> failwith "unreachable"
    in
    Format.fprintf fmt "(" ;
    fmt_term_down svar_pref (
      (wrap_with_sep ")" op kids) :: next
    ) fmt kid
  | `DISTINCT
  | `INTDIV
  | `ABS
  | _ ->
    Format.asprintf "unsupported symbol %a" Symbol.pp_print_symbol sym
    |> failwith
  (*
  | `TO_REAL
  | `TO_INT
  | `IS_INT
  (* Illegal. *)
  | `NUMERAL of Numeral.t
  | `DECIMAL of Decimal.t
  | `TRUE
  | `FALSE -> Format.fprintf fmt "illegal" *)
)
| Term.T.App (sym, []) -> failwith "application with no kids"
| Term.T.Var var ->
  fmt_var svar_pref fmt var ;
  fmt_term_up svar_pref fmt next
| Term.T.Const sym ->
  ( match Symbol.node_of_symbol sym with
    | `NUMERAL n -> Format.fprintf fmt "%a" Numeral.pp_print_numeral n
    | `DECIMAL d -> Format.fprintf fmt "%a" Decimal.pp_print_decimal d
    | `TRUE -> Format.fprintf fmt "true"
    | `FALSE -> Format.fprintf fmt "false"
    | _ -> Format.asprintf "Const %a" Symbol.pp_print_symbol sym |> failwith
  ) ;
  fmt_term_up svar_pref fmt next
| Term.T.Attr (kid,_) -> fmt_term_down svar_pref [] fmt kid

(* Goes up a continuation. Prints the strings it finds and calls
[fmt_term_down] on terms. *)
and fmt_term_up svar_pref fmt = function
| (next :: nexts) :: tail -> (
  let tail = nexts :: tail in
  match next with
  | S str ->
    Format.fprintf fmt "%s" str ;
    fmt_term_up svar_pref fmt tail
  | T term ->
    fmt_term_down svar_pref tail fmt term
)
| [] :: tail -> fmt_term_up svar_pref fmt tail
| [] -> ()

(* Formatter for terms as rust expressions. *)
let fmt_term svar_pref = fmt_term_down svar_pref []




(* Formatter for types as rust expressions. *)
let fmt_type fmt t = match Type.node_of_type t with
| Type.Bool -> Format.fprintf fmt "Bool"
| Type.Int
| Type.IntRange _ -> Format.fprintf fmt "Int"
| Type.Real -> Format.fprintf fmt "Real"
| _ ->
  Format.asprintf "type %a is not supported" Type.pp_print_type t
  |> failwith

(* Rust-level parsing function for a type. *)
let parser_for t = match Type.node_of_type t with
| Type.Bool -> parse_bool_fun
| Type.Int
| Type.IntRange _ -> parse_int_fun
| Type.Real -> parse_real_fun
| _ ->
  Format.asprintf "type %a is not supported" Type.pp_print_type t
  |> failwith


(* Unsafe string representation of an ident, used for rust identifiers. *)
let mk_id_legal = Id.string_of_ident false

(* Same as [mk_id_legal] but capitalizes the first letter to fit rust
conventions for type naming. *)
let mk_id_type id = mk_id_legal id |> String.capitalize

(* Prefix for all state variables. *)
let svar_pref = "svar_"


(* Gathers [LustreNode.equation] with [LustreNode.node_call] for ordering. *)
type equation =
| Eq of N.equation (* An equation. *)
| Call of (int * N.node_call) (* A call with a uid local to the node. *)

(* Identifier refering to the current state of the system called. *)
let id_of_call cnt { N.call_node_name } =
  Format.sprintf "%s_%d" (mk_id_legal call_node_name) cnt

(* Pretty prints an equation or a call. *)
let pp_print_equation fmt = function
| Eq eq -> N.pp_print_node_equation false fmt eq
| Call (cnt, call) ->
  Format.fprintf fmt "%a (%d)" (N.pp_print_call false) call cnt


(* Orders equations topologicaly based on the [expr_init] or [expr_next]
expression of the right-hand side of the equation. *)
let order_equations init_or_expr inputs equations =
  (* Checks if [svar] is defined in a list of equations or is an input. *)
  let is_defined sorted svar =
    List.exists (fun (_, svar') -> svar == svar') inputs
    || List.exists (function
      | Eq (svar', _, _) -> svar == svar'
      | Call (_, { N.call_outputs }) ->
        I.bindings call_outputs |> List.exists (
          fun (_, svar') -> svar == svar'
        )
    ) sorted
  in
  (* Sorts equations. *)
  let rec loop count later to_do sorted = match to_do with
    (* Equation. *)
    | (Eq (_, _, rhs)) as eq :: to_do ->
      let later, sorted =
        if
          init_or_expr rhs
          |> E.cur_term_of_expr (Numeral.succ E.base_offset)
          (* Extract svars. *)
          |> Term.state_vars_at_offset_of_term (Numeral.succ E.base_offset)
          (* All svars must be defined. *)
          |> SVS.for_all (is_defined sorted)
        then later, eq :: sorted else eq :: later, sorted
      in
      loop count later to_do sorted
    (* Node call. *)
    | (
      Call (
        _, { N.call_inputs ; N.call_outputs ; N.call_defaults }
      ) as eq
    ) :: to_do ->
      if call_defaults != None then (
        Format.printf "Compilating of condacts is not supported.@.@." ;
        failwith "could not compile system"
      ) ;
      let later, sorted =
        if
          I.bindings call_inputs
          (* All input svar must be defined. *)
          |> List.for_all (fun (_, svar) -> is_defined sorted svar)
        then later, eq :: sorted else eq :: later, sorted
      in
      loop count later to_do sorted
    (* Done. *)
    | [] -> (
      let count = count + 1 in
      if count <= (List.length equations) + 1 then
        match later with
        | [] -> List.rev sorted
        | _ -> loop count [] later sorted
      else (
        Format.printf
          "Some equations use undefined variables:@.  @[<v 2>%a@]@.@." (
            pp_print_list pp_print_equation "@ "
          ) later ;
        failwith "could not compile system"
      )
    )
  in
  loop 0 [] equations []



(* Pretty prints calls for struct documentation. *)
let fmt_calls_doc fmt = function
| [] -> Format.fprintf fmt "No subsystems for this system.@."
| calls -> Format.fprintf fmt "\
  | Lustre identifier | Struct | Inputs | Outputs | Position |@.\
  /// |:---:|:---:|:---:|:---:|:---:|@.\
  /// %a@.\
" ( pp_print_list
    ( fun fmt {
        N.call_pos ; N.call_node_name ; N.call_inputs ; N.call_outputs
      } ->
        Format.fprintf fmt
          "\
            | `%s` @?\
            | [%s](struct.%s.html) @?\
            | %a @?\
            | %a @?\
            | %a |\
          "
          (mk_id_legal call_node_name)
          (mk_id_type call_node_name)
          (mk_id_type call_node_name)
          (pp_print_list (fun fmt (_, svar) ->
              SVar.name_of_state_var svar
              |> Format.fprintf fmt "`%s`"
            ) ", "
          ) (I.bindings call_inputs)
          (pp_print_list (fun fmt (_, svar) ->
              SVar.name_of_state_var svar
              |> Format.fprintf fmt "`%s`"
            ) ", "
          ) (I.bindings call_outputs)
          pp_print_position call_pos
    ) "@./// "
  ) calls


(* Pretty prints assertions for struct documentation. *)
let fmt_asserts_doc fmt = function
| [] -> Format.fprintf fmt "No assertions for this system.@."
| asserts -> Format.fprintf fmt "%a@." (
  pp_print_list (fun fmt expr ->
    Format.fprintf fmt
      "- `%a`"
      (E.pp_print_lustre_expr false) expr
  ) "@ /// "
) asserts

(* Pretty prints assertions for a struct documentation. *)
let fmt_assumes_doc fmt = function
| [] -> Format.fprintf fmt "/// No assumptions for this system.@."
| assumes -> Format.fprintf fmt "\
  /// | State variable | Position | Number |@.\
  /// |:------:|:-----:|:-----:|@.\
  /// %a@.\
" ( pp_print_list (fun fmt {
      LustreContract.pos ; LustreContract.num ; LustreContract.svar
    } ->
      Format.fprintf fmt
        "| `%s` @?| %a @?| %d |"
        (SVar.name_of_state_var svar)
        pp_print_position pos
        num
    ) "@ /// "
  ) (List.rev assumes)


(* Writes the documentation for a struct for the implementation of a node. *)
let implem_doc_of_struct is_top fmt (
  name, inputs, outputs, calls, asserts, contract
) =
  Format.fprintf fmt "\
      /// Stores the state for %s `%s`.@.\
      ///@.\
      /// # Inputs@.\
      ///@.\
      /// | Lustre identifier | Type |@.\
      /// |:---:|:---|@.\
      /// %a@.\
      ///@.\
      /// # Outputs@.\
      ///@.\
      /// | Lustre identifier | Type |@.\
      /// |:---:|:---|@.\
      /// %a@.\
      ///@.\
      /// # Sub systems@.\
      ///@.\
      /// %a\
      ///@.\
      /// # Assertions@.\
      ///@.\
      /// %a\
      ///@.\
      /// # Assumptions@.\
      ///@.\
      %a\
      ///@.\
    "
    (if is_top then "**top node**" else "sub-node") name
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "| `%s` | %a |"
          (SVar.name_of_state_var svar)
          fmt_type (SVar.type_of_state_var svar)
      ) "@./// "
    ) inputs
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "| `%s` | %a |"
          (SVar.name_of_state_var svar)
          fmt_type (SVar.type_of_state_var svar)
      ) "@./// "
    ) outputs
    fmt_calls_doc calls
    fmt_asserts_doc asserts
    ( fun fmt -> function
      | None -> fmt_assumes_doc fmt []
      | Some { C.assumes } -> fmt_assumes_doc fmt assumes
    ) contract


(* Writes the documentation for a struct for the test oracle of a node. *)
let oracle_doc_of_struct is_top fmt (
  name, inputs, outputs, assumes, guarantees, modes, svar_source_map
) =
  Format.fprintf fmt "\
      /// Stores the state for the oracle for %s `%s`.@.\
      ///@.\
      /// # Inputs@.\
      ///@.\
      /// | Lustre identifier | Type | Source |@.\
      /// |:---:|:---:|:---|@.\
      /// %a@.\
      ///@.\
      /// # Outputs@.\
      ///@.\
      /// The outputs of the oracle are the guarantees of the original@.\
      /// system and the implications for each require of each mode.
      ///@.\
      /// That is, if a mode has requires `req_1`, ..., `req_n` and ensures@.\
      /// `ens_1`, ..., `ens_m` this will generate `m` outputs:@.\
      ///@.\
      /// - `(req_1 && ... && req_n) => ens_1`
      /// - ...
      /// - `(req_1 && ... && req_n) => ens_n`
      ///@.\
      /// Hence, an ensure output is false iff the mode is active and the
      /// ensure is false.
      ///@.\
      /// | Lustre identifier | Type |@.\
      /// |:---:|:---|@.\
      /// %a@.\
      ///@.\
      /// ## Guarantees@.\
      ///@.\
      /// %a\
      ///@.\
      /// %a\
      ///@.\
      /// # Assumptions@.\
      ///@.\
      %a\
      ///@.\
    "
    (if is_top then "**top node**" else "sub-node") name
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "| `%s` | %a | %a |"
          (SVar.name_of_state_var svar)
          fmt_type (SVar.type_of_state_var svar)
          N.pp_print_state_var_source (
            try
              SVM.find svar svar_source_map
            with Not_found ->
              Format.asprintf
                "can't find source of svar %a"
                SVar.pp_print_state_var svar
              |> failwith
          )
      ) "@./// "
    ) inputs
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "| `%s` | %a |"
          (SVar.name_of_state_var svar)
          fmt_type (SVar.type_of_state_var svar)
      ) "@./// "
    ) outputs
    ( fun fmt -> function
      | [] -> Format.fprintf fmt "No guarantees for this system.@."
      | guarantees ->
        Format.fprintf fmt "\
            | Lustre identifier | Assumption number | Position |@.\
            /// |:---:|:---:|:---|@.\
            /// %a@.
          "
          ( pp_print_list
            ( fun fmt { C.pos ; C.num ; C.svar } ->
                Format.fprintf fmt "| `%s` | %d | %a |"
                  (SVar.name_of_state_var svar)
                  num
                  pp_print_position pos
            ) "@./// "
          ) guarantees
    ) guarantees
    ( fun fmt -> function
      | [] -> Format.fprintf fmt "No modes for this system."
      | modes ->
        Format.fprintf fmt "%a@." (pp_print_list
          ( fun fmt { C.name ; C.pos ; C.ensures } ->
            Format.fprintf fmt "\
                ## Mode **%s**@.\
                ///@.\
                /// Position: *%a*.@.\
                ///@.\
                /// | Lustre identifier | Mode require number | Position |@.\
                /// |:---:|:---:|:---|@.\
                /// %a@.
              "
              (Id.string_of_ident false name)
              pp_print_position pos
              ( pp_print_list
                (fun fmt { C.pos ; C.num ; C.svar } ->
                  Format.fprintf fmt "| `%s` | %d | %a |"
                    (SVar.name_of_state_var svar)
                    num
                    pp_print_position pos
                ) "@./// "
              ) ensures
          ) "@.///@./// "
        ) modes
    ) modes
    fmt_assumes_doc assumes


(* Compiles a node to rust, writes it to a formatter. *)
let node_to_rust oracle_info is_top fmt (
  {
    N.inputs ; N.outputs ; N.locals ;
    N.equations ; N.state_var_source_map ; N.calls = real_calls ;
    N.asserts ; N.contract
  } as node
) =
  let calls, _ =
    real_calls |> List.fold_left (
      fun (l,cpt) c -> Call (cpt, c) :: l, cpt + 1
    ) ([], 0)
  in
  let equations =
    equations |> List.fold_left (fun eqs ( (svar, _, _) as eq ) ->
      (* if SVM.mem svar state_var_source_map
      then (Eq eq) :: eqs else eqs *)
      Eq eq :: eqs
    ) calls
  in
  let name = mk_id_legal node.N.name in
  let typ = mk_id_type node.N.name in

  let inputs, outputs, locals =
    I.bindings inputs, I.bindings outputs,
    locals |> List.map I.bindings |> List.flatten
    (* |> List.fold_left (fun locs index ->
      ( I.bindings index |> List.filter (fun (_, svar) ->
        SVM.mem svar state_var_source_map
        ) |> List.rev_append
      ) locs
    ) [] *)
  in

  (* Struct documentation for this system. *)
  ( match oracle_info with
    | None ->
      implem_doc_of_struct is_top fmt (
        name, inputs, outputs, real_calls, asserts, contract
      )
    | Some (assumes, guarantees, modes) ->
      oracle_doc_of_struct is_top fmt (
        name, inputs, outputs, assumes, guarantees, modes, state_var_source_map
      )
  ) ;

  (* Struct header. *)
  Format.fprintf fmt "pub struct %s {" typ ;

  (* Fields. *)
  inputs
  |> List.iter (fun (_, svar) ->
    Format.fprintf fmt "@.  /// Input: `%a`@.  pub %s%s: %a,"
      SVar.pp_print_state_var svar
      svar_pref
      (SVar.name_of_state_var svar)
      fmt_type (SVar.type_of_state_var svar)
  ) ;

  Format.fprintf fmt "@." ;

  outputs
  |> List.iter (fun (_, svar) ->
    Format.fprintf fmt "@.  /// Output: `%a`@.  pub %s%s: %a,"
      SVar.pp_print_state_var svar
      svar_pref
      (SVar.name_of_state_var svar)
      fmt_type (SVar.type_of_state_var svar)
  ) ;

  Format.fprintf fmt "@." ;

  locals |> List.iter (fun (_, svar) ->
    let source =
      try
        Format.asprintf ", %a"
          N.pp_print_state_var_source (
            SVM.find svar state_var_source_map
          )
      with Not_found -> ""
    in
    Format.fprintf
      fmt "@.  /// Local%s: `%a`@.  pub %s%s: %a,"
      source
      SVar.pp_print_state_var svar
      svar_pref
      (SVar.name_of_state_var svar)
      fmt_type (SVar.type_of_state_var svar)
  ) ;

  Format.fprintf fmt "@." ;

  calls |> List.iter (function
    | Call (cnt, ({ N.call_pos ; N.call_node_name } as call)) ->
      Format.fprintf
        fmt "@.  /// Call to `%a` (%a).@.  pub %s: %s,"
        (Id.pp_print_ident false) call_node_name
        pp_print_position call_pos
        (id_of_call cnt call)
        (mk_id_type call_node_name)
    | _ -> failwith "unreachable"
  ) ;

  Format.fprintf fmt "@.}@.@.impl Sys for %s {@." typ ;

  (* Input type. *)
  inputs
  |> Format.fprintf fmt "  type Input = (@.    @[<v>%a@]@.  ) ;@." (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "%a, // %s%s (%a)"
        fmt_type (SVar.type_of_state_var svar)
        svar_pref
        (SVar.name_of_state_var svar)
        SVar.pp_print_state_var svar
    ) "@ "
  ) ;

  (* Output type. *)
  outputs
  |> Format.fprintf fmt "  type Output = (@.    @[<v>%a@]@.  ) ;@." (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "%a, // %s%s (%a)"
        fmt_type (SVar.type_of_state_var svar)
        svar_pref
        (SVar.name_of_state_var svar)
        SVar.pp_print_state_var svar
    ) "@ "
  ) ;

  (* Arity. *)
  List.length inputs
  |> Format.fprintf fmt "  fn arity() -> usize { %d }@." ;

  (* Input parsing. *)
  let input_cpt = ref 0 in
  Format.fprintf fmt "  \
      @[<v>\
        fn input_of(vec: Vec<String>) -> Result<Self::Input, String> {@   \
          @[<v>\
            match vec.len() {@   \
              @[<v>\
                n if n == Self::arity() => {@   \
                  @[<v>\
                    Ok( (@   @[<v>%a@],@ ) )\
                  @]@ \
                },@ \
                n => Err(@   \
                  @[<v>\
                    format!(@   \
                      \"arity mismatch, expected {} but got {}: {:?}\",@   \
                      Self::arity(), n, vec@ \
                    )@ \
                  @]@ \
                ),\
              @]@ \
            }\
          @]@ \
        }\
      @]@.@.\
    "
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "try!( parse::%s(& vec[%d]) )" (
          SVar.type_of_state_var svar
          |> parser_for
        ) ! input_cpt ;
        input_cpt := 1 + !input_cpt
      ) ", @ "
    ) inputs ;

  (* Init. *)
  let input_cpt = ref 0 in
  let eqs_init =
    order_equations (fun expr -> expr.E.expr_init) inputs equations
  in
  Format.fprintf fmt "  \
      fn init(input: Self::Input) -> Result<Self, String> {@.    \
        @[<v>\
          // |===| Retrieving inputs.@ \
          %a@ @ \
          // |===| Computing initial state.@ \
          %a@ @ \
          // |===| Checking assertions.@ \
          %a@ @ \
          %a\
          // |===| Returning initial state.@ \
          Ok( %s {@   \
            @[<v>\
              // |===| Inputs.@ %a@ @ \
              // |===| Outputs.@ %a@ @ \
              // |===| Locals.@ %a@ @ \
              // |===| Calls.@ %a\
            @]@ \
          } )\
        @]@.  \
      }@.@.\
    "
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "let %s%s = input.%d ;"
          svar_pref
          (SVar.name_of_state_var svar) !input_cpt ;
        input_cpt := 1 + !input_cpt
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt -> function
        | Eq (svar, _, expr) ->
          expr.E.expr_init
          |> E.base_term_of_expr (Numeral.succ E.base_offset)
          |> Format.fprintf fmt "let %s%s = %a ;"
            svar_pref
            (SVar.name_of_state_var svar)
            (fmt_term svar_pref)
        | Call (
          cnt, ({ N.call_node_name ; N.call_inputs ; N.call_outputs } as call)
        ) ->
          Format.fprintf fmt
            "\
              let %s = try!( %s::init( (@   @[<v>%a,@]@ ) ) ) ;@ \
              let (@   @[<v>%a,@]@ ) = %s.output() ;@ \
            "
            (id_of_call cnt call)
            (mk_id_type call_node_name)
            ( pp_print_list (fun fmt (_, svar) ->
                Format.fprintf fmt "%s%s"
                  svar_pref (SVar.name_of_state_var svar)
              ) ",@ "
            ) (I.bindings call_inputs)
            ( pp_print_list (fun fmt (_, svar) ->
                Format.fprintf fmt "%s%s"
                  svar_pref (SVar.name_of_state_var svar)
              ) ",@ "
            ) (I.bindings call_outputs)
            (id_of_call cnt call)
      ) "@ "
    ) eqs_init
    ( fun fmt asserts ->
      if oracle_info = None
      then
        Format.fprintf fmt
          "\
            // |===| Checking assumptions.@ \
            %a@ @ \
          "
          ( pp_print_list (fun fmt expr ->
              Format.fprintf fmt
                "// %a@ if ! (@   %a@ ) {@   \
                  @[<v>\
                    return Err(@   \
                      \"assertion failure in system `%s`: %a\".to_string()@ \
                    )\
                  @]@ \
                } ;"
                (E.pp_print_lustre_expr false) expr
                (fmt_term svar_pref) (
                  expr.E.expr_init
                  |> E.base_term_of_expr (Numeral.succ E.base_offset)
                )
                name
                (E.pp_print_lustre_expr false) expr
            ) "@ "
          ) asserts
    ) asserts
    ( fun fmt -> function
      | None -> ()
      | Some { LustreContract.assumes } ->
        ( pp_print_list (fun fmt {
            LustreContract.pos ; LustreContract.num ; LustreContract.svar
          } ->
            Format.fprintf fmt
              "// Assumption number %d at %a@ if ! %s%s {@   \
                @[<v>\
                  return Err(@   \
                    \"assumption failure: \
                      %a (assumption number %d)\".to_string()@ \
                  )\
                @]@ \
              } ;"
              num
              pp_print_position pos
              svar_pref (SVar.name_of_state_var svar)
              pp_print_position pos
              num
          ) "@ "
        ) fmt (List.rev assumes)
    ) contract
    typ
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "%s: %s," name name
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "%s: %s," name name
      ) "@ "
    ) outputs
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "%s: %s," name name
      ) "@ "
    ) locals
    ( pp_print_list (fun fmt -> function
        | Call (cpt, call) ->
          let name = id_of_call cpt call in
          Format.fprintf fmt "%s: %s," name name
        | _ -> failwith "unreachable"
      ) "@ "
    ) calls ;

  (* Next. *)
  let input_cpt = ref 0 in
  let eqs_next =
    order_equations (fun expr -> expr.E.expr_step) inputs equations
  in
  Format.fprintf fmt "  \
      fn next(mut self, input: Self::Input) -> Result<Self, String> {@.    \
        @[<v>\
          // |===| Retrieving inputs.@ \
          %a@ @ \
          // |===| Computing next state.@ \
          %a@ @ \
          // |===| Checking assertions.@ \
          %a@ @ \
          // |===| Checking assumptions.@ \
          %a@ @ \
          // |===| Updating next state.@ \
          // |===| Inputs.@ %a@ @ \
          // |===| Outputs.@ %a@ @ \
          // |===| Locals.@ %a@ @ \
          // |===| Calls.@ %a@ @ \
          // |===| Return new state.@ Ok( self )\
        @]@.  \
      }@.@.\
    "
    ( pp_print_list (fun fmt (_, svar) ->
        Format.fprintf fmt "let %s%s = input.%d ;"
          svar_pref
          (SVar.name_of_state_var svar) !input_cpt ;
        input_cpt := 1 + !input_cpt
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt -> function
        | Eq (svar, _, expr) ->
          expr.E.expr_step
          |> E.cur_term_of_expr (Numeral.succ E.base_offset)
          |> Format.fprintf fmt "let %s%s = %a ;"
            svar_pref
            (SVar.name_of_state_var svar)
            (fmt_term svar_pref)
        | Call (
          cnt, ({ N.call_node_name ; N.call_inputs ; N.call_outputs } as call)
        ) ->
          Format.fprintf fmt
            "\
              let %s = try!( self.%s.next( (@   @[<v>%a,@]@ ) ) ) ;@ \
              let (@   @[<v>%a,@]@ ) = %s.output() ;\
            "
            (id_of_call cnt call)
            (id_of_call cnt call)
            ( pp_print_list (fun fmt (_, svar) ->
                Format.fprintf fmt "%s%s"
                  svar_pref (SVar.name_of_state_var svar)
              ) ",@ "
            ) (I.bindings call_inputs)
            ( pp_print_list (fun fmt (_, svar) ->
                Format.fprintf fmt "%s%s"
                  svar_pref (SVar.name_of_state_var svar)
              ) ",@ "
            ) (I.bindings call_outputs)
            (id_of_call cnt call)
      ) "@ "
    ) eqs_next
    ( pp_print_list (fun fmt expr ->
        Format.fprintf fmt
          "// %a@ if ! (@   %a@ ) {@   \
            @[<v>\
              return Err(@   \
                \"assertion failure: %a\".to_string()@ \
              )\
            @]@ \
          } ;"
          (E.pp_print_lustre_expr false) expr
          (fmt_term svar_pref) (
            expr.E.expr_step
            |> E.base_term_of_expr (Numeral.succ E.base_offset)
          )
          (E.pp_print_lustre_expr false) expr
      ) "@ "
    ) asserts
    ( fun fmt -> function
      | None -> ()
      | Some { LustreContract.assumes } ->
        ( pp_print_list (fun fmt {
            LustreContract.pos ; LustreContract.num ; LustreContract.svar
          } ->
            Format.fprintf fmt
              "// Assumption number %d at %a@ if ! %s%s {@   \
                @[<v>\
                  return Err(@   \
                    \"assumption failure: \
                      %a (assumption number %d)\".to_string()@ \
                  )\
                @]@ \
              } ;"
              num
              pp_print_position pos
              svar_pref (SVar.name_of_state_var svar)
              pp_print_position pos
              num
          ) "@ "
        ) fmt (List.rev assumes)
    ) contract
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "self.%s = %s ;" name name
      ) "@ "
    ) inputs
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "self.%s = %s ;" name name
      ) "@ "
    ) outputs
    ( pp_print_list (fun fmt (_, svar) ->
        let name = svar_pref ^ SVar.name_of_state_var svar in
        Format.fprintf fmt "self.%s = %s ;" name name
      ) "@ "
    ) locals
    ( pp_print_list (fun fmt -> function
        | Call (cpt, call) ->
          let name = id_of_call cpt call in
          Format.fprintf fmt "self.%s = %s ;" name name
        | _ -> failwith "unreachable"
      ) "@ "
    ) calls ;

  (* Output. *)
  outputs
  |> Format.fprintf fmt "  \
    fn output(& self) -> Self::Output {(@.    \
      @[<v>%a@],@.  \
    )}@.\
  " (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "self.%s%s" svar_pref (SVar.name_of_state_var svar)
    ) ",@ "
  ) ;

  (* Output to string. *)
  Format.fprintf fmt "  \
    @[<v>\
      fn output_str(& self) -> String {@   \
        @[<v>\
          format!(@   \
            @[<v>\"%a\",@ %a@]@ \
          )\
        @]@ \
      }\
    @]@.\
  " (
    pp_print_list (fun fmt _ -> Format.fprintf fmt "{}") ", \\@ "
  ) outputs (
    pp_print_list (fun fmt (_, svar) ->
      Format.fprintf fmt "self.%s%s" svar_pref (SVar.name_of_state_var svar)
    ) ",@ "
  ) outputs ;

  Format.fprintf fmt "}@.@." ;

  calls |> List.map (
    function
    | Call (_, { N.call_node_name } ) -> call_node_name
    | _ -> failwith "unreachable"
  )

(* Dumps the default [Cargo.toml] file in a directory. *)
let dump_toml name dir =
  let out_channel = Format.sprintf "%s/Cargo.toml" dir |> open_out in
  let fmt = Format.formatter_of_out_channel out_channel in
  Format.fprintf fmt
    "\
      [package]@.\
      name = \"%s\"@.\
      version = \"1.0.0\"@.\
      authors = [\"Kind 2 <cesare-tinelli@uiowa.edu>\"]@.\
    "
    name ;
  close_out out_channel

let to_rust oracle_info target find_sub top =
  let top_name, top_type = mk_id_legal top.N.name, mk_id_type top.N.name in
  (* Creating project directory if necessary. *)
  mk_dir target ;
  (* Creating source dir. *)
  let src_dir = Format.sprintf "%s/src" target in
  mk_dir src_dir ;
  (* Dump toml configuration file. *)
  dump_toml top_name target ;
  (* Opening writer to file. *)
  let file = Format.sprintf "%s/main.rs" src_dir in
  let out_channel = open_out file in
  let fmt = Format.formatter_of_out_channel out_channel in
  Format.pp_set_margin fmt max_int ;

  (* Write prefix and static stuff. *)
  Format.fprintf
    fmt "%a@.%a@.@.%s@.@."
    ( match oracle_info with
      | None -> fmt_prefix_implem top_name
      | _    -> fmt_prefix_oracle top_name
    ) top_type
    fmt_main top_type
    (* (consts "unimplemented" "unimplemented" "unimplemented") *)
    file_static ;

  let rec compile is_top compiled = function
    | node :: nodes ->
      let compiled, nodes =
        if Id.Set.mem node.N.name compiled |> not then (
          (* Oracle info only makes sense for the top node. *)
          let oracle_info = if not is_top then None else oracle_info in
          (* Remembering we compiled this node. *)
          let compiled = Id.Set.add node.N.name compiled in
          
          compiled,
          nodes @ (
            (* Compiling nodes, getting subnodes back. *)
            node_to_rust oracle_info is_top fmt node
            (* Discarding subnodes we already compiled. *)
            |> List.fold_left (fun l call_id ->
              if Id.Set.mem call_id compiled |> not
              then (Id.to_scope call_id |> find_sub) :: l else l
            ) []
          )
        ) else compiled, nodes
      in
      compile false compiled nodes
    | [] -> ()
  in

  compile true Id.Set.empty [ top ] ;


  Format.fprintf fmt "@.@." ;

  (* Flush and close file writer. *)
  close_out out_channel


let print_trie desc =
  Format.printf "%s: @[<v>%a@]@.@."
    desc
    ( I.pp_print_trie
      ( fun fmt (lst, svar) ->
        Format.fprintf fmt "%a -> %a"
          (I.pp_print_one_index true) (List.hd lst)
          SVar.pp_print_state_var svar
      ) "@ "
    )

let implem_to_rust = to_rust None

let oracle_to_rust target find_sub top =
  (* Successor of the max index of some trie. *)
  let next_index_of trie = I.top_max_index trie |> succ in
  let is_ghost svar =
    try (
      match SVM.find svar top.N.state_var_source_map with
      | N.Ghost -> true
      | _ -> false
    ) with Not_found -> false
  in
  (* let print_svar_source svar =
    try
      Format.printf "%a: %a@."
        SVar.pp_print_state_var svar
        N.pp_print_state_var_source (SVM.find svar top.N.state_var_source_map)
    with
      Not_found -> Format.printf "%a: not found@." SVar.pp_print_state_var svar
  in *)

  (* Format.printf "@.@.Inputs:@." ;
  top.N.inputs |> I.bindings
  |> List.iter (fun (_, svar) -> print_svar_source svar) ;
  Format.printf "@.@.Outputs:@." ;
  top.N.outputs |> I.bindings
  |> List.iter (fun (_, svar) -> print_svar_source svar) ;
  Format.printf "@.@.Locals:@." ;
  top.N.locals |> List.iter (
    fun loc -> I.bindings loc |> List.iter (
      fun (_, svar) -> print_svar_source svar
    )
  ) ;
  Format.printf "@.@.Equations:@." ;
  top.N.equations |> List.iter (
    fun eq -> Format.printf "  %a@." (N.pp_print_node_equation false) eq
  ) ;
  Format.printf "@.@.Calls:@." ;
  top.N.calls |> List.iter (
    fun call -> Format.printf "  %a@." (N.pp_print_call false) call
  ) ;
  Format.printf "@.@." ; *)

  (* Appends two tries. *)
  let append lhs rhs =
    I.fold (
      fun index svar trie -> match index with
      | _ :: index ->
        I.add (
          I.ListIndex (next_index_of trie) :: index
        ) svar trie
      | [] -> failwith "empty index of outputs"
    ) rhs lhs
  in
  
  (* Adding to inputs. *)
  let inputs = append top.N.inputs top.N.outputs in

  (* Outputs are guarantees and mode ensures. *)
  let (outputs, output_svars, output_eqs), oracle_info =
    match top.N.contract with
    | None -> failwith "cannot generate oracle for contract-free node"
    | Some contract ->
      let outputs, output_svars =
        contract.C.guarantees |> List.fold_left (fun (trie, outs) svar ->
          I.add (
            [ I.ListIndex (next_index_of trie) ]
          ) svar.C.svar trie,
          SVS.add svar.C.svar outs
        ) (I.empty, SVS.empty)
      in
      contract.C.modes |> List.fold_left (fun (trie, outs, eqs) {
        C.name ; C.requires ; C.ensures
      } ->
        ensures |> List.fold_left (fun (trie, outs, eqs) svar ->
          let output =
            SVar.mk_state_var
              ( Format.sprintf "mode_%s_%d"
                  (Id.string_of_ident false name) svar.C.num
              ) [] Type.t_bool
          in
          let expr =
            requires
            |> List.map (fun req -> E.mk_var req.C.svar)
            |> E.mk_and_n
            |> fun lhs -> E.mk_impl lhs (E.mk_var svar.C.svar)
          in
          I.add (
            [ I.ListIndex (next_index_of trie) ]
          ) output trie,
          SVS.add output outs,
          (output, [], expr) :: eqs
        ) (trie, outs, eqs)
      ) (outputs, output_svars, []),
      Some (
        contract.C.assumes, contract.C.guarantees, contract.C.modes
      )
  in

  let locals =
    top.N.locals |> List.filter (
      fun loc ->
        I.bindings loc
        |> List.exists ( fun (_, svar) -> SVS.mem svar output_svars |> not )
    )
  in

  (* Format.printf "@.@.Inputs:@." ;
  inputs |> I.bindings
  |> List.iter (fun (_, svar) -> print_svar_source svar) ;
  Format.printf "@.@.Outputs:@." ;
  outputs |> I.bindings
  |> List.iter (fun (_, svar) -> print_svar_source svar) ;
  Format.printf "@.@.Locals:@." ;
  locals |> List.iter (
    fun loc -> I.bindings loc |> List.iter (
      fun (_, svar) -> print_svar_source svar
    )
  ) ;
  Format.printf "@.@.Equations:@." ;
  top.N.equations |> List.iter (
    fun eq -> Format.printf "  %a@." (N.pp_print_node_equation false) eq
  ) ;
  Format.printf "@.@." ; *)

  (* Only keep equations about ghost variables. *)
  let equations =
    (* let outputs = I.bindings top.N.outputs |> List.map snd in
    top.N.equations |> List.filter (
      fun (svar, _, _) ->
        is_ghost svar && (List.mem svar outputs |> not)
    ) *)
    output_eqs @ top.N.equations
  in

  (* Only keep calls about ghost variables. *)
  let calls =
    (* top.N.calls |> List.filter (
      fun ({ N.call_inputs }: N.node_call) ->
        I.bindings call_inputs |> List.for_all (
          fun (_, svar) -> is_ghost svar
        )
    ) *)
    top.N.calls
  in

  (* Creating node and compiling. *)
  { top with
    N.inputs = inputs ;
    N.outputs = outputs ;
    N.locals = locals ;
    N.equations = equations ;
    N.calls = calls ;
  } |> to_rust oracle_info target find_sub


