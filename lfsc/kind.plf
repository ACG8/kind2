;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                  ;;
;; Signature for k-induction proofs ;;
;;                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Depends on sat.plf, th_base.plf and smt.plf


(declare Int sort)
(define index Int)
(declare int (! n mpz (term Int)))

;; relations over indexes (used for transition relation)
(define rel (! x mpz (! y mpz formula)))

;; sets over indexes (used for initial formula)
(define set (! x mpz formula))


(declare invariant (! I set (! T rel (! P set type))))

;; ;; unary encoding of naturals
;; (declare nat type)
;; (declare O nat)
;; (declare S (! n nat nat))

;; ;; conversions to/from mpz

;; (program mpz_of_nat ((n nat)) mpz
;;   (match n
;;     (O 0)
;;     ((S m) (mp_add 1 (mpz_of_nat m)))))

;; (program nat_of_mpz ((z mpz)) nat
;;   (mp_ifneg z (fail nat)
;;   (mp_ifzero z O
;;   (S (nat_of_mpz (mp_add z (~ 1)))))))

;; (run (nat_of_mpz 3))
;; (run (nat_of_mpz (~ 3)))


;; Unrolling transition relation k times starting from the initial state
(program unroll_from ((T rel) (I set) (k mpz)) formula
 (mp_ifneg k
   (fail formula)
   (mp_ifzero k
     (I 0)
     (let j (mp_add k (~ 1))
       (and (unroll_from T I j) (T j k))))))


;; (define trans (! x %index% (! y %index% formula)))
;; (define init (! x %index% formula))

;; (program unroll_from2 ((I init) (T trans) (k %index%)) formula
;;   (match k
;;     (%%0 (I %%0))
;;     (default           
;;      (let j (decr_index k)
;;        (and (unroll_from2 I T j) (T j k)))))))






;; (define trans (! _ (term Int) (! _ (term Int) formula)))
;; (define init (! x (term Int) formula))

;; (check (: (term Int) (int 0)))
;; (declare ii init)
;; (check (: formula (ii (int 0))))

;; (define unrollf
;;   (: (! I init (! T trans (! k mpz formula)))
;;      (mp_ifzero k
;;        (I (int 0))
;;        (@ j (mp_add k (~ 1))
;;           (and (unrollf I T j) (T (int j) (int k)))))))

        
;; (program test ((I init)) formula
;;          (I (int 0)))

;; (declare T trans)
;; (declare I init)

;; (program test2 ((k mpz)) formula
;;          (ii (int 0)))

;; (program unroll_from2 ((k mpz)) formula
;;  (mp_ifneg k
;;    (fail formula)
;;    (mp_ifzero k
;;      (I (int 0))
;;      (let j (mp_add k (~ 1))
;;        (and (unroll_from2 j) (T (int j) (int k)))))))



;; TODO: we might need to embed indexes in terms data structure depending on
;; the actual types of T and I

;; (define trans (term (arrow Int (arrow Int Bool))))
;; (define init (term (arrow Int Bool)))
;; (define term_Int (term Int))

;; (run (int 0))


;; lfsc loops on that

;; (program unroll_from
;;  ((T trans)
;;   (I init)
;;   (k term_Int))
;;  formula
;;  (match k
;;  ((term (int k2))
;;   (mp_ifneg k2
;;    (fail formula)
;;    (mp_ifzero k2
;;      (p_app (apply Int Bool I k))
;;      (let j (term (int (mp_add k2 (~ 1))))
;;        (and (unroll_from T I j) (p_app (apply Int Bool (apply Int (arrow Int Bool) T j) k)))))))))

;; (program unroll_from
;;  ((T trans)
;;   (I init)
;;   (k mpz))
;;  formula
;;  (let kt (int k)
;;  (let km1 (mp_add k (~ 1))
;;  (let km1t (int km1)
;;  (mp_ifneg k
;;    (fail formula)
;;    (mp_ifzero k
;;      (p_app (apply Int Bool I kt))
;;      (and (unroll_from T I km1) (p_app (apply Int Bool (apply Int (arrow Int Bool) T km1t) kt)))))))))


;; (run 1)


;; base for k steps

(program base_k ((I set) (T rel) (P set) (k mpz)) formula
 (mp_ifneg k
   (fail formula)
   (mp_ifzero k
     (and (unroll_from T I 0) (not (P 0)))
     (let j (mp_add k (~ 1))
       (or (base_k I T P j) (and (unroll_from T I k) (not (P k))))))))


;; base for k steps

(program base ((I set) (T rel) (P set) (k mpz)) formula
 (base_k I T P (mp_add k (~ 1))))

;; unroll step case under assumption

(program unroll_with ((T rel) (P set) (k mpz)) formula
 (mp_ifneg k
   (fail formula)
   (mp_ifzero k
     (P 0)
     (let j (mp_add k (~ 1))
       (mp_ifzero j
          (and (P 0) (T 0 1))
          (and (unroll_with T P j) (and (P j) (T j k))))))))


(program step ((T rel) (P set) (k mpz)) formula
  (and (unroll_with T P k) (not (P k))))


;; Rule for strengthening of invariants

(declare invariant-implies2
  (! I set
  (! T rel
  (! P1 set
  (! P2 set

  (! u
     (! k mpz      
     (! v1 (th_holds (P1 k))
     (! v2 (th_holds (not (P2 k)))
        (holds cln))))

  (! i1
     (invariant I T P1)
  ;--------------------------------
  (invariant I T P2)

  )))))))



;; Other version

(declare invariant-implies
  (! I set
  (! T rel
  (! P1 set
  (! P2 set

  ;; proof that P1 => P2
  (! u
     (! k mpz      
     (! v (th_holds (not (impl (P1 k) (P2 k))))
        (holds cln)))

  ;; proof that P1 is invariant
  (! i1
     (invariant I T P1)

  ;--------------------------------
  (invariant I T P2)

  )))))))


;; Rule for k-induction principle

(declare kinduction
  (! k mpz      ; bound k
  (! I set      ; initial states
  (! T rel      ; transition relation
  (! P set      ; k-inductice invariant

  (! B formula  ; formula for base case (see sc r1)
  (! r1 (^ (base I T P k) B)

  (! S formula  ; formula for step case (see sc r2)
  (! r2 (^ (step T P k) S)
         
  (! ub (! vb (th_holds B) (holds cln)) ; proof of base

  (! us (! vs (th_holds S) (holds cln)) ; proof of step


  ;------------------------------------
  (invariant I T P)

  )))))))))))

     
;;-------------------------------------------------------------------------
;; Some tests

;; (define T (: rel (\ x (\ y (and (= _ (int x) (int 1)) (= _ (int y) (int 2)))))))
;; (define I (: set (\ x (= _ (int x) (int 0)))))

;; (declare T rel)
;; (declare I set)
;; (declare P set)


;; (run (unroll_from T I 4)))
;; ;; result:
;; ;; (and (and (and (and (I 0) (T 0 1)) (T 1 2)) (T 2 3)) (T 3 4))
;; (run (unroll_from T I (~ 1))))
;; ;; result:
;; ;; fail

;; (run (base I T P 2))
;; (run (base I T P 4))
;; (run (base I T P (~ 1)))
;; (run (base I T P 0))
;; (run (base I T P 1))

;; (run (unroll_with T P 4))
;; (run (unroll_with T P 1))
;; (run (unroll_with T P 0))
;; (run (unroll_with T P (~ 1)))

;; (run (step T P 2))
;; (run (step T P 4))

;; ;;-------------------------------------------------------------------------


;; (check

;;  (% xI set
;;  (% xT rel
;;  (% xP set

;;  (% B2 (th_holds (or (and (xI 0) (not (xP 0))) (and (and (xI 0) (xT 0 1)) (not (xP 1)))))
;;  (% S2 (th_holds (and (and (and (xP 0) (xT 0 1)) (and (xP 1) (xT 1 2))) (not (xP 2))))
    
;;  (: (invariant xI xT xP)

;;  (kinduction 2 _ _ _
;;    ;; _ _
;;    ;; B and S can be inferred from the other types (and the side conditions?)
;;    (or (and (xI 0) (not (xP 0))) (and (and (xI 0) (xT 0 1)) (not (xP 1))))
             
;;    (and (and (and (xP 0) (xT 0 1)) (and (xP 1) (xT 1 2))) (not (xP 2)))


;;    (\ pb (clausify_false (trust))) ;; hole for proof of base at 2
     
;;    (\ ps (clausify_false (trust))) ;; hole for proof of step at 2

;;  ))))))))
   
