<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="include/style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="LustreSlicing.html">
<link rel="next" href="LustreInput.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Log" rel="Chapter" href="Log.html">
<link title="Event" rel="Chapter" href="Event.html">
<link title="Strategy" rel="Chapter" href="Strategy.html">
<link title="Analysis" rel="Chapter" href="Analysis.html">
<link title="Flags" rel="Chapter" href="Flags.html">
<link title="InvarManager" rel="Chapter" href="InvarManager.html">
<link title="Kind2" rel="Chapter" href="Kind2.html">
<link title="InputSystem" rel="Chapter" href="InputSystem.html">
<link title="Eval" rel="Chapter" href="Eval.html">
<link title="Ident" rel="Chapter" href="Ident.html">
<link title="Ltree" rel="Chapter" href="Ltree.html">
<link title="Model" rel="Chapter" href="Model.html">
<link title="Scope" rel="Chapter" href="Scope.html">
<link title="Simplify" rel="Chapter" href="Simplify.html">
<link title="StateVar" rel="Chapter" href="StateVar.html">
<link title="Symbol" rel="Chapter" href="Symbol.html">
<link title="TermAttr" rel="Chapter" href="TermAttr.html">
<link title="Term" rel="Chapter" href="Term.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="UfSymbol" rel="Chapter" href="UfSymbol.html">
<link title="Var" rel="Chapter" href="Var.html">
<link title="Property" rel="Chapter" href="Property.html">
<link title="SubSystem" rel="Chapter" href="SubSystem.html">
<link title="TransSys" rel="Chapter" href="TransSys.html">
<link title="Actlit" rel="Chapter" href="Actlit.html">
<link title="Base" rel="Chapter" href="Base.html">
<link title="Compress" rel="Chapter" href="Compress.html">
<link title="Step" rel="Chapter" href="Step.html">
<link title="Clause" rel="Chapter" href="Clause.html">
<link title="CooperQE" rel="Chapter" href="CooperQE.html">
<link title="Extract" rel="Chapter" href="Extract.html">
<link title="IC3" rel="Chapter" href="IC3.html">
<link title="Poly" rel="Chapter" href="Poly.html">
<link title="Presburger" rel="Chapter" href="Presburger.html">
<link title="QE" rel="Chapter" href="QE.html">
<link title="InvGenMiner" rel="Chapter" href="InvGenMiner.html">
<link title="InvGenDomain" rel="Chapter" href="InvGenDomain.html">
<link title="InvGenGraph" rel="Chapter" href="InvGenGraph.html">
<link title="InvGen" rel="Chapter" href="InvGen.html">
<link title="LockStepDriver" rel="Chapter" href="LockStepDriver.html">
<link title="InputParser" rel="Chapter" href="InputParser.html">
<link title="Interpreter" rel="Chapter" href="Interpreter.html">
<link title="LustreLexer" rel="Chapter" href="LustreLexer.html">
<link title="LustreParser" rel="Chapter" href="LustreParser.html">
<link title="LustreAst" rel="Chapter" href="LustreAst.html">
<link title="LustreIdent" rel="Chapter" href="LustreIdent.html">
<link title="LustreIndex" rel="Chapter" href="LustreIndex.html">
<link title="LustreExpr" rel="Chapter" href="LustreExpr.html">
<link title="LustreNode" rel="Chapter" href="LustreNode.html">
<link title="LustreContext" rel="Chapter" href="LustreContext.html">
<link title="LustreDeclarations" rel="Chapter" href="LustreDeclarations.html">
<link title="LustreSimplify" rel="Chapter" href="LustreSimplify.html">
<link title="LustreSlicing" rel="Chapter" href="LustreSlicing.html">
<link title="LustreTransSys" rel="Chapter" href="LustreTransSys.html">
<link title="LustreInput" rel="Chapter" href="LustreInput.html">
<link title="LustrePath" rel="Chapter" href="LustrePath.html">
<link title="NativeInput" rel="Chapter" href="NativeInput.html">
<link title="Pretty" rel="Chapter" href="Pretty.html">
<link title="SMTExpr" rel="Chapter" href="SMTExpr.html">
<link title="SMTLIBSolver" rel="Chapter" href="SMTLIBSolver.html">
<link title="SMTSolver" rel="Chapter" href="SMTSolver.html">
<link title="SolverDriver" rel="Chapter" href="SolverDriver.html">
<link title="SolverResponse" rel="Chapter" href="SolverResponse.html">
<link title="SolverSig" rel="Chapter" href="SolverSig.html">
<link title="CVC4Driver" rel="Chapter" href="CVC4Driver.html">
<link title="GenericSMTLIBDriver" rel="Chapter" href="GenericSMTLIBDriver.html">
<link title="Z3Driver" rel="Chapter" href="Z3Driver.html">
<link title="Yices2SMT2Driver" rel="Chapter" href="Yices2SMT2Driver.html">
<link title="YicesDriver" rel="Chapter" href="YicesDriver.html">
<link title="YicesLexer" rel="Chapter" href="YicesLexer.html">
<link title="YicesNative" rel="Chapter" href="YicesNative.html">
<link title="YicesResponse" rel="Chapter" href="YicesResponse.html">
<link title="Debug" rel="Chapter" href="Debug.html">
<link title="Decimal" rel="Chapter" href="Decimal.html">
<link title="Hashcons" rel="Chapter" href="Hashcons.html">
<link title="HString" rel="Chapter" href="HString.html">
<link title="HStringSExpr" rel="Chapter" href="HStringSExpr.html">
<link title="Kind2Config" rel="Chapter" href="Kind2Config.html">
<link title="Lib" rel="Chapter" href="Lib.html">
<link title="Messaging" rel="Chapter" href="Messaging.html">
<link title="Numeral" rel="Chapter" href="Numeral.html">
<link title="SExprBase" rel="Chapter" href="SExprBase.html">
<link title="SExprLexer" rel="Chapter" href="SExprLexer.html">
<link title="Stat" rel="Chapter" href="Stat.html">
<link title="TermLib" rel="Chapter" href="TermLib.html">
<link title="Trie" rel="Chapter" href="Trie.html">
<link title="Version" rel="Chapter" href="Version.html">
<link title="LustreToRust" rel="Chapter" href="LustreToRust.html">
<link title="TestgenDF" rel="Chapter" href="TestgenDF.html">
<link title="TestgenIO" rel="Chapter" href="TestgenIO.html">
<link title="TestgenModes" rel="Chapter" href="TestgenModes.html">
<link title="TestgenSolver" rel="Chapter" href="TestgenSolver.html">
<link title="TestgenStrategies" rel="Chapter" href="TestgenStrategies.html">
<link title="TestgenTree" rel="Chapter" href="TestgenTree.html">
<link title="TestgenLib" rel="Chapter" href="TestgenLib.html"><title>Kind 2 Developer's Documentation : LustreTransSys</title>
</head>
<body>
<div class="navbar"><a class="pre" href="LustreSlicing.html" title="LustreSlicing">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="LustreInput.html" title="LustreInput">Next</a>
</div>
<h1>Module <a href="type_LustreTransSys.html">LustreTransSys</a></h1>

<pre><span class="keyword">module</span> LustreTransSys: <code class="code"><span class="keyword">sig</span></code> <a href="LustreTransSys.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Convert a Lustre node to a transition system
<p>

    <h1 id="1_VerificationofContracts">Verification of Contracts</h1>
<p>

    From a node's contract annotations, it has requirements that can
    be assumed invariant, and guarantees that have to be shown
    invariant. Each caller of a node must show it keeps the
    requirementes of the callee at call site invariant.
<p>

    Besides these proof obligations from contracts, a node may be
    annotated with properties that are to be shown invariant under the
    assumption of the requirements from its contracts.
<p>

    Every proof obligation of a called node is instantiated at call
    site as a proof obligation of the calling node. An instantiated
    proof obligation is less general than the one it is generated
    from, because it is embedded in the context of the caller.
<p>

    Only proof obligations of the top node are considered, the proof
    obligations of sub-nodes are disregarded in the analysis. All
    proof obligations are considered together, but some verification
    engines may be able to prove invariance of a subset of the proof
    obligations before other proof obligations. 
<p>

    To generate proof obligations for a transition system, we exploit
    instantiation of proof obligations, multi-property verification
    and information from previous analysis runs in the following way.
<p>

    For every node with a contract but the top node, add a proof
    obligation for its requirements. This proof obligation will be not
    be seen by the analysis, but is instantiated by each caller. The
    requirements of the top node are assumed to be invariant.
<p>

    For every node, unless it is abstracted to its contract, add its
    guarantee as a proof obligation. If the guarantee has been
    shown in a previous anaysis run, it becomes an invariant
    instead. If the guarantee remains a proof obligation, it is
    instantied in each calling node, and is proved together with all
    other other proof obligations, thus strengthening the
    analysis. For every node that is abstracted to its contract, add
    the guarantee as an invariant, since it can only be proved by
    providing the implementation.
<p>

    This approach works for any combination of modular and
    compositional analysis. 
<p>

    <h1 id="1_LustreExpressions">Lustre Expressions</h1>
<p>

    A Lustre expression <a href="LustreExpr.html#TYPEt"><code class="code"><span class="constructor">LustreExpr</span>.t</code></a> is rewritten to a normal form
    in the following ways.
<p>

    There is exactly one <code class="code"><span class="keywordsign">-&gt;</span></code> operator at the top of the expression,
    thus an expression can be represented as a pair of expressions
    <code class="code">(i, t)</code> without <code class="code"><span class="keywordsign">-&gt;</span></code> operators. 
<p>

    The argument of a <code class="code">pre</code> operator is always a variable, therefore
    an expression <code class="code">pre x</code> operator can be represented by the variable
    <code class="code">x</code> at the previous state. A non-variable expression under a <code class="code">pre</code>
    is abstracted to a fresh variable that is defined by this
    expression.
<p>

    There are no node calls in a Lustre expression. They are
    abstracted out and the results are captured in fresh variables. If
    an input parameter of a node contains a <code class="code">pre</code> operator, the
    expression has to be abstracted to a fresh variable.
<p>

    <h1 id="1_LustreNodes">Lustre Nodes</h1> 
<p>

    A Lustre node <a href="LustreNode.html#TYPEt"><code class="code"><span class="constructor">LustreNode</span>.t</code></a> is simplified and rewritten in the
    following ways.
<p>

    Streams are flattened such that each element of a tuple, a record
    or an array becomes a separate stream. Constants are expanded in
    expressions.
<p>

    An equational definition of a stream becomes an association of the
    variable of the stream to a Lustre expression as described above,
    where no temporal operators occur, and all node calls are
    abstracted out. Each unguarded pre operators is replaced by a
    fresh constant variable that is an oracle for the initial value.
<p>

    Assertions are Lustre expressions of Boolean type, properties are
    abstracted to variables of Boolean type.
<p>

    When creating simplified Lustre expressions, all node calls are
    abstracted such that the return values are assigned to fresh
    variables. Further, expressions under a <code class="code">pre</code> operator and
    parameters of node calls that contain a <code class="code">pre</code> operator are
    abstracted to definitions of fresh variables. 
<p>

    The definitions of variables are ordered such that the definition of
    a variable <code class="code">x</code> occurs before all definitions that use variable <code class="code">x</code>.
<p>

    <h1 id="1_Translation">Translation</h1>
<p>

    Each Lustre node is translated to two definitions of fresh
    uninterpreted predicate symbols over a set of stateful variables
    of the node. The first predicate constrains the initial values of
    the variables, the second predicate constrains the set of primed
    variables as a function of the set of unprimed variables.
<p>

    A variable is stateful if it is 
<p>
<ul>
<li>an input variable, </li>
<li>an output variable, or</li>
<li>a property variable, or further,</li>
<li>a variable occurring under a <code class="code">pre</code> operator in any expression in
      the node, or</li>
<li>a variable capturing the output of a node call.</li>
</ul>

    The predicates are defined as the conjunction of equational
    definitions of stateful variables, assertions and predicates of
    node calls. Equational definitions of not stateful variable are
    substituted by binding the variable to a <code class="code"><span class="keyword">let</span></code> definition.
<p>

    The <code class="code">depth_input</code> and <code class="code">max_depth_input</code> control the abstraction of
    the nodes for which a contract is available. Both are constants
    and are inputs of the node. When instantiating a node with a
    contract, the value of the depth input is the caller's depth input
    plus one, meaning that since this node has a contract we are going
    down one abstraction level. The max depth input always has the
    same value and is passed as an input for the sake of uniformity.
<p>

    The init / trans predicates are conditional on the depth input.
    If the value of the depth input is greater than the max depth
    input, then the contract definition of the node is used instead of
    the actual init / trans predicate. In this case, lifting the
    properties of the subnode might not make sense since the actual
    init / trans predicate is not used. The abstract predicates
    therefore constrain all the properties to evaluate to true.
<p>

    Predicates are thus defined as
    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(depth_input&nbsp;&lt;&nbsp;max_depth_input)&nbsp;=&gt;&nbsp;contract&nbsp;<span class="keyword">and</span>&nbsp;(props&nbsp;=&nbsp;<span class="keyword">true</span>)&nbsp;</code></pre>
    <pre class="codepre"><code class="code">&nbsp;not&nbsp;(depth_input&nbsp;&lt;&nbsp;max_depth_input)&nbsp;=&gt;&nbsp;concrete_predicate&nbsp;</code></pre>
<p>

    <h1 id="1_CondactEncoding">Condact Encoding</h1>
<p>

    If a node call has an activation condition that is not the constant
    true, additional fresh variables are generated. One variable is
    initially false and becomes and remains true on the first time the
    activation condition is true. Further, all input variables are
    duplicated to shadow input variables that freeze the input values
    at the last instant the activation condition has been true.
<p>

    The <code class="code">init_flag</code> flag is <code class="code"><span class="keyword">true</span></code> from the first state up to the
    state when the clock first ticks, including that state. After that
    state, the flag is false forever.
    For example:
    <pre class="codepre"><code class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">false</span>&nbsp;<span class="keyword">false</span>&nbsp;<span class="keyword">true</span>&nbsp;<span class="keyword">false</span>&nbsp;<span class="keyword">true</span>&nbsp;&nbsp;<span class="keyword">false</span>&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_flag&nbsp;<span class="keyword">true</span>&nbsp;&nbsp;<span class="keyword">true</span>&nbsp;&nbsp;<span class="keyword">true</span>&nbsp;<span class="keyword">false</span>&nbsp;<span class="keyword">false</span>&nbsp;<span class="keyword">false</span>&nbsp;...&nbsp;</code></pre>
    Thus <code class="code">clock <span class="keyword">and</span> init_flag</code> is true when and only when clock ticks
    for the first time. The <code class="code">init_flag</code> flag will be passed down to
    the called node as its init flag. It is mandatory for invariant
    lifting: two state invariants are guarded by <code class="code">init_flag <span class="keyword">or</span> inv</code>,
    and substitution takes care of rewriting that as
    <code class="code">clock =&gt; init_flag <span class="keyword">or</span> inv</code>.
<p>

    The initial state constraint of the called node is a conjunction of
    formulas representing the following:<ul>
<li>the <code class="code">init_flag</code> flag is true (see paragraph above):
    <pre class="codepre"><code class="code">init_flag&nbsp;=&nbsp;<span class="keyword">true</span></code></pre></li>
<li>the shadow input variables take the values of the actual input
      variables if the activation condition is true:
    <pre class="codepre"><code class="code">clock&nbsp;=&gt;&nbsp;shadow_input&nbsp;=&nbsp;actual_input</code></pre></li>
<li>the initial state predicate of the called node with the
      parameters as above, except for the input variables that are
      replaced by the shadow input variables:
    <pre class="codepre"><code class="code">clock&nbsp;=&gt;&nbsp;init(init_flag,args)</code></pre></li>
<li>if the activation condition is false then the outputs are
      constrained to their default values:
    <pre class="codepre"><code class="code">not&nbsp;clock&nbsp;=&gt;&nbsp;out&nbsp;=&nbsp;default</code></pre></li>
</ul>

    The transition relation of the called node is a conjunction of
    formulas representing the following facts:
<p>
<ul>
<li>the <code class="code">init_flag</code> flag is true in the current state iff it was
      true in the previous instant and the activation condition was
      false in the previous instant:
    <pre class="codepre"><code class="code">init_flag'&nbsp;=&nbsp;init_flag&nbsp;<span class="keyword">and</span>&nbsp;not&nbsp;clock&nbsp;</code></pre></li>
</ul>
<ul>
<li>the shadow input variables in the next state take the values of
      the actual input variables if the activation condition is true:
    <pre class="codepre"><code class="code">clock'&nbsp;=&gt;&nbsp;shadow_input'&nbsp;=&nbsp;actual_input'</code></pre>
      and their previous values if the activation condition is false.
      More generally, all the arguments of the subnode init/trans stay
      the same:
    <pre class="codepre"><code class="code">not&nbsp;clock'&nbsp;=&gt;&nbsp;(args'&nbsp;=&nbsp;args)</code></pre></li>
</ul>
<ul>
<li>the initial state predicate of the called node with the
      parameters as above, except for the input variables that are
      replaced by the shadow input variables, if the activation
      condition is true in the next step and the <code class="code">init_flag</code> flag is
      true in the next step:
    <pre class="codepre"><code class="code">(clock'&nbsp;<span class="keyword">and</span>&nbsp;init_flag')&nbsp;=&gt;&nbsp;init(init_flag',args')</code></pre></li>
</ul>
<ul>
<li>the transition relation predicate of the called node with the
      parameters as above, except for the input variables that are
      replaced by the shadow input variables, if the activation
      condition is true and the <code class="code">init_flag</code> flag is false in the next
      step.
    <pre class="codepre"><code class="code">(clock'&nbsp;<span class="keyword">and</span>&nbsp;not&nbsp;init_flag')&nbsp;=&gt;&nbsp;trans(init_flag',args',init_flag,args)</code></pre></li>
</ul>
<br>
<b>Author(s):</b> Christoph Sticksel, Adrien Champion<br>
</div>
<hr width="100%">

<pre><span id="VALtrans_sys_of_nodes"><span class="keyword">val</span> trans_sys_of_nodes</span> : <code class="type">?preserve_sig:bool -><br>       <a href="LustreNode.html#TYPEt">LustreNode.t</a> <a href="SubSystem.html#TYPEt">SubSystem.t</a> -><br>       LustreGlobals.t -><br>       <a href="Analysis.html#TYPEparam">Analysis.param</a> -> <a href="TransSys.html#TYPEt">TransSys.t</a> * <a href="LustreNode.html#TYPEt">LustreNode.t</a> <a href="SubSystem.html#TYPEt">SubSystem.t</a> * LustreGlobals.t</code></pre></body></html>