<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="include/style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="LustreExpr.html">
<link rel="next" href="LustreContext.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Log" rel="Chapter" href="Log.html">
<link title="Event" rel="Chapter" href="Event.html">
<link title="Strategy" rel="Chapter" href="Strategy.html">
<link title="Analysis" rel="Chapter" href="Analysis.html">
<link title="Flags" rel="Chapter" href="Flags.html">
<link title="InvarManager" rel="Chapter" href="InvarManager.html">
<link title="Kind2" rel="Chapter" href="Kind2.html">
<link title="InputSystem" rel="Chapter" href="InputSystem.html">
<link title="Eval" rel="Chapter" href="Eval.html">
<link title="Ident" rel="Chapter" href="Ident.html">
<link title="Ltree" rel="Chapter" href="Ltree.html">
<link title="Model" rel="Chapter" href="Model.html">
<link title="Scope" rel="Chapter" href="Scope.html">
<link title="Simplify" rel="Chapter" href="Simplify.html">
<link title="StateVar" rel="Chapter" href="StateVar.html">
<link title="Symbol" rel="Chapter" href="Symbol.html">
<link title="TermAttr" rel="Chapter" href="TermAttr.html">
<link title="Term" rel="Chapter" href="Term.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="UfSymbol" rel="Chapter" href="UfSymbol.html">
<link title="Var" rel="Chapter" href="Var.html">
<link title="Property" rel="Chapter" href="Property.html">
<link title="SubSystem" rel="Chapter" href="SubSystem.html">
<link title="TransSys" rel="Chapter" href="TransSys.html">
<link title="Actlit" rel="Chapter" href="Actlit.html">
<link title="Base" rel="Chapter" href="Base.html">
<link title="Compress" rel="Chapter" href="Compress.html">
<link title="Step" rel="Chapter" href="Step.html">
<link title="Clause" rel="Chapter" href="Clause.html">
<link title="CooperQE" rel="Chapter" href="CooperQE.html">
<link title="Extract" rel="Chapter" href="Extract.html">
<link title="IC3" rel="Chapter" href="IC3.html">
<link title="Poly" rel="Chapter" href="Poly.html">
<link title="Presburger" rel="Chapter" href="Presburger.html">
<link title="QE" rel="Chapter" href="QE.html">
<link title="InvGenMiner" rel="Chapter" href="InvGenMiner.html">
<link title="InvGenDomain" rel="Chapter" href="InvGenDomain.html">
<link title="InvGenGraph" rel="Chapter" href="InvGenGraph.html">
<link title="InvGen" rel="Chapter" href="InvGen.html">
<link title="LockStepDriver" rel="Chapter" href="LockStepDriver.html">
<link title="InputParser" rel="Chapter" href="InputParser.html">
<link title="Interpreter" rel="Chapter" href="Interpreter.html">
<link title="LustreLexer" rel="Chapter" href="LustreLexer.html">
<link title="LustreParser" rel="Chapter" href="LustreParser.html">
<link title="LustreAst" rel="Chapter" href="LustreAst.html">
<link title="LustreIdent" rel="Chapter" href="LustreIdent.html">
<link title="LustreIndex" rel="Chapter" href="LustreIndex.html">
<link title="LustreExpr" rel="Chapter" href="LustreExpr.html">
<link title="LustreNode" rel="Chapter" href="LustreNode.html">
<link title="LustreContext" rel="Chapter" href="LustreContext.html">
<link title="LustreContract" rel="Chapter" href="LustreContract.html">
<link title="LustreDeclarations" rel="Chapter" href="LustreDeclarations.html">
<link title="LustreSimplify" rel="Chapter" href="LustreSimplify.html">
<link title="LustreSlicing" rel="Chapter" href="LustreSlicing.html">
<link title="LustreTransSys" rel="Chapter" href="LustreTransSys.html">
<link title="LustreInput" rel="Chapter" href="LustreInput.html">
<link title="LustrePath" rel="Chapter" href="LustrePath.html">
<link title="NativeInput" rel="Chapter" href="NativeInput.html">
<link title="Pretty" rel="Chapter" href="Pretty.html">
<link title="SMTExpr" rel="Chapter" href="SMTExpr.html">
<link title="SMTLIBSolver" rel="Chapter" href="SMTLIBSolver.html">
<link title="SMTSolver" rel="Chapter" href="SMTSolver.html">
<link title="SolverDriver" rel="Chapter" href="SolverDriver.html">
<link title="SolverResponse" rel="Chapter" href="SolverResponse.html">
<link title="SolverSig" rel="Chapter" href="SolverSig.html">
<link title="CVC4Driver" rel="Chapter" href="CVC4Driver.html">
<link title="GenericSMTLIBDriver" rel="Chapter" href="GenericSMTLIBDriver.html">
<link title="Z3Driver" rel="Chapter" href="Z3Driver.html">
<link title="Yices2SMT2Driver" rel="Chapter" href="Yices2SMT2Driver.html">
<link title="YicesDriver" rel="Chapter" href="YicesDriver.html">
<link title="YicesLexer" rel="Chapter" href="YicesLexer.html">
<link title="YicesNative" rel="Chapter" href="YicesNative.html">
<link title="YicesResponse" rel="Chapter" href="YicesResponse.html">
<link title="Debug" rel="Chapter" href="Debug.html">
<link title="Decimal" rel="Chapter" href="Decimal.html">
<link title="Hashcons" rel="Chapter" href="Hashcons.html">
<link title="HString" rel="Chapter" href="HString.html">
<link title="HStringSExpr" rel="Chapter" href="HStringSExpr.html">
<link title="Kind2Config" rel="Chapter" href="Kind2Config.html">
<link title="Lib" rel="Chapter" href="Lib.html">
<link title="Messaging" rel="Chapter" href="Messaging.html">
<link title="Numeral" rel="Chapter" href="Numeral.html">
<link title="SExprBase" rel="Chapter" href="SExprBase.html">
<link title="SExprLexer" rel="Chapter" href="SExprLexer.html">
<link title="Stat" rel="Chapter" href="Stat.html">
<link title="TermLib" rel="Chapter" href="TermLib.html">
<link title="Trie" rel="Chapter" href="Trie.html">
<link title="Version" rel="Chapter" href="Version.html">
<link title="LustreToRust" rel="Chapter" href="LustreToRust.html">
<link title="TestgenDF" rel="Chapter" href="TestgenDF.html">
<link title="TestgenIO" rel="Chapter" href="TestgenIO.html">
<link title="TestgenModes" rel="Chapter" href="TestgenModes.html">
<link title="TestgenSolver" rel="Chapter" href="TestgenSolver.html">
<link title="TestgenStrategies" rel="Chapter" href="TestgenStrategies.html">
<link title="TestgenTree" rel="Chapter" href="TestgenTree.html">
<link title="TestgenLib" rel="Chapter" href="TestgenLib.html">
<link title="Certificate" rel="Chapter" href="Certificate.html"><link title="Types" rel="Section" href="#1_Types">
<link title="Pretty-printers" rel="Section" href="#1_Prettyprinters">
<link title="Node Lists" rel="Section" href="#1_NodeLists">
<link title="Iterators" rel="Subsection" href="#2_Iterators">
<link title="Sources" rel="Subsection" href="#2_Sources">
<title>Kind 2 Developer's Documentation : LustreNode</title>
</head>
<body>
<div class="navbar"><a class="pre" href="LustreExpr.html" title="LustreExpr">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="LustreContext.html" title="LustreContext">Next</a>
</div>
<h1>Module <a href="type_LustreNode.html">LustreNode</a></h1>

<pre><span class="keyword">module</span> LustreNode: <code class="code"><span class="keyword">sig</span></code> <a href="LustreNode.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Internal representation of a Lustre node
<p>

    Nodes are normalized for easy translation into a transition
    system, mainly by introducing new variables. 
<p>

    The node equations taken together become a map of state variables
    to expressions. All node calls are factored out with fresh state
    variables as inputs and outputs.
<p>

    The node signature as input and output variables as well as its
    local variables is in <code class="code">inputs</code>, <code class="code">outputs</code> and <code class="code">locals</code>,
    respectively. Local constants are propagated and do not need to be
    stored. The inputs of a node can be extended by constant state
    variables in <code class="code">oracles</code> for the initial value of unguarded pre
    operations.
<p>

    Assertions, properties to prove and contracts as assumptions and
    guarantees are lists of expressions in <code class="code">asserts</code>, <code class="code">props</code>,
    contracts fo into <code class="code">global_contracts</code> and <code class="code">mode_contracts</code>.
<p>

    The flag <code class="code">node_is_main</code> is set if the node has been annotated as
    main, it is not checked if more than one node or no node at all may
    have that annotation.<br>
<b>Author(s):</b> Christoph Sticksel<br>
</div>
<hr width="100%">
<br>
<h1 id="1_Types">Types</h1><br>

<pre><code><span id="TYPEnode_call"><span class="keyword">type</span> <code class="type"></code>node_call</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTnode_call.call_pos">call_pos</span>&nbsp;: <code class="type"><a href="Lib.html#TYPEposition">Lib.position</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Position of node call in input file<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTnode_call.call_node_name">call_node_name</span>&nbsp;: <code class="type"><a href="LustreIdent.html#TYPEt">LustreIdent.t</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Identifier of the called node<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTnode_call.call_clock">call_clock</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Boolean activation condition if any<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTnode_call.call_inputs">call_inputs</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> LustreIndex.t</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Variables for actual input parameters 
<p>

      The keys of the index match those in the <a href="LustreNode.html#TYPEELTt.inputs"><code class="code"><span class="constructor">LustreNode</span>.t.inputs</code></a> field of
      the called node.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTnode_call.call_oracles">call_oracles</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Variables providing non-deterministic inputs
<p>

      The length of the list is equal to the length of the list in
      the <a href="LustreNode.html#TYPEELTt.oracles"><code class="code"><span class="constructor">LustreNode</span>.t.oracles</code></a> field of the called node.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTnode_call.call_outputs">call_outputs</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> LustreIndex.t</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Variables capturing the outputs 
<p>

      The keys of the index match those in the <a href="LustreNode.html#TYPEELTt.outputs"><code class="code"><span class="constructor">LustreNode</span>.t.outputs</code></a> field of the
      called node.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTnode_call.call_defaults">call_defaults</span>&nbsp;: <code class="type"><a href="LustreExpr.html#TYPEt">LustreExpr.t</a> LustreIndex.t option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Expressions for initial return values
<p>

      This value should be <code class="code"><span class="constructor">None</span></code> for node calls on the base clock,
      and <code class="code"><span class="constructor">Some</span> l</code> for node calls with a clock. A node call with a
      clock may only have <code class="code"><span class="constructor">None</span></code> here if it occurs directly under a
      <code class="code">merge</code> operator. 
<p>

      If the option value is not <code class="code"><span class="constructor">None</span></code>, the keys of the index match
      those in the <a href="LustreNode.html#TYPEELTt.outputs"><code class="code"><span class="constructor">LustreNode</span>.t.outputs</code></a> field of the called node.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
A call to a node 
<p>

    Calls are uniquely identified by the position, no two calls may
    share the same position, therefore the <code class="code">call_pos</code> must not be a
    dummy position.<br>
</div>


<pre><code><span id="TYPEfunction_call"><span class="keyword">type</span> <code class="type"></code>function_call</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTfunction_call.call_pos">call_pos</span>&nbsp;: <code class="type"><a href="Lib.html#TYPEposition">Lib.position</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTfunction_call.call_function_name">call_function_name</span>&nbsp;: <code class="type"><a href="LustreIdent.html#TYPEt">LustreIdent.t</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTfunction_call.call_inputs">call_inputs</span>&nbsp;: <code class="type"><a href="LustreExpr.html#TYPEt">LustreExpr.t</a> LustreIndex.t</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTfunction_call.call_outputs">call_outputs</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> LustreIndex.t</code>;</code></td>

</tr></table>
}

<div class="info ">
A call of a function<br>
</div>


<pre><code><span id="TYPEstate_var_source"><span class="keyword">type</span> <code class="type"></code>state_var_source</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstate_var_source.Input"><span class="constructor">Input</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Declared input variable<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstate_var_source.Output"><span class="constructor">Output</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Declared output variable<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstate_var_source.Local"><span class="constructor">Local</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Declared local variable<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstate_var_source.Ghost"><span class="constructor">Ghost</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Declared ghost variable<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTstate_var_source.Oracle"><span class="constructor">Oracle</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Generated non-deterministic input<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
Source of a state variable<br>
</div>


<pre><span id="TYPEcontract"><span class="keyword">type</span> <code class="type"></code>contract</span> = <code class="type"><a href="LustreContract.html#TYPEt">LustreContract.t</a></code> </pre>
<div class="info ">
A contract.<br>
</div>


<pre><code><span id="TYPEbound_or_fixed"><span class="keyword">type</span> <code class="type">'a</code> bound_or_fixed</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbound_or_fixed.Bound"><span class="constructor">Bound</span></span> <span class="keyword">of</span> <code class="type">'a</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Equation is for each value of the index variable
                   between zero and the upper bound<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbound_or_fixed.Fixed"><span class="constructor">Fixed</span></span> <span class="keyword">of</span> <code class="type">'a</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Fixed value for index variable<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
Type of index in an equation for an array<br>
</div>


<pre><span id="TYPEequation"><span class="keyword">type</span> <code class="type"></code>equation</span> = <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> * <a href="LustreExpr.html#TYPEexpr">LustreExpr.expr</a> <a href="LustreNode.html#TYPEbound_or_fixed">bound_or_fixed</a> list * <a href="LustreExpr.html#TYPEt">LustreExpr.t</a></code> </pre>
<div class="info ">
An equation is a triple <code class="code">(state_var, bounds, expr)</code> of the
    expression <code class="code">expr</code> that defines the state variable <code class="code">state_var</code>,
    and a list <code class="code">bounds</code> of indexes. 
<p>

    An array can be defined either only at a given index, or at all
    indexes, when the expression on the right-hand side is interpreted
    as a function of the running variable of the index.<br>
</div>


<pre><code><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.name">name</span>&nbsp;: <code class="type"><a href="LustreIdent.html#TYPEt">LustreIdent.t</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Name of the node<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.instance">instance</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Distinguished constant state variable uniquely identifying the
      node instance<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.init_flag">init_flag</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Distinguished state variable to be true in the first
     instant only<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.inputs">inputs</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> LustreIndex.t</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Input streams defined in the node
<p>

      The inputs are considered as a list with an integer indexes
      corresponding to their position in the formal parameters if
      there is more than one input parameter. If there is only one
      input parameter, the list index is omitted, the index is empty
      if there are no input parameters.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.oracles">oracles</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Oracle inputs added to the node inputs
<p>

      Input streams added to the node to obtain non-deterministic
      values for the initial values of unguarded pre operators. The
      state variables are constant.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.outputs">outputs</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> LustreIndex.t</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Output streams defined in the node
<p>

      The outputs are considered as a list with an integer indexes
      corresponding to their position in the formal parameters.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.locals">locals</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> LustreIndex.t list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Local variables of node
<p>

      The order of the list is irrelevant, we are doing dependency
      analysis and cone of influence reduction later.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.equations">equations</span>&nbsp;: <code class="type"><a href="LustreNode.html#TYPEequation">equation</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Equations for local and output variables<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.calls">calls</span>&nbsp;: <code class="type"><a href="LustreNode.html#TYPEnode_call">node_call</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Node calls inside the node<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.function_calls">function_calls</span>&nbsp;: <code class="type"><a href="LustreNode.html#TYPEfunction_call">function_call</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Function calls in the node<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.asserts">asserts</span>&nbsp;: <code class="type"><a href="LustreExpr.html#TYPEt">LustreExpr.t</a> list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Assertions of node<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.props">props</span>&nbsp;: <code class="type">(<a href="StateVar.html#TYPEt">StateVar.t</a> * string * <a href="Property.html#TYPEprop_source">Property.prop_source</a>) list</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Proof obligations for the node<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.contract">contract</span>&nbsp;: <code class="type"><a href="LustreNode.html#TYPEcontract">contract</a> option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Contract.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.is_main">is_main</span>&nbsp;: <code class="type">bool</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Flag node as the top node<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.state_var_source_map">state_var_source_map</span>&nbsp;: <code class="type"><a href="LustreNode.html#TYPEstate_var_source">state_var_source</a> StateVar.StateVarMap.t</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Map from a state variable to its source 
<p>

      Variables that were introduced to abstract expressions do not
      have a source.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.oracle_state_var_map">oracle_state_var_map</span>&nbsp;: <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> StateVar.StateVarHashtbl.t</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Map from state variables to state variables providing a
      non-deterministic pre-initial value<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt.state_var_expr_map">state_var_expr_map</span>&nbsp;: <code class="type"><a href="LustreExpr.html#TYPEt">LustreExpr.t</a> StateVar.StateVarHashtbl.t</code>;</code></td>

</tr></table>
}

<div class="info ">
A Lustre node
<p>

    Every state variable occurs exactly once in <a href="LustreNode.html#TYPEELTt.inputs"><code class="code"><span class="constructor">LustreNode</span>.t.inputs</code></a>,
    <a href="LustreNode.html#TYPEELTt.outputs"><code class="code"><span class="constructor">LustreNode</span>.t.outputs</code></a>, and <a href="LustreNode.html#TYPEELTt.oracles"><code class="code"><span class="constructor">LustreNode</span>.t.oracles</code></a>, and at most once on the left-hand
    side of <a href="LustreNode.html#TYPEELTt.calls"><code class="code"><span class="constructor">LustreNode</span>.t.calls</code></a>. If the state variable is of array type, there
    may be more than one occurrence of it in <a href="LustreNode.html#TYPEELTt.equations"><code class="code"><span class="constructor">LustreNode</span>.t.equations</code></a>, each
    defining the index variable at a different value with
    <a href="LustreNode.html#TYPEELTbound_or_fixed.Fixed"><code class="code"><span class="constructor">LustreNode</span>.bound_or_fixed.<span class="constructor">Fixed</span></code></a>. If the state variable is not an array, or
    all its bounds are <a href="LustreNode.html#TYPEELTbound_or_fixed.Bound"><code class="code"><span class="constructor">LustreNode</span>.bound_or_fixed.<span class="constructor">Bound</span></code></a>, then it occurs at most
    once on the left-hand side of <a href="LustreNode.html#TYPEELTt.equations"><code class="code"><span class="constructor">LustreNode</span>.t.equations</code></a>.<br>
</div>


<pre><span id="TYPEstate_var_instance"><span class="keyword">type</span> <code class="type"></code>state_var_instance</span> = <code class="type"><a href="Lib.html#TYPEposition">Lib.position</a> * <a href="LustreIdent.html#TYPEt">LustreIdent.t</a> * <a href="StateVar.html#TYPEt">StateVar.t</a></code> </pre>
<div class="info ">
Instance of state vars as streams with their position<br>
</div>


<pre><span id="VALempty_node"><span class="keyword">val</span> empty_node</span> : <code class="type"><a href="LustreIdent.html#TYPEt">LustreIdent.t</a> -> <a href="LustreNode.html#TYPEt">t</a></code></pre><div class="info ">
Return a node of the given name without inputs, outputs, oracles,
    equations, etc. Create a state variable for the <a href="LustreNode.html#TYPEELTt.instance"><code class="code"><span class="constructor">LustreNode</span>.t.instance</code></a> and
    <a href="LustreNode.html#TYPEELTt.init_flag"><code class="code"><span class="constructor">LustreNode</span>.t.init_flag</code></a> fields, and set <a href="LustreNode.html#TYPEELTt.is_main"><code class="code"><span class="constructor">LustreNode</span>.t.is_main</code></a> to false.<br>
</div>
<br>
<h1 id="1_Prettyprinters">Pretty-printers</h1><br>

<pre><span id="VALpp_print_node_equation"><span class="keyword">val</span> pp_print_node_equation</span> : <code class="type">bool -><br>       Format.formatter -><br>       <a href="StateVar.html#TYPEt">StateVar.t</a> * <a href="LustreExpr.html#TYPEexpr">LustreExpr.expr</a> <a href="LustreNode.html#TYPEbound_or_fixed">bound_or_fixed</a> list * <a href="LustreExpr.html#TYPEt">LustreExpr.t</a> -><br>       unit</code></pre><div class="info ">
Pretty-print a node equation in Lustre format 
<p>

    If the flag in the first argument is <code class="code"><span class="keyword">true</span></code>, print identifiers in
    Lustre syntax.<br>
</div>

<pre><span id="VALpp_print_call"><span class="keyword">val</span> pp_print_call</span> : <code class="type">bool -> Format.formatter -> <a href="LustreNode.html#TYPEnode_call">node_call</a> -> unit</code></pre><div class="info ">
Pretty-print a node call in Lustre format 
<p>

    If the flag in the first argument is <code class="code"><span class="keyword">true</span></code>, print identifiers in
    Lustre syntax.<br>
</div>

<pre><span id="VALpp_print_node"><span class="keyword">val</span> pp_print_node</span> : <code class="type">bool -> Format.formatter -> <a href="LustreNode.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Pretty-print a node in Lustre format 
<p>

    If the flag in the first argument is <code class="code"><span class="keyword">true</span></code>, print identifiers in
    Lustre syntax.<br>
</div>

<pre><span id="VALpp_print_node_signature"><span class="keyword">val</span> pp_print_node_signature</span> : <code class="type">Format.formatter -> <a href="LustreNode.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Pretty-prints the signature of a node in Lustre format, WITHOUT NODE
KEYWORD AND NAME. (Used in contract generation.)<br>
</div>

<pre><span id="VALpp_print_node_debug"><span class="keyword">val</span> pp_print_node_debug</span> : <code class="type">Format.formatter -> <a href="LustreNode.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Pretty-print the node as a record with all information<br>
</div>
<br>
<h1 id="1_NodeLists">Node Lists</h1><br>

<pre><span id="VALnode_of_name"><span class="keyword">val</span> node_of_name</span> : <code class="type"><a href="LustreIdent.html#TYPEt">LustreIdent.t</a> -> <a href="LustreNode.html#TYPEt">t</a> list -> <a href="LustreNode.html#TYPEt">t</a></code></pre><div class="info ">
Return the node of the given name from a list of nodes<br>
</div>

<pre><span id="VALexists_node_of_name"><span class="keyword">val</span> exists_node_of_name</span> : <code class="type"><a href="LustreIdent.html#TYPEt">LustreIdent.t</a> -> <a href="LustreNode.html#TYPEt">t</a> list -> bool</code></pre><div class="info ">
Return true if a node of the given name exists in the a list of nodes<br>
</div>

<pre><span id="VALfind_main"><span class="keyword">val</span> find_main</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> list -> <a href="LustreIdent.html#TYPEt">LustreIdent.t</a></code></pre><div class="info ">
Return name of the first node annotated with --%MAIN.  Raise
    <code class="code"><span class="constructor">Not_found</span></code> if no node has a --%MAIN annotation or <code class="code"><span class="constructor">Failure</span>
    <span class="string">"find_main"</span></code> if more than one node has a --%MAIN annotation.<br>
</div>

<pre><span id="VALident_of_top"><span class="keyword">val</span> ident_of_top</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> list -> <a href="LustreIdent.html#TYPEt">LustreIdent.t</a></code></pre><div class="info ">
Return the identifier of the top node
<p>

    Fail with <code class="code"><span class="constructor">Invalid_argument</span> <span class="string">"ident_of_top"</span></code> if list of nodes is empty<br>
</div>

<pre><span id="VALhas_contract"><span class="keyword">val</span> has_contract</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return true if the node has a global or at least one mode
    contract<br>
</div>

<pre><span id="VALhas_impl"><span class="keyword">val</span> has_impl</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return false if the body of the node is empty, that is, all
    equations are ghost and there are no assertions<br>
</div>

<pre><span id="VALsubsystem_of_nodes"><span class="keyword">val</span> subsystem_of_nodes</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> list -> <a href="LustreNode.html#TYPEt">t</a> <a href="SubSystem.html#TYPEt">SubSystem.t</a></code></pre><div class="info ">
Return a tree-like subsystem hierarchy from a flat list of nodes,
    where the top node is at the head of the list.<br>
</div>

<pre><span id="VALnodes_of_subsystem"><span class="keyword">val</span> nodes_of_subsystem</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> <a href="SubSystem.html#TYPEt">SubSystem.t</a> -> <a href="LustreNode.html#TYPEt">t</a> list</code></pre><div class="info ">
Return list of topologically ordered list of nodes from subsystem.
    The top node is the head of the list.<br>
</div>

<pre><span id="VALstateful_vars_of_node"><span class="keyword">val</span> stateful_vars_of_node</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> StateVar.StateVarSet.t</code></pre><div class="info ">
Return all stateful variables from expressions in a node<br>
</div>

<pre><span id="VALname_of_node"><span class="keyword">val</span> name_of_node</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="LustreIdent.html#TYPEt">LustreIdent.t</a></code></pre><div class="info ">
Return the name of the node<br>
</div>

<pre><span id="VALordered_equations_of_node"><span class="keyword">val</span> ordered_equations_of_node</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> list -> bool -> <a href="LustreNode.html#TYPEequation">equation</a> list</code></pre><div class="info ">
<code class="code">ordered_equations_of_node n stateful init</code>
    Returns the equations of <code class="code">n</code>, topologically sorted by their base (step)
    expression if <code class="code">init</code> (<code class="code">not init</code>).<br>
</div>

<pre><span id="VALequation_of_svar"><span class="keyword">val</span> equation_of_svar</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> <a href="LustreNode.html#TYPEequation">equation</a> option</code></pre><div class="info ">
Returns the equation for a state variable if any.<br>
</div>

<pre><span id="VALnode_call_of_svar"><span class="keyword">val</span> node_call_of_svar</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> <a href="LustreNode.html#TYPEnode_call">node_call</a> option</code></pre><div class="info ">
Returns the node call the svar is (one of) the output(s) of, if any.<br>
</div>

<pre><span id="VALfunction_call_of_svar"><span class="keyword">val</span> function_call_of_svar</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> <a href="LustreNode.html#TYPEfunction_call">function_call</a> option</code></pre><div class="info ">
Returns the function call the svar is (one of) the output(s) of, if any.<br>
</div>

<pre><span id="VALscope_of_node"><span class="keyword">val</span> scope_of_node</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="Scope.html#TYPEt">Scope.t</a></code></pre><div class="info ">
Return the scope of the node<br>
</div>
<br>
<h2 id="2_Iterators">Iterators</h2><br>

<pre><span id="VALfold_node_calls_with_trans_sys"><span class="keyword">val</span> fold_node_calls_with_trans_sys</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> list -><br>       (<a href="LustreNode.html#TYPEt">t</a> -><br>        <a href="TransSys.html#TYPEt">TransSys.t</a> -> (<a href="TransSys.html#TYPEt">TransSys.t</a> * <a href="TransSys.html#TYPEinstance">TransSys.instance</a>) list -> 'a list -> 'a) -><br>       <a href="LustreNode.html#TYPEt">t</a> -> <a href="TransSys.html#TYPEt">TransSys.t</a> -> 'a</code></pre><div class="info ">
Fold bottom-up over node calls together with the transition system 
<p>

    <code class="code">fold_node_calls_with_trans_sys l f n t</code> evaluates <code class="code">f m s i a</code> for
    each node call in the node <code class="code">n</code>, including <code class="code">n</code> itself. The list of
    nodes <code class="code">l</code> must at least contain all sub-nodes of <code class="code">n</code>, and <code class="code">n</code>
    itself, the transition system <code class="code">t</code> must at least contain subsystem
    instances for all node calls. Both <code class="code">l</code> and <code class="code">t</code> may contain more
    nodes and subsystems, respectively, only the node calls in <code class="code">n</code> are
    relevant.
<p>

    The function <code class="code">f</code> is evaluated with the node <code class="code">m</code>, its transition
    system <code class="code">s</code>, and the reverse sequence of instantiations <code class="code">i</code> that
    reach the top system <code class="code">t</code>. The last parameter <code class="code">a</code> is the list of
    evaluations of <code class="code">f</code> on the called nodes and subsystems of <code class="code">s</code>. The
    sequence of instantiations <code class="code">i</code> contains at its head a system that
    has <code class="code">s</code> as a direct subsystem, together with the instance
    parameters. For the top system <code class="code">i</code> is the empty list.
<p>

    The systems are presented in topological order such that each
    system is presented to <code class="code">f</code> after all its subsystem instances have
    been presented.<br>
</div>
<br>
<h2 id="2_Sources">Sources</h2><br>
<br>
Every state variable is either defined in a node, or was
    introduced in pre-processing, see <a href="LustreNode.html#TYPEstate_var_source"><code class="code"><span class="constructor">LustreNode</span>.state_var_source</code></a>.
<p>
<ul>
<li><code class="code"><span class="constructor">Input</span></code>, <code class="code"><span class="constructor">Output</span></code> or <code class="code"><span class="constructor">Local</span></code> state variables correspond to input,
    output and local streams defined in a node, respectively. </li>
</ul>
<ul>
<li><code class="code"><span class="constructor">Oracle</span></code> state variables are additional input variables
     introduced to non-deterministivcally give a value to unguarded
     <code class="code">pre</code> expressions, or to unconstrained streams.</li>
</ul>
<ul>
<li>A <code class="code"><span class="constructor">Ghost</span></code> state variables are is a local variable defined in
      a contract.</li>
</ul>
<br>

<pre><span id="VALpp_print_state_var_source"><span class="keyword">val</span> pp_print_state_var_source</span> : <code class="type">Format.formatter -> <a href="LustreNode.html#TYPEstate_var_source">state_var_source</a> -> unit</code></pre><div class="info ">
Pretty-print a source of a state variable<br>
</div>

<pre><span id="VALset_state_var_source"><span class="keyword">val</span> set_state_var_source</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> <a href="LustreNode.html#TYPEstate_var_source">state_var_source</a> -> <a href="LustreNode.html#TYPEt">t</a></code></pre><div class="info ">
Set source of state variable<br>
</div>

<pre><span id="VALget_state_var_source"><span class="keyword">val</span> get_state_var_source</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> <a href="LustreNode.html#TYPEstate_var_source">state_var_source</a></code></pre><div class="info ">
Get source of state variable<br>
</div>

<pre><span id="VALset_state_var_instance"><span class="keyword">val</span> set_state_var_instance</span> : <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> -> <a href="Lib.html#TYPEposition">Lib.position</a> -> <a href="LustreIdent.html#TYPEt">LustreIdent.t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> unit</code></pre><div class="info ">
State variable is identical to a state variable in a node instance<br>
</div>

<pre><span id="VALset_oracle_state_var"><span class="keyword">val</span> set_oracle_state_var</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> unit</code></pre>
<pre><span id="VALget_oracle_state_var_map"><span class="keyword">val</span> get_oracle_state_var_map</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> StateVar.StateVarHashtbl.t</code></pre>
<pre><span id="VALset_state_var_expr"><span class="keyword">val</span> set_state_var_expr</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> <a href="LustreExpr.html#TYPEt">LustreExpr.t</a> -> unit</code></pre>
<pre><span id="VALget_state_var_expr_map"><span class="keyword">val</span> get_state_var_expr_map</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="LustreExpr.html#TYPEt">LustreExpr.t</a> StateVar.StateVarHashtbl.t</code></pre>
<pre><span id="VALget_state_var_instances"><span class="keyword">val</span> get_state_var_instances</span> : <code class="type"><a href="StateVar.html#TYPEt">StateVar.t</a> -> <a href="LustreNode.html#TYPEstate_var_instance">state_var_instance</a> list</code></pre><div class="info ">
get all instances of a state variable<br>
</div>

<pre><span id="VALstate_var_is_visible"><span class="keyword">val</span> state_var_is_visible</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> bool</code></pre><div class="info ">
Return true if the state variable should be visible to the user,
    false if it was created internally
<p>

    Return <code class="code"><span class="keyword">true</span></code> if the source of the state variable is either
    <code class="code"><span class="constructor">Input</span></code>, <code class="code"><span class="constructor">Output</span></code>, or <code class="code"><span class="constructor">Local</span></code>, and <code class="code"><span class="keyword">false</span></code> otherwise.<br>
</div>

<pre><span id="VALstate_var_is_input"><span class="keyword">val</span> state_var_is_input</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> bool</code></pre><div class="info ">
Return true if the state variable is an input<br>
</div>

<pre><span id="VALstate_var_is_output"><span class="keyword">val</span> state_var_is_output</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> bool</code></pre><div class="info ">
Return true if the state variable is an output<br>
</div>

<pre><span id="VALstate_var_is_local"><span class="keyword">val</span> state_var_is_local</span> : <code class="type"><a href="LustreNode.html#TYPEt">t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a> -> bool</code></pre><div class="info ">
Return true if the state variable is a local variable<br>
</div>
</body></html>