<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="include/style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Step.html">
<link rel="next" href="CooperQE.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Unroller" rel="Chapter" href="Unroller.html">
<link title="Log" rel="Chapter" href="Log.html">
<link title="Event" rel="Chapter" href="Event.html">
<link title="Strategy" rel="Chapter" href="Strategy.html">
<link title="Analysis" rel="Chapter" href="Analysis.html">
<link title="Flags" rel="Chapter" href="Flags.html">
<link title="InvarManager" rel="Chapter" href="InvarManager.html">
<link title="Kind2" rel="Chapter" href="Kind2.html">
<link title="Kind2Flow" rel="Chapter" href="Kind2Flow.html">
<link title="PostAnalysis" rel="Chapter" href="PostAnalysis.html">
<link title="InputSystem" rel="Chapter" href="InputSystem.html">
<link title="Eval" rel="Chapter" href="Eval.html">
<link title="Ident" rel="Chapter" href="Ident.html">
<link title="Ltree" rel="Chapter" href="Ltree.html">
<link title="Model" rel="Chapter" href="Model.html">
<link title="Scope" rel="Chapter" href="Scope.html">
<link title="Simplify" rel="Chapter" href="Simplify.html">
<link title="StateVar" rel="Chapter" href="StateVar.html">
<link title="Symbol" rel="Chapter" href="Symbol.html">
<link title="TermAttr" rel="Chapter" href="TermAttr.html">
<link title="Term" rel="Chapter" href="Term.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="UfSymbol" rel="Chapter" href="UfSymbol.html">
<link title="Var" rel="Chapter" href="Var.html">
<link title="Property" rel="Chapter" href="Property.html">
<link title="SubSystem" rel="Chapter" href="SubSystem.html">
<link title="TransSys" rel="Chapter" href="TransSys.html">
<link title="Actlit" rel="Chapter" href="Actlit.html">
<link title="Base" rel="Chapter" href="Base.html">
<link title="Compress" rel="Chapter" href="Compress.html">
<link title="Step" rel="Chapter" href="Step.html">
<link title="Clause" rel="Chapter" href="Clause.html">
<link title="CooperQE" rel="Chapter" href="CooperQE.html">
<link title="Extract" rel="Chapter" href="Extract.html">
<link title="IC3" rel="Chapter" href="IC3.html">
<link title="Poly" rel="Chapter" href="Poly.html">
<link title="Presburger" rel="Chapter" href="Presburger.html">
<link title="QE" rel="Chapter" href="QE.html">
<link title="InvGenMiner" rel="Chapter" href="InvGenMiner.html">
<link title="InvGenDomain" rel="Chapter" href="InvGenDomain.html">
<link title="InvGenGraph" rel="Chapter" href="InvGenGraph.html">
<link title="InvGen" rel="Chapter" href="InvGen.html">
<link title="LockStepDriver" rel="Chapter" href="LockStepDriver.html">
<link title="InputParser" rel="Chapter" href="InputParser.html">
<link title="Interpreter" rel="Chapter" href="Interpreter.html">
<link title="LustreLexer" rel="Chapter" href="LustreLexer.html">
<link title="LustreParser" rel="Chapter" href="LustreParser.html">
<link title="LustreAst" rel="Chapter" href="LustreAst.html">
<link title="LustreIdent" rel="Chapter" href="LustreIdent.html">
<link title="LustreIndex" rel="Chapter" href="LustreIndex.html">
<link title="LustreExpr" rel="Chapter" href="LustreExpr.html">
<link title="LustreNode" rel="Chapter" href="LustreNode.html">
<link title="LustreContext" rel="Chapter" href="LustreContext.html">
<link title="LustreContract" rel="Chapter" href="LustreContract.html">
<link title="LustreDeclarations" rel="Chapter" href="LustreDeclarations.html">
<link title="LustreSimplify" rel="Chapter" href="LustreSimplify.html">
<link title="LustreSlicing" rel="Chapter" href="LustreSlicing.html">
<link title="LustreTransSys" rel="Chapter" href="LustreTransSys.html">
<link title="LustreInput" rel="Chapter" href="LustreInput.html">
<link title="LustrePath" rel="Chapter" href="LustrePath.html">
<link title="NativeInput" rel="Chapter" href="NativeInput.html">
<link title="Pretty" rel="Chapter" href="Pretty.html">
<link title="SMTExpr" rel="Chapter" href="SMTExpr.html">
<link title="SMTLIBSolver" rel="Chapter" href="SMTLIBSolver.html">
<link title="SMTSolver" rel="Chapter" href="SMTSolver.html">
<link title="SolverDriver" rel="Chapter" href="SolverDriver.html">
<link title="SolverResponse" rel="Chapter" href="SolverResponse.html">
<link title="SolverSig" rel="Chapter" href="SolverSig.html">
<link title="CVC4Driver" rel="Chapter" href="CVC4Driver.html">
<link title="GenericSMTLIBDriver" rel="Chapter" href="GenericSMTLIBDriver.html">
<link title="Z3Driver" rel="Chapter" href="Z3Driver.html">
<link title="Yices2SMT2Driver" rel="Chapter" href="Yices2SMT2Driver.html">
<link title="YicesDriver" rel="Chapter" href="YicesDriver.html">
<link title="YicesLexer" rel="Chapter" href="YicesLexer.html">
<link title="YicesNative" rel="Chapter" href="YicesNative.html">
<link title="YicesResponse" rel="Chapter" href="YicesResponse.html">
<link title="Debug" rel="Chapter" href="Debug.html">
<link title="Decimal" rel="Chapter" href="Decimal.html">
<link title="Hashcons" rel="Chapter" href="Hashcons.html">
<link title="HString" rel="Chapter" href="HString.html">
<link title="HStringSExpr" rel="Chapter" href="HStringSExpr.html">
<link title="Kind2Config" rel="Chapter" href="Kind2Config.html">
<link title="Lib" rel="Chapter" href="Lib.html">
<link title="Res" rel="Chapter" href="Res.html">
<link title="Messaging" rel="Chapter" href="Messaging.html">
<link title="Numeral" rel="Chapter" href="Numeral.html">
<link title="SExprBase" rel="Chapter" href="SExprBase.html">
<link title="SExprLexer" rel="Chapter" href="SExprLexer.html">
<link title="Stat" rel="Chapter" href="Stat.html">
<link title="TermLib" rel="Chapter" href="TermLib.html">
<link title="Trie" rel="Chapter" href="Trie.html">
<link title="Version" rel="Chapter" href="Version.html">
<link title="LustreToRust" rel="Chapter" href="LustreToRust.html">
<link title="TestgenDF" rel="Chapter" href="TestgenDF.html">
<link title="TestgenIO" rel="Chapter" href="TestgenIO.html">
<link title="TestgenModes" rel="Chapter" href="TestgenModes.html">
<link title="TestgenSolver" rel="Chapter" href="TestgenSolver.html">
<link title="TestgenStrategies" rel="Chapter" href="TestgenStrategies.html">
<link title="TestgenTree" rel="Chapter" href="TestgenTree.html">
<link title="TestgenLib" rel="Chapter" href="TestgenLib.html">
<link title="Certificate" rel="Chapter" href="Certificate.html"><link title="Clauses" rel="Section" href="#1_Clauses">
<link title="Activation Literals" rel="Section" href="#1_ActivationLiterals">
<link title="Property sets" rel="Section" href="#1_Propertysets">
<link title="Frames" rel="Section" href="#1_Frames">
<link title="Activation literals" rel="Section" href="#1_Activationliterals">
<title>Kind 2 Developer's Documentation : Clause</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Step.html" title="Step">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="CooperQE.html" title="CooperQE">Next</a>
</div>
<h1>Module <a href="type_Clause.html">Clause</a></h1>

<pre><span class="keyword">module</span> Clause: <code class="code"><span class="keyword">sig</span></code> <a href="Clause.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Clause, properties and activation literals for IC3<br>
<b>Author(s):</b> Christoph Sticksel<br>
</div>
<hr width="100%">

<pre><code><span id="TYPEsource"><span class="keyword">type</span> <code class="type"></code>source</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsource.PropSet"><span class="constructor">PropSet</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Clause is a pseudo clause for property set<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsource.BlockFrontier"><span class="constructor">BlockFrontier</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Negation of clause reaches a state outside the property in one step<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsource.BlockRec"><span class="constructor">BlockRec</span></span> <span class="keyword">of</span> <code class="type"><a href="Clause.html#TYPEt">t</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Negtion of clause reaches a state outside the
                      negation of the clause to block<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsource.IndGen"><span class="constructor">IndGen</span></span> <span class="keyword">of</span> <code class="type"><a href="Clause.html#TYPEt">t</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Clause is an inductive generalization of the clause<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsource.CopyFwdProp"><span class="constructor">CopyFwdProp</span></span> <span class="keyword">of</span> <code class="type"><a href="Clause.html#TYPEt">t</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Clause is a copy of the clause from forward propagation<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsource.CopyBlockProp"><span class="constructor">CopyBlockProp</span></span> <span class="keyword">of</span> <code class="type"><a href="Clause.html#TYPEt">t</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Clause is a copy of the clause from blocking in future frames<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsource.Copy"><span class="constructor">Copy</span></span> <span class="keyword">of</span> <code class="type"><a href="Clause.html#TYPEt">t</a></code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Clause is a copy of the clause for another reason<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
Origin of clause<br>
</div>


<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> </pre>
<div class="info ">
Clause<br>
</div>


<pre><span class="keyword">module</span> <a href="Clause.ClauseTrie.html">ClauseTrie</a>: <code class="type"><a href="Trie.S.html">Trie.S</a></code><code class="type">  with type key = <a href="Term.html">Term</a>.t list</code></pre><div class="info">
A trie of literals
</div>
<br>
<h1 id="1_Clauses">Clauses</h1><br>
<br>
For every clause <code class="code"><span class="constructor">C</span>&nbsp;=&nbsp;{<span class="constructor">L1</span>,&nbsp;...,&nbsp;<span class="constructor">Ln</span>}</code> two activation literals <code class="code">p0</code>
    and <code class="code">p1</code> are generated per clause, in addition two activation
    literals <code class="code">n0_i</code> and <code class="code">n1_i</code> per literal Li. The following terms are
    then lazily asserted on the first access of the actiation:
<p>

    <pre class="codepre"><code class="code">    p0 =&gt; <span class="constructor">C</span>
    p1 =&gt; <span class="constructor">C'</span>
    n01 =&gt; ~<span class="constructor">L1</span>
    n11 =&gt; ~<span class="constructor">L1'</span>
    ...
    n0n =&gt; ~<span class="constructor">Ln</span>
    n1n =&gt; ~<span class="constructor">Ln'</span>
    </code></pre>
<p>

    where the C' and Li' are the clause and the literals,
    respectively, at the next instant.<br>

<pre><span id="VALmk_clause_of_literals"><span class="keyword">val</span> mk_clause_of_literals</span> : <code class="type"><a href="Clause.html#TYPEsource">source</a> -> <a href="Term.html#TYPEt">Term.t</a> list -> <a href="Clause.html#TYPEt">t</a></code></pre><div class="info ">
Create a clause from a set of literals
<p>

    The activation literals are only created in the Kind 2 term
    database, but nothing is sent to the solver, instead they are only
    made on the first access of the activation literals in
    <a href="Clause.html#VALactlit_p0_of_clause"><code class="code"><span class="constructor">Clause</span>.actlit_p0_of_clause</code></a>, <a href="Clause.html#VALactlit_p1_of_clause"><code class="code"><span class="constructor">Clause</span>.actlit_p1_of_clause</code></a>,
    <a href="Clause.html#VALactlits_n0_of_clause"><code class="code"><span class="constructor">Clause</span>.actlits_n0_of_clause</code></a> and <a href="Clause.html#VALactlits_n1_of_clause"><code class="code"><span class="constructor">Clause</span>.actlits_n1_of_clause</code></a>.<br>
</div>

<pre><span id="VALcopy_clause_block_prop"><span class="keyword">val</span> copy_clause_block_prop</span> : <code class="type"><a href="Clause.html#TYPEt">t</a> -> <a href="Clause.html#TYPEt">t</a></code></pre><div class="info ">
Return a copy of the clause with fresh activation literal<br>
</div>

<pre><span id="VALcopy_clause_fwd_prop"><span class="keyword">val</span> copy_clause_fwd_prop</span> : <code class="type"><a href="Clause.html#TYPEt">t</a> -> <a href="Clause.html#TYPEt">t</a></code></pre>
<pre><span id="VALcopy_clause"><span class="keyword">val</span> copy_clause</span> : <code class="type"><a href="Clause.html#TYPEt">t</a> -> <a href="Clause.html#TYPEt">t</a></code></pre>
<pre><span id="VALid_of_clause"><span class="keyword">val</span> id_of_clause</span> : <code class="type"><a href="Clause.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Return unique identifier of clause<br>
</div>

<pre><span id="VALlength_of_clause"><span class="keyword">val</span> length_of_clause</span> : <code class="type"><a href="Clause.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Return the number of literals in the clause 
<p>

    Since duplicate literals are eliminated, this is not necessarily
    equal to the number of literals given when creating the clause.<br>
</div>

<pre><span id="VALterm_of_clause"><span class="keyword">val</span> term_of_clause</span> : <code class="type"><a href="Clause.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">Term.t</a></code></pre><div class="info ">
Return the conjunction of all literals in the clause<br>
</div>

<pre><span id="VALliterals_of_clause"><span class="keyword">val</span> literals_of_clause</span> : <code class="type"><a href="Clause.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">Term.t</a> list</code></pre><div class="info ">
Return the literals in the clause 
<p>

    Since duplicate literals are eliminated and ordered, this is not
    necessarily equal to the list of literals given when creating the
    clause.<br>
</div>

<pre><span id="VALsource_of_clause"><span class="keyword">val</span> source_of_clause</span> : <code class="type"><a href="Clause.html#TYPEt">t</a> -> <a href="Clause.html#TYPEsource">source</a></code></pre><div class="info ">
Return the source of the clause<br>
</div>
<br>
<h1 id="1_ActivationLiterals">Activation Literals</h1><br>

<pre><span id="VALactlit_p0_of_clause"><span class="keyword">val</span> actlit_p0_of_clause</span> : <code class="type"><a href="SMTSolver.html#TYPEt">SMTSolver.t</a> -> <a href="Clause.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">Term.t</a></code></pre><div class="info ">
Return the activation literal for the positive unprimed clause 
<p>

    Declare the activation literal and assert the term <code class="code">p0&nbsp;=&gt;&nbsp;<span class="constructor">C</span></code> on
    the first access of the activation literal in the given solver
    instance. Fail with <code class="code"><span class="constructor">Invalid_argument</span></code> if <a href="Clause.html#VALdeactivate_clause"><code class="code"><span class="constructor">Clause</span>.deactivate_clause</code></a> has
    been called for the clause in the given solver instance.<br>
</div>

<pre><span id="VALactlit_p1_of_clause"><span class="keyword">val</span> actlit_p1_of_clause</span> : <code class="type"><a href="SMTSolver.html#TYPEt">SMTSolver.t</a> -> <a href="Clause.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">Term.t</a></code></pre><div class="info ">
Return the activation literal for the positive primed clause 
<p>

    Declare the activation literal and assert the term <code class="code">p1&nbsp;=&gt;&nbsp;<span class="constructor">C'</span></code> on
    the first access of the activation literal in the given solver
    instance. Fail with <code class="code"><span class="constructor">Invalid_argument</span></code> if <a href="Clause.html#VALdeactivate_clause"><code class="code"><span class="constructor">Clause</span>.deactivate_clause</code></a> has
    been called for the clause in the given solver instance.<br>
</div>

<pre><span id="VALactlits_n0_of_clause"><span class="keyword">val</span> actlits_n0_of_clause</span> : <code class="type"><a href="SMTSolver.html#TYPEt">SMTSolver.t</a> -> <a href="Clause.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">Term.t</a> list</code></pre><div class="info ">
Return the activation literals for the negated clause literals 
<p>

    Declare the activation literals and assert the terms <code class="code">n0_i&nbsp;=&gt;&nbsp;<span class="constructor">L_i</span></code>
    for each literal <code class="code"><span class="constructor">L_i</span></code> in the clause on the first access of the
    activation literal in the given solver instance. Fail with
    <code class="code"><span class="constructor">Invalid_argument</span></code> if <a href="Clause.html#VALdeactivate_clause"><code class="code"><span class="constructor">Clause</span>.deactivate_clause</code></a> has been called for the
    clause in the given solver instance.<br>
</div>

<pre><span id="VALactlits_n1_of_clause"><span class="keyword">val</span> actlits_n1_of_clause</span> : <code class="type"><a href="SMTSolver.html#TYPEt">SMTSolver.t</a> -> <a href="Clause.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">Term.t</a> list</code></pre><div class="info ">
Return the activation literals for the negated, primed literals
<p>

    Declare the activation literals and assert the terms <code class="code">n1_i&nbsp;=&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="constructor">L_i'</span></code> for each literal <code class="code"><span class="constructor">L_i</span></code> in the clause on the first access of
    the activation literal in the given solver instance. Fail with
    <code class="code"><span class="constructor">Invalid_argument</span></code> if <a href="Clause.html#VALdeactivate_clause"><code class="code"><span class="constructor">Clause</span>.deactivate_clause</code></a> has been called for the
    clause in the given solver instance.<br>
</div>

<pre><span id="VALdeactivate_clause"><span class="keyword">val</span> deactivate_clause</span> : <code class="type"><a href="SMTSolver.html#TYPEt">SMTSolver.t</a> -> <a href="Clause.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Assert the negation of all activation literals of clause in the
    solver instance 
<p>

    The clause is marked as unusable in the solver instance, hence all
    calls to <a href="Clause.html#VALactlit_p0_of_clause"><code class="code"><span class="constructor">Clause</span>.actlit_p0_of_clause</code></a>, <a href="Clause.html#VALactlit_p1_of_clause"><code class="code"><span class="constructor">Clause</span>.actlit_p1_of_clause</code></a>,
    <a href="Clause.html#VALactlits_n0_of_clause"><code class="code"><span class="constructor">Clause</span>.actlits_n0_of_clause</code></a>, <a href="Clause.html#VALactlits_n1_of_clause"><code class="code"><span class="constructor">Clause</span>.actlits_n1_of_clause</code></a> fail.<br>
</div>

<pre><span id="VALundo_ind_gen"><span class="keyword">val</span> undo_ind_gen</span> : <code class="type"><a href="Clause.html#TYPEt">t</a> -> <a href="Clause.html#TYPEt">t</a> option</code></pre><div class="info ">
If the clause is an inductive generalization, return the clause
    before generalization
<p>

    Only return one step of inductive generalization, repeat to obtain
    possible chains of generalizations.<br>
</div>
<br>
<h1 id="1_Propertysets">Property sets</h1><br>

<pre><span id="TYPEprop_set"><span class="keyword">type</span> <code class="type"></code>prop_set</span> </pre>
<div class="info ">
Set of properties<br>
</div>


<pre><span id="VALprop_set_of_props"><span class="keyword">val</span> prop_set_of_props</span> : <code class="type">(string * <a href="Term.html#TYPEt">Term.t</a>) list -> <a href="Clause.html#TYPEprop_set">prop_set</a></code></pre><div class="info ">
Create a property set from a list of named properties 
<p>

    The conjunction of properties is viewed as a single literal of a
    clause, and this clause is asserted with activation literals in
    the given solver instance.<br>
</div>

<pre><span id="VALclause_of_prop_set"><span class="keyword">val</span> clause_of_prop_set</span> : <code class="type"><a href="Clause.html#TYPEprop_set">prop_set</a> -> <a href="Clause.html#TYPEt">t</a></code></pre><div class="info ">
Return the unit clause containing the conjunction of the
    properties as a literals<br>
</div>

<pre><span id="VALterm_of_prop_set"><span class="keyword">val</span> term_of_prop_set</span> : <code class="type"><a href="Clause.html#TYPEprop_set">prop_set</a> -> <a href="Term.html#TYPEt">Term.t</a></code></pre><div class="info ">
Return the conjunction of the properties<br>
</div>

<pre><span id="VALprops_of_prop_set"><span class="keyword">val</span> props_of_prop_set</span> : <code class="type"><a href="Clause.html#TYPEprop_set">prop_set</a> -> (string * <a href="Term.html#TYPEt">Term.t</a>) list</code></pre><div class="info ">
Return the named properties of the property set<br>
</div>

<pre><span id="VALactlit_p0_of_prop_set"><span class="keyword">val</span> actlit_p0_of_prop_set</span> : <code class="type"><a href="SMTSolver.html#TYPEt">SMTSolver.t</a> -> <a href="Clause.html#TYPEprop_set">prop_set</a> -> <a href="Term.html#TYPEt">Term.t</a></code></pre><div class="info ">
Return the activation literal for the positive conjunction of properties<br>
</div>

<pre><span id="VALactlit_p1_of_prop_set"><span class="keyword">val</span> actlit_p1_of_prop_set</span> : <code class="type"><a href="SMTSolver.html#TYPEt">SMTSolver.t</a> -> <a href="Clause.html#TYPEprop_set">prop_set</a> -> <a href="Term.html#TYPEt">Term.t</a></code></pre><div class="info ">
Return the activation literal for the positive primed conjunction
    of properties<br>
</div>

<pre><span id="VALactlits_n0_of_prop_set"><span class="keyword">val</span> actlits_n0_of_prop_set</span> : <code class="type"><a href="SMTSolver.html#TYPEt">SMTSolver.t</a> -> <a href="Clause.html#TYPEprop_set">prop_set</a> -> <a href="Term.html#TYPEt">Term.t</a> list</code></pre><div class="info ">
Return the (singleton list of) activation literals for the negated
    conjunction of properties<br>
</div>

<pre><span id="VALactlits_n1_of_prop_set"><span class="keyword">val</span> actlits_n1_of_prop_set</span> : <code class="type"><a href="SMTSolver.html#TYPEt">SMTSolver.t</a> -> <a href="Clause.html#TYPEprop_set">prop_set</a> -> <a href="Term.html#TYPEt">Term.t</a> list</code></pre><div class="info ">
Return the (singleton list of) activation literals for the negated
    primed conjunction of properties<br>
</div>
<br>
<h1 id="1_Frames">Frames</h1><br>

<pre><span id="VALactlit_of_frame"><span class="keyword">val</span> actlit_of_frame</span> : <code class="type">int -> <a href="Term.html#TYPEt">Term.t</a></code></pre><div class="info ">
Create or return an activation literal for the given frame<br>
</div>

<pre><span id="VALactlit_symbol_of_frame"><span class="keyword">val</span> actlit_symbol_of_frame</span> : <code class="type">int -> <a href="UfSymbol.html#TYPEt">UfSymbol.t</a></code></pre><div class="info ">
Create or return the uninterpreted functoin symbol for the
    activation literal for the given frame<br>
</div>
<br>
<h1 id="1_Activationliterals">Activation literals</h1><br>

<pre><code><span id="TYPEactlit_type"><span class="keyword">type</span> <code class="type"></code>actlit_type</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTactlit_type.Actlit_p0"><span class="constructor">Actlit_p0</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
positive unprimed<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTactlit_type.Actlit_n0"><span class="constructor">Actlit_n0</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
negative unprimed<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTactlit_type.Actlit_p1"><span class="constructor">Actlit_p1</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
positive primed<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTactlit_type.Actlit_n1"><span class="constructor">Actlit_n1</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
negative primed<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
Type of activation literal<br>
</div>


<pre><span id="VALcreate_and_assert_fresh_actlit"><span class="keyword">val</span> create_and_assert_fresh_actlit</span> : <code class="type"><a href="SMTSolver.html#TYPEt">SMTSolver.t</a> -> string -> <a href="Term.html#TYPEt">Term.t</a> -> <a href="Clause.html#TYPEactlit_type">actlit_type</a> -> <a href="Term.html#TYPEt">Term.t</a></code></pre><div class="info ">
Create a fresh activation literal, declare it in the solver, and
    assert a term guarded with it
<p>

    <code class="code">create_and_assert_fresh_actlit&nbsp;s&nbsp;h&nbsp;t&nbsp;a</code> declares a fresh
    uninterpreted Boolean constant in the solver instance <code class="code">s</code>, and
    asserts the term <code class="code">t</code> guarded by this activation literal in the
    same solver instance. The parameter <code class="code">h</code> is a tag used to name the
    constant, together with a counter that is maintained per tag.<br>
</div>
</body></html>