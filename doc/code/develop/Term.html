<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="include/style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="TermAttr.html">
<link rel="next" href="Type.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Log" rel="Chapter" href="Log.html">
<link title="Event" rel="Chapter" href="Event.html">
<link title="Strategy" rel="Chapter" href="Strategy.html">
<link title="Analysis" rel="Chapter" href="Analysis.html">
<link title="Flags" rel="Chapter" href="Flags.html">
<link title="InvarManager" rel="Chapter" href="InvarManager.html">
<link title="Kind2" rel="Chapter" href="Kind2.html">
<link title="InputSystem" rel="Chapter" href="InputSystem.html">
<link title="Eval" rel="Chapter" href="Eval.html">
<link title="Ident" rel="Chapter" href="Ident.html">
<link title="Ltree" rel="Chapter" href="Ltree.html">
<link title="Model" rel="Chapter" href="Model.html">
<link title="Scope" rel="Chapter" href="Scope.html">
<link title="Simplify" rel="Chapter" href="Simplify.html">
<link title="StateVar" rel="Chapter" href="StateVar.html">
<link title="Symbol" rel="Chapter" href="Symbol.html">
<link title="TermAttr" rel="Chapter" href="TermAttr.html">
<link title="Term" rel="Chapter" href="Term.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="UfSymbol" rel="Chapter" href="UfSymbol.html">
<link title="Var" rel="Chapter" href="Var.html">
<link title="Property" rel="Chapter" href="Property.html">
<link title="SubSystem" rel="Chapter" href="SubSystem.html">
<link title="TransSys" rel="Chapter" href="TransSys.html">
<link title="Actlit" rel="Chapter" href="Actlit.html">
<link title="Base" rel="Chapter" href="Base.html">
<link title="Compress" rel="Chapter" href="Compress.html">
<link title="Step" rel="Chapter" href="Step.html">
<link title="Clause" rel="Chapter" href="Clause.html">
<link title="CooperQE" rel="Chapter" href="CooperQE.html">
<link title="Extract" rel="Chapter" href="Extract.html">
<link title="IC3" rel="Chapter" href="IC3.html">
<link title="Poly" rel="Chapter" href="Poly.html">
<link title="Presburger" rel="Chapter" href="Presburger.html">
<link title="QE" rel="Chapter" href="QE.html">
<link title="InvGenMiner" rel="Chapter" href="InvGenMiner.html">
<link title="InvGenDomain" rel="Chapter" href="InvGenDomain.html">
<link title="InvGenGraph" rel="Chapter" href="InvGenGraph.html">
<link title="InvGen" rel="Chapter" href="InvGen.html">
<link title="LockStepDriver" rel="Chapter" href="LockStepDriver.html">
<link title="InputParser" rel="Chapter" href="InputParser.html">
<link title="Interpreter" rel="Chapter" href="Interpreter.html">
<link title="LustreLexer" rel="Chapter" href="LustreLexer.html">
<link title="LustreParser" rel="Chapter" href="LustreParser.html">
<link title="LustreAst" rel="Chapter" href="LustreAst.html">
<link title="LustreIdent" rel="Chapter" href="LustreIdent.html">
<link title="LustreIndex" rel="Chapter" href="LustreIndex.html">
<link title="LustreExpr" rel="Chapter" href="LustreExpr.html">
<link title="LustreNode" rel="Chapter" href="LustreNode.html">
<link title="LustreContext" rel="Chapter" href="LustreContext.html">
<link title="LustreContract" rel="Chapter" href="LustreContract.html">
<link title="LustreDeclarations" rel="Chapter" href="LustreDeclarations.html">
<link title="LustreSimplify" rel="Chapter" href="LustreSimplify.html">
<link title="LustreSlicing" rel="Chapter" href="LustreSlicing.html">
<link title="LustreTransSys" rel="Chapter" href="LustreTransSys.html">
<link title="LustreInput" rel="Chapter" href="LustreInput.html">
<link title="LustrePath" rel="Chapter" href="LustrePath.html">
<link title="NativeInput" rel="Chapter" href="NativeInput.html">
<link title="Pretty" rel="Chapter" href="Pretty.html">
<link title="SMTExpr" rel="Chapter" href="SMTExpr.html">
<link title="SMTLIBSolver" rel="Chapter" href="SMTLIBSolver.html">
<link title="SMTSolver" rel="Chapter" href="SMTSolver.html">
<link title="SolverDriver" rel="Chapter" href="SolverDriver.html">
<link title="SolverResponse" rel="Chapter" href="SolverResponse.html">
<link title="SolverSig" rel="Chapter" href="SolverSig.html">
<link title="CVC4Driver" rel="Chapter" href="CVC4Driver.html">
<link title="GenericSMTLIBDriver" rel="Chapter" href="GenericSMTLIBDriver.html">
<link title="Z3Driver" rel="Chapter" href="Z3Driver.html">
<link title="Yices2SMT2Driver" rel="Chapter" href="Yices2SMT2Driver.html">
<link title="YicesDriver" rel="Chapter" href="YicesDriver.html">
<link title="YicesLexer" rel="Chapter" href="YicesLexer.html">
<link title="YicesNative" rel="Chapter" href="YicesNative.html">
<link title="YicesResponse" rel="Chapter" href="YicesResponse.html">
<link title="Debug" rel="Chapter" href="Debug.html">
<link title="Decimal" rel="Chapter" href="Decimal.html">
<link title="Hashcons" rel="Chapter" href="Hashcons.html">
<link title="HString" rel="Chapter" href="HString.html">
<link title="HStringSExpr" rel="Chapter" href="HStringSExpr.html">
<link title="Kind2Config" rel="Chapter" href="Kind2Config.html">
<link title="Lib" rel="Chapter" href="Lib.html">
<link title="Messaging" rel="Chapter" href="Messaging.html">
<link title="Numeral" rel="Chapter" href="Numeral.html">
<link title="SExprBase" rel="Chapter" href="SExprBase.html">
<link title="SExprLexer" rel="Chapter" href="SExprLexer.html">
<link title="Stat" rel="Chapter" href="Stat.html">
<link title="TermLib" rel="Chapter" href="TermLib.html">
<link title="Trie" rel="Chapter" href="Trie.html">
<link title="Version" rel="Chapter" href="Version.html">
<link title="LustreToRust" rel="Chapter" href="LustreToRust.html">
<link title="TestgenDF" rel="Chapter" href="TestgenDF.html">
<link title="TestgenIO" rel="Chapter" href="TestgenIO.html">
<link title="TestgenModes" rel="Chapter" href="TestgenModes.html">
<link title="TestgenSolver" rel="Chapter" href="TestgenSolver.html">
<link title="TestgenStrategies" rel="Chapter" href="TestgenStrategies.html">
<link title="TestgenTree" rel="Chapter" href="TestgenTree.html">
<link title="TestgenLib" rel="Chapter" href="TestgenLib.html">
<link title="Certificate" rel="Chapter" href="Certificate.html"><link title="Types and hash-consing" rel="Section" href="#1_Typesandhashconsing">
<link title="Hashtables, maps and sets" rel="Section" href="#1_Hashtablesmapsandsets">
<link title="Constructors" rel="Section" href="#1_Constructors">
<link title="Constant terms" rel="Section" href="#1_Constantterms">
<link title="Additional term constructors" rel="Section" href="#1_Additionaltermconstructors">
<link title="Accessor functions" rel="Section" href="#1_Accessorfunctions">
<link title="Pretty-printing" rel="Section" href="#1_Prettyprinting">
<link title="Conversions" rel="Section" href="#1_Conversions">
<link title="Prefix and infix operators for term construction" rel="Subsection" href="#2_Prefixandinfixoperatorsfortermconstruction">
<title>Kind 2 Developer's Documentation : Term</title>
</head>
<body>
<div class="navbar"><a class="pre" href="TermAttr.html" title="TermAttr">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Type.html" title="Type">Next</a>
</div>
<h1>Module <a href="type_Term.html">Term</a></h1>

<pre><span class="keyword">module</span> Term: <code class="code"><span class="keyword">sig</span></code> <a href="Term.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Term representation
<p>

    Terms are hashconsed for maximal sharing, comparison with physical
    equality and to store type information.
<p>

    Terms are lambda trees, see <a href="Ltree.html"><code class="code"><span class="constructor">Ltree</span></code></a>, with symbols of type
    <a href="Symbol.html#TYPEt"><code class="code"><span class="constructor">Symbol</span>.t</code></a>, free variables of type <a href="Var.html#TYPEt"><code class="code"><span class="constructor">Var</span>.t</code></a> and types <a href="Type.html#TYPEt"><code class="code"><span class="constructor">Type</span>.t</code></a>.
<p>

    The type <a href="Term.html#TYPEt"><code class="code"><span class="constructor">Term</span>.t</code></a> is private and cannot be constructed outside
    this module in order to ensure that all equal subterms are
    physically equal for hashconsing.
<p>

    Use the constructor functions like <a href="Term.html#VALmk_true"><code class="code"><span class="constructor">Term</span>.mk_true</code></a>, <a href="Term.html#VALmk_num"><code class="code"><span class="constructor">Term</span>.mk_num</code></a> etc. to
    construct terms. An exception will be raised if an incorrectly
    typed term is constructed.<br>
<b>Author(s):</b> Christoph Sticksel<br>
</div>
<hr width="100%">
<br>
<h1 id="1_Typesandhashconsing">Types and hash-consing</h1><br>

<pre><span class="keyword">module</span> <a href="Term.T.html">T</a>: <code class="type"><a href="Ltree.S.html">Ltree.S</a></code><code class="type"> 
  with type symbol = <a href="Symbol.html">Symbol</a>.t
  and type var = <a href="Var.html">Var</a>.t
  and type sort = <a href="Type.html">Type</a>.t</code></pre>
<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type">T.t</code> </pre>
<div class="info ">
Terms are hashconsed abstract syntax trees<br>
</div>


<pre><span id="TYPElambda"><span class="keyword">type</span> <code class="type"></code>lambda</span> = <code class="type">T.lambda</code> </pre>
<div class="info ">
Terms are hashconsed abstract syntax trees<br>
</div>

<br>
<h1 id="1_Hashtablesmapsandsets">Hashtables, maps and sets</h1><br>

<pre><span id="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Comparison function on terms<br>
</div>

<pre><span id="VALequal"><span class="keyword">val</span> equal</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Equality function on terms<br>
</div>

<pre><span id="VALhash"><span class="keyword">val</span> hash</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Hashing function on terms<br>
</div>

<pre><span id="VALtag"><span class="keyword">val</span> tag</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Unique identifier for terms<br>
</div>

<pre><span class="keyword">module</span> <a href="Term.TermHashtbl.html">TermHashtbl</a>: <code class="type">Hashtbl.S</code><code class="type">  with type key = t</code></pre><div class="info">
Hash table over terms
</div>

<pre><span class="keyword">module</span> <a href="Term.TermSet.html">TermSet</a>: <code class="type">Set.S</code><code class="type">  with type elt = t</code></pre><div class="info">
Set over terms
</div>

<pre><span class="keyword">module</span> <a href="Term.TermMap.html">TermMap</a>: <code class="type">Map.S</code><code class="type">  with type key = t</code></pre><div class="info">
Map over terms
</div>
<br>
<h1 id="1_Constructors">Constructors</h1><br>

<pre><span id="VALmk_term"><span class="keyword">val</span> mk_term</span> : <code class="type">T.t_node -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a hashconsed term<br>
</div>

<pre><span id="VALmk_lambda"><span class="keyword">val</span> mk_lambda</span> : <code class="type"><a href="Var.html#TYPEt">Var.t</a> list -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPElambda">lambda</a></code></pre><div class="info ">
Create a hashconsed lambda expression<br>
</div>

<pre><span id="VALimport"><span class="keyword">val</span> import</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Import a term from a different instance into this hashcons table<br>
</div>

<pre><span id="VALimport_lambda"><span class="keyword">val</span> import_lambda</span> : <code class="type"><a href="Term.html#TYPElambda">lambda</a> -> <a href="Term.html#TYPElambda">lambda</a></code></pre><div class="info ">
Import a term from a different instance into this hashcons table<br>
</div>

<pre><span id="VALis_lambda_identity"><span class="keyword">val</span> is_lambda_identity</span> : <code class="type"><a href="Term.html#TYPElambda">lambda</a> -> bool</code></pre><div class="info ">
Returns true if the lamda expression is the identity, i.e. lambda x.x<br>
</div>

<pre><span id="VALmk_true"><span class="keyword">val</span> mk_true</span> : <code class="type">unit -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create the propositional constant <code class="code"><span class="keyword">true</span></code><br>
</div>

<pre><span id="VALmk_false"><span class="keyword">val</span> mk_false</span> : <code class="type">unit -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create the propositional constant <code class="code"><span class="keyword">false</span></code><br>
</div>

<pre><span id="VALmk_not"><span class="keyword">val</span> mk_not</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an Boolean negation
<p>

    Hint: consider using <a href="Term.html#VALnegate"><code class="code"><span class="constructor">Term</span>.negate</code></a> to avoid double negations<br>
</div>

<pre><span id="VALmk_implies"><span class="keyword">val</span> mk_implies</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a Boolean implication<br>
</div>

<pre><span id="VALmk_and"><span class="keyword">val</span> mk_and</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an Boolean conjunction<br>
</div>

<pre><span id="VALmk_or"><span class="keyword">val</span> mk_or</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an Boolean disjunction<br>
</div>

<pre><span id="VALmk_xor"><span class="keyword">val</span> mk_xor</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an Boolean exclusive disjunction<br>
</div>

<pre><span id="VALmk_eq"><span class="keyword">val</span> mk_eq</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an equality<br>
</div>

<pre><span id="VALmk_distinct"><span class="keyword">val</span> mk_distinct</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an pairwise distinct predicate<br>
</div>

<pre><span id="VALmk_ite"><span class="keyword">val</span> mk_ite</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an if-then-else term<br>
</div>

<pre><span id="VALmk_num"><span class="keyword">val</span> mk_num</span> : <code class="type"><a href="Numeral.html#TYPEt">Numeral.t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an integer numeral<br>
</div>

<pre><span id="VALmk_num_of_int"><span class="keyword">val</span> mk_num_of_int</span> : <code class="type">int -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an integer numeral<br>
</div>

<pre><span id="VALmk_dec"><span class="keyword">val</span> mk_dec</span> : <code class="type"><a href="Decimal.html#TYPEt">Decimal.t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a floating point decimal<br>
</div>

<pre><span id="VALmk_minus"><span class="keyword">val</span> mk_minus</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an integer or real difference<br>
</div>

<pre><span id="VALmk_plus"><span class="keyword">val</span> mk_plus</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an integer or real sum<br>
</div>

<pre><span id="VALmk_times"><span class="keyword">val</span> mk_times</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an integer or real product<br>
</div>

<pre><span id="VALmk_div"><span class="keyword">val</span> mk_div</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a real quotient<br>
</div>

<pre><span id="VALmk_intdiv"><span class="keyword">val</span> mk_intdiv</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an integer quotient<br>
</div>

<pre><span id="VALmk_mod"><span class="keyword">val</span> mk_mod</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an integer modulus<br>
</div>

<pre><span id="VALmk_abs"><span class="keyword">val</span> mk_abs</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an absolute value<br>
</div>

<pre><span id="VALmk_leq"><span class="keyword">val</span> mk_leq</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a less-or-equal predicate<br>
</div>

<pre><span id="VALmk_lt"><span class="keyword">val</span> mk_lt</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a less-than predicate<br>
</div>

<pre><span id="VALmk_geq"><span class="keyword">val</span> mk_geq</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a greater-or-equal predicate<br>
</div>

<pre><span id="VALmk_gt"><span class="keyword">val</span> mk_gt</span> : <code class="type"><a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a greater-than predicate<br>
</div>

<pre><span id="VALmk_to_real"><span class="keyword">val</span> mk_to_real</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a conversion to a real decimal<br>
</div>

<pre><span id="VALmk_to_int"><span class="keyword">val</span> mk_to_int</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a conversion to an integer numeral<br>
</div>

<pre><span id="VALmk_is_int"><span class="keyword">val</span> mk_is_int</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a predicate for coincidence of a real with an integer<br>
</div>

<pre><span id="VALmk_divisible"><span class="keyword">val</span> mk_divisible</span> : <code class="type"><a href="Numeral.html#TYPEt">Numeral.t</a> -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a predicate for divisibility by a constant integer<br>
</div>

<pre><span id="VALmk_select"><span class="keyword">val</span> mk_select</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a predicate for divisibility by a constant integer<br>
</div>

<pre><span id="VALmk_named"><span class="keyword">val</span> mk_named</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> int * <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Uniquely name a term with an integer and return a named term and
    its name<br>
</div>

<pre><span id="VALmk_named_unsafe"><span class="keyword">val</span> mk_named_unsafe</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> string -> int -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Name term with the given integer in a given namespace
<p>

    This is a basic function, the caller has to generate the name, and
    ensure the name is used only once. Use with caution, or better
    only use <a href="Term.html#VALmk_named"><code class="code"><span class="constructor">Term</span>.mk_named</code></a>, which will create a unique name.
<p>

    The namespace <code class="code"><span class="string">"t"</span></code> will be rejected, because this is the
    namespace used by <a href="Term.html#VALmk_named"><code class="code"><span class="constructor">Term</span>.mk_named</code></a>.<br>
</div>

<pre><span id="VALmk_uf"><span class="keyword">val</span> mk_uf</span> : <code class="type"><a href="UfSymbol.html#TYPEt">UfSymbol.t</a> -> <a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create an uninterpreted constant or function<br>
</div>

<pre><span id="VALmk_var"><span class="keyword">val</span> mk_var</span> : <code class="type"><a href="Var.html#TYPEt">Var.t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a symbol to be bound to a term<br>
</div>

<pre><span id="VALmk_let"><span class="keyword">val</span> mk_let</span> : <code class="type">(<a href="Var.html#TYPEt">Var.t</a> * <a href="Term.html#TYPEt">t</a>) list -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a binding of symbols to terms<br>
</div>

<pre><span id="VALmk_exists"><span class="keyword">val</span> mk_exists</span> : <code class="type"><a href="Var.html#TYPEt">Var.t</a> list -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Return a hashconsed existentially quantified term<br>
</div>

<pre><span id="VALmk_forall"><span class="keyword">val</span> mk_forall</span> : <code class="type"><a href="Var.html#TYPEt">Var.t</a> list -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Return a hashconsed universally quantified term<br>
</div>
<br>
<h1 id="1_Constantterms">Constant terms</h1><br>

<pre><span id="VALt_true"><span class="keyword">val</span> t_true</span> : <code class="type"><a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
The propositional constant <code class="code"><span class="keyword">true</span></code><br>
</div>

<pre><span id="VALt_false"><span class="keyword">val</span> t_false</span> : <code class="type"><a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
The propositional constant <code class="code"><span class="keyword">false</span></code><br>
</div>
<br>
<h2 id="2_Prefixandinfixoperatorsfortermconstruction">Prefix and infix operators for term construction</h2><br>

<pre><span class="keyword">module</span> <a href="Term.Abbrev.html">Abbrev</a>: <code class="code"><span class="keyword">sig</span></code> <a href="Term.Abbrev.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><br>
<h1 id="1_Additionaltermconstructors">Additional term constructors</h1><br>

<pre><span id="VALmk_bool"><span class="keyword">val</span> mk_bool</span> : <code class="type">bool -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create the propositional constant <code class="code"><span class="keyword">true</span></code> or <code class="code"><span class="keyword">false</span></code><br>
</div>

<pre><span id="VALmk_const_of_symbol_node"><span class="keyword">val</span> mk_const_of_symbol_node</span> : <code class="type"><a href="Symbol.html#TYPEsymbol">Symbol.symbol</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a constant<br>
</div>

<pre><span id="VALmk_const"><span class="keyword">val</span> mk_const</span> : <code class="type"><a href="Symbol.html#TYPEt">Symbol.t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create constant of a hashconsed symbol<br>
</div>

<pre><span id="VALmk_app_of_symbol_node"><span class="keyword">val</span> mk_app_of_symbol_node</span> : <code class="type"><a href="Symbol.html#TYPEsymbol">Symbol.symbol</a> -> <a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a function application<br>
</div>

<pre><span id="VALmk_app"><span class="keyword">val</span> mk_app</span> : <code class="type"><a href="Symbol.html#TYPEt">Symbol.t</a> -> <a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Create a function application of a hashconsed symbol<br>
</div>

<pre><span id="VALmk_succ"><span class="keyword">val</span> mk_succ</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Increment integer or real term by one<br>
</div>

<pre><span id="VALmk_pred"><span class="keyword">val</span> mk_pred</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Decrement integer or real term by one<br>
</div>

<pre><span id="VALnegate"><span class="keyword">val</span> negate</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Negate term, avoiding double negation<br>
</div>

<pre><span id="VALnegate_simplify"><span class="keyword">val</span> negate_simplify</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Negates a term by modifying the top node if it is a not, true,
    false, or an arithmetic inequality.<br>
</div>

<pre><span id="VALunnegate"><span class="keyword">val</span> unnegate</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Remove top negation from term, otherwise return term unchanged<br>
</div>
<br>
<h1 id="1_Accessorfunctions">Accessor functions</h1><br>

<pre><span id="VALtype_of_term"><span class="keyword">val</span> type_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Type.html#TYPEt">Type.t</a></code></pre><div class="info ">
Return the type of the term<br>
</div>

<pre><span id="VALnode_of_term"><span class="keyword">val</span> node_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> T.t_node</code></pre><div class="info ">
Return the node of the hashconsed term<br>
</div>

<pre><span id="VALdestruct"><span class="keyword">val</span> destruct</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> T.flat</code></pre><div class="info ">
Flatten top node of term<br>
</div>

<pre><span id="VALconstruct"><span class="keyword">val</span> construct</span> : <code class="type">T.flat -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Convert a flat term to a term<br>
</div>

<pre><span id="VALis_atom"><span class="keyword">val</span> is_atom</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return true if the term is a simple Boolean atom, that is, has
    type Boolean and does not contain subterms of type Boolean<br>
</div>

<pre><span id="VALis_negated"><span class="keyword">val</span> is_negated</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return true if the top symbol of the term is a negation<br>
</div>

<pre><span id="VALis_free_var"><span class="keyword">val</span> is_free_var</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return <code class="code"><span class="keyword">true</span></code> if the term is a free variable<br>
</div>

<pre><span id="VALfree_var_of_term"><span class="keyword">val</span> free_var_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Var.html#TYPEt">Var.t</a></code></pre><div class="info ">
Return the variable of a free variable term<br>
</div>

<pre><span id="VALis_bound_var"><span class="keyword">val</span> is_bound_var</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return <code class="code"><span class="keyword">true</span></code> if the term is a bound variable<br>
</div>

<pre><span id="VALis_leaf"><span class="keyword">val</span> is_leaf</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return <code class="code"><span class="keyword">true</span></code> if the term is a leaf symbol<br>
</div>

<pre><span id="VALleaf_of_term"><span class="keyword">val</span> leaf_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Symbol.html#TYPEt">Symbol.t</a></code></pre><div class="info ">
Return the symbol of a leaf term<br>
</div>

<pre><span id="VALis_node"><span class="keyword">val</span> is_node</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return <code class="code"><span class="keyword">true</span></code> if the term is a function application<br>
</div>

<pre><span id="VALnode_symbol_of_term"><span class="keyword">val</span> node_symbol_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Symbol.html#TYPEt">Symbol.t</a></code></pre><div class="info ">
Return the symbol of a function application<br>
</div>

<pre><span id="VALnode_args_of_term"><span class="keyword">val</span> node_args_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a> list</code></pre><div class="info ">
Return the arguments of a function application<br>
</div>

<pre><span id="VALis_let"><span class="keyword">val</span> is_let</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return <code class="code"><span class="keyword">true</span></code> if the term is a let binding<br>
</div>

<pre><span id="VALis_exists"><span class="keyword">val</span> is_exists</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return <code class="code"><span class="keyword">true</span></code> if the term is an existential quantifier<br>
</div>

<pre><span id="VALis_forall"><span class="keyword">val</span> is_forall</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return true if the term is a universal quantifier<br>
</div>

<pre><span id="VALis_named"><span class="keyword">val</span> is_named</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return true if the term is a named term<br>
</div>

<pre><span id="VALterm_of_named"><span class="keyword">val</span> term_of_named</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Return the term of a named term<br>
</div>

<pre><span id="VALname_of_named"><span class="keyword">val</span> name_of_named</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Return the name of a named term<br>
</div>

<pre><span id="VALis_numeral"><span class="keyword">val</span> is_numeral</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return true if the term is an integer constant<br>
</div>

<pre><span id="VALnumeral_of_term"><span class="keyword">val</span> numeral_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Numeral.html#TYPEt">Numeral.t</a></code></pre><div class="info ">
Return integer constant of a term<br>
</div>

<pre><span id="VALis_decimal"><span class="keyword">val</span> is_decimal</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return true if the term is a decimal constant<br>
</div>

<pre><span id="VALdecimal_of_term"><span class="keyword">val</span> decimal_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Decimal.html#TYPEt">Decimal.t</a></code></pre><div class="info ">
Return decimal constant of a term<br>
</div>

<pre><span id="VALis_bool"><span class="keyword">val</span> is_bool</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return true if the term is a Boolean constant<br>
</div>

<pre><span id="VALbool_of_term"><span class="keyword">val</span> bool_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return Boolean constant of a term<br>
</div>

<pre><span id="VALis_select"><span class="keyword">val</span> is_select</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Return true if the term is an application of the select operator<br>
</div>

<pre><span id="VALindexes_and_var_of_select"><span class="keyword">val</span> indexes_and_var_of_select</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Var.html#TYPEt">Var.t</a> * <a href="Term.html#TYPEt">t</a> list</code></pre><div class="info ">
Return the indexes and the array variable of the select operator
<p>

    The array argument of a select is either another select operation
    or a variable. For the expression <code class="code">(select (select <span class="constructor">A</span> j) k)</code> return
    the pair <code class="code"><span class="constructor">A</span></code> and <code class="code">[j; k]</code>.<br>
</div>
<br>
<h1 id="1_Prettyprinting">Pretty-printing</h1><br>

<pre><span id="VALpp_print_term"><span class="keyword">val</span> pp_print_term</span> : <code class="type">Format.formatter -> <a href="Term.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Pretty-print a term<br>
</div>

<pre><span id="VALprint_term"><span class="keyword">val</span> print_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Pretty-print a term to the standard formatter<br>
</div>

<pre><span id="VALstring_of_term"><span class="keyword">val</span> string_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> string</code></pre><div class="info ">
Return a string representation of a term<br>
</div>

<pre><span id="VALpp_print_lambda"><span class="keyword">val</span> pp_print_lambda</span> : <code class="type">Format.formatter -> <a href="Term.html#TYPElambda">lambda</a> -> unit</code></pre><div class="info ">
Pretty-print a lambda abstraction<br>
</div>

<pre><span id="VALprint_lambda"><span class="keyword">val</span> print_lambda</span> : <code class="type"><a href="Term.html#TYPElambda">lambda</a> -> unit</code></pre><div class="info ">
Pretty-print a lambda abstraction to the standard formatter<br>
</div>

<pre><span id="VALstring_of_lambda"><span class="keyword">val</span> string_of_lambda</span> : <code class="type"><a href="Term.html#TYPElambda">lambda</a> -> string</code></pre><div class="info ">
Return a string representation of a lambda abstraction<br>
</div>
<br>
<h1 id="1_Conversions">Conversions</h1><br>

<pre><span id="VALeval_t"><span class="keyword">val</span> eval_t</span> : <code class="type">(T.flat -> 'a list -> 'a) -> <a href="Term.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Evaluate the term bottom-up and right-to-left. The evaluation
    function is called at each node of the term with the the term
    being evaluated, and the list of values computed for the
    subterms. Let bindings are lazily unfolded.<br>
</div>

<pre><span id="VALeval_lambda"><span class="keyword">val</span> eval_lambda</span> : <code class="type"><a href="Term.html#TYPElambda">lambda</a> -> <a href="Term.html#TYPEt">t</a> list -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Beta-evaluate a lambda expression<br>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">(int -> T.t -> T.t) -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Tail-recursive bottom-up right-to-left map on the term
<p>

    Not every subterm is a proper term, since the de Bruijn indexes are
    shifted. Therefore, the function <code class="code">f</code> is called with the number of
    let bindings the subterm is under as first argument, so that the
    indexes can be adjusted in the subterm if necessary.<br>
</div>

<pre><span id="VALmap_state_vars"><span class="keyword">val</span> map_state_vars</span> : <code class="type">(<a href="StateVar.html#TYPEt">StateVar.t</a> -> <a href="StateVar.html#TYPEt">StateVar.t</a>) -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Return a new term with each state variable replaced 
<p>

    <code class="code">map_state_vars t f</code> returns a new term of <code class="code">t</code> with each occurring
    state variable <code class="code">s</code> replaced by the result of the evaluation <code class="code">f s</code>.<br>
</div>

<pre><span id="VALmod_to_divisible"><span class="keyword">val</span> mod_to_divisible</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Convert <code class="code">(= 0 (<span class="keyword">mod</span> t n))</code> to <code class="code">(divisble n t)</code>
<p>

    The term <code class="code">n</code> must be an integer numeral.<br>
</div>

<pre><span id="VALdivisible_to_mod"><span class="keyword">val</span> divisible_to_mod</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Convert <code class="code">(divisble n t)</code> to <code class="code">(= 0 (<span class="keyword">mod</span> t n))</code><br>
</div>

<pre><span id="VALnums_to_pos_nums"><span class="keyword">val</span> nums_to_pos_nums</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Convert negative numerals and decimals to negations of their
    absolute value<br>
</div>

<pre><span id="VALbump_state"><span class="keyword">val</span> bump_state</span> : <code class="type"><a href="Numeral.html#TYPEt">Numeral.t</a> -> <a href="Term.html#TYPEt">t</a> -> <a href="Term.html#TYPEt">t</a></code></pre><div class="info ">
Add to offset of state variable instances
<p>

    Negative values are allowed<br>
</div>

<pre><span id="VALbump_and_apply_k"><span class="keyword">val</span> bump_and_apply_k</span> : <code class="type">(<a href="Term.html#TYPEt">t</a> -> unit) -> <a href="Numeral.html#TYPEt">Numeral.t</a> -> <a href="Term.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Apply function to term for instants 0..k<br>
</div>

<pre><span id="VALstate_vars_of_term"><span class="keyword">val</span> state_vars_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> StateVar.StateVarSet.t</code></pre><div class="info ">
Return the state variables occurring in the term<br>
</div>

<pre><span id="VALvars_of_term"><span class="keyword">val</span> vars_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> Var.VarSet.t</code></pre><div class="info ">
Return the variables occurring in the term<br>
</div>

<pre><span id="VALstate_vars_at_offset_of_term"><span class="keyword">val</span> state_vars_at_offset_of_term</span> : <code class="type"><a href="Numeral.html#TYPEt">Numeral.t</a> -> <a href="Term.html#TYPEt">t</a> -> StateVar.StateVarSet.t</code></pre><div class="info ">
Return the state variables at given offset in term<br>
</div>

<pre><span id="VALvars_at_offset_of_term"><span class="keyword">val</span> vars_at_offset_of_term</span> : <code class="type"><a href="Numeral.html#TYPEt">Numeral.t</a> -> <a href="Term.html#TYPEt">t</a> -> Var.VarSet.t</code></pre><div class="info ">
Return the state variables at given offset in term<br>
</div>

<pre><span id="VALvar_offsets_of_term"><span class="keyword">val</span> var_offsets_of_term</span> : <code class="type"><a href="Term.html#TYPEt">t</a> -> <a href="Numeral.html#TYPEt">Numeral.t</a> option * <a href="Numeral.html#TYPEt">Numeral.t</a> option</code></pre><div class="info ">
Return the minimal and maximal offset of state variable instances
<p>

    Return <code class="code">(<span class="constructor">None</span>, <span class="constructor">None</span>)</code> if there are no state variable instances in
    the term.<br>
</div>

<pre><span id="VALstats"><span class="keyword">val</span> stats</span> : <code class="type">unit -> int * int * int * int * int * int</code></pre></body></html>