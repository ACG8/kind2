<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="include/style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="LustreSimplify.html">
<link rel="next" href="LustreTransSys.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Log" rel="Chapter" href="Log.html">
<link title="Event" rel="Chapter" href="Event.html">
<link title="Strategy" rel="Chapter" href="Strategy.html">
<link title="Analysis" rel="Chapter" href="Analysis.html">
<link title="Flags" rel="Chapter" href="Flags.html">
<link title="InvarManager" rel="Chapter" href="InvarManager.html">
<link title="Kind2" rel="Chapter" href="Kind2.html">
<link title="InputSystem" rel="Chapter" href="InputSystem.html">
<link title="Eval" rel="Chapter" href="Eval.html">
<link title="Ident" rel="Chapter" href="Ident.html">
<link title="Ltree" rel="Chapter" href="Ltree.html">
<link title="Model" rel="Chapter" href="Model.html">
<link title="Scope" rel="Chapter" href="Scope.html">
<link title="Simplify" rel="Chapter" href="Simplify.html">
<link title="StateVar" rel="Chapter" href="StateVar.html">
<link title="Symbol" rel="Chapter" href="Symbol.html">
<link title="TermAttr" rel="Chapter" href="TermAttr.html">
<link title="Term" rel="Chapter" href="Term.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="UfSymbol" rel="Chapter" href="UfSymbol.html">
<link title="Var" rel="Chapter" href="Var.html">
<link title="Property" rel="Chapter" href="Property.html">
<link title="SubSystem" rel="Chapter" href="SubSystem.html">
<link title="TransSys" rel="Chapter" href="TransSys.html">
<link title="Actlit" rel="Chapter" href="Actlit.html">
<link title="Base" rel="Chapter" href="Base.html">
<link title="Compress" rel="Chapter" href="Compress.html">
<link title="Step" rel="Chapter" href="Step.html">
<link title="Clause" rel="Chapter" href="Clause.html">
<link title="CooperQE" rel="Chapter" href="CooperQE.html">
<link title="Extract" rel="Chapter" href="Extract.html">
<link title="IC3" rel="Chapter" href="IC3.html">
<link title="Poly" rel="Chapter" href="Poly.html">
<link title="Presburger" rel="Chapter" href="Presburger.html">
<link title="QE" rel="Chapter" href="QE.html">
<link title="InvGenMiner" rel="Chapter" href="InvGenMiner.html">
<link title="InvGenDomain" rel="Chapter" href="InvGenDomain.html">
<link title="InvGenGraph" rel="Chapter" href="InvGenGraph.html">
<link title="InvGen" rel="Chapter" href="InvGen.html">
<link title="LockStepDriver" rel="Chapter" href="LockStepDriver.html">
<link title="InputParser" rel="Chapter" href="InputParser.html">
<link title="Interpreter" rel="Chapter" href="Interpreter.html">
<link title="LustreLexer" rel="Chapter" href="LustreLexer.html">
<link title="LustreParser" rel="Chapter" href="LustreParser.html">
<link title="LustreAst" rel="Chapter" href="LustreAst.html">
<link title="LustreIdent" rel="Chapter" href="LustreIdent.html">
<link title="LustreIndex" rel="Chapter" href="LustreIndex.html">
<link title="LustreExpr" rel="Chapter" href="LustreExpr.html">
<link title="LustreNode" rel="Chapter" href="LustreNode.html">
<link title="LustreContext" rel="Chapter" href="LustreContext.html">
<link title="LustreContract" rel="Chapter" href="LustreContract.html">
<link title="LustreDeclarations" rel="Chapter" href="LustreDeclarations.html">
<link title="LustreSimplify" rel="Chapter" href="LustreSimplify.html">
<link title="LustreSlicing" rel="Chapter" href="LustreSlicing.html">
<link title="LustreTransSys" rel="Chapter" href="LustreTransSys.html">
<link title="LustreInput" rel="Chapter" href="LustreInput.html">
<link title="LustrePath" rel="Chapter" href="LustrePath.html">
<link title="NativeInput" rel="Chapter" href="NativeInput.html">
<link title="Pretty" rel="Chapter" href="Pretty.html">
<link title="SMTExpr" rel="Chapter" href="SMTExpr.html">
<link title="SMTLIBSolver" rel="Chapter" href="SMTLIBSolver.html">
<link title="SMTSolver" rel="Chapter" href="SMTSolver.html">
<link title="SolverDriver" rel="Chapter" href="SolverDriver.html">
<link title="SolverResponse" rel="Chapter" href="SolverResponse.html">
<link title="SolverSig" rel="Chapter" href="SolverSig.html">
<link title="CVC4Driver" rel="Chapter" href="CVC4Driver.html">
<link title="GenericSMTLIBDriver" rel="Chapter" href="GenericSMTLIBDriver.html">
<link title="Z3Driver" rel="Chapter" href="Z3Driver.html">
<link title="Yices2SMT2Driver" rel="Chapter" href="Yices2SMT2Driver.html">
<link title="YicesDriver" rel="Chapter" href="YicesDriver.html">
<link title="YicesLexer" rel="Chapter" href="YicesLexer.html">
<link title="YicesNative" rel="Chapter" href="YicesNative.html">
<link title="YicesResponse" rel="Chapter" href="YicesResponse.html">
<link title="Debug" rel="Chapter" href="Debug.html">
<link title="Decimal" rel="Chapter" href="Decimal.html">
<link title="Hashcons" rel="Chapter" href="Hashcons.html">
<link title="HString" rel="Chapter" href="HString.html">
<link title="HStringSExpr" rel="Chapter" href="HStringSExpr.html">
<link title="Kind2Config" rel="Chapter" href="Kind2Config.html">
<link title="Lib" rel="Chapter" href="Lib.html">
<link title="Messaging" rel="Chapter" href="Messaging.html">
<link title="Numeral" rel="Chapter" href="Numeral.html">
<link title="SExprBase" rel="Chapter" href="SExprBase.html">
<link title="SExprLexer" rel="Chapter" href="SExprLexer.html">
<link title="Stat" rel="Chapter" href="Stat.html">
<link title="TermLib" rel="Chapter" href="TermLib.html">
<link title="Trie" rel="Chapter" href="Trie.html">
<link title="Version" rel="Chapter" href="Version.html">
<link title="LustreToRust" rel="Chapter" href="LustreToRust.html">
<link title="TestgenDF" rel="Chapter" href="TestgenDF.html">
<link title="TestgenIO" rel="Chapter" href="TestgenIO.html">
<link title="TestgenModes" rel="Chapter" href="TestgenModes.html">
<link title="TestgenSolver" rel="Chapter" href="TestgenSolver.html">
<link title="TestgenStrategies" rel="Chapter" href="TestgenStrategies.html">
<link title="TestgenTree" rel="Chapter" href="TestgenTree.html">
<link title="TestgenLib" rel="Chapter" href="TestgenLib.html">
<link title="Certificate" rel="Chapter" href="Certificate.html"><link title="Dependency order" rel="Section" href="#1_Dependencyorder">
<link title="Cone of influence reduction" rel="Section" href="#1_Coneofinfluencereduction">
<title>Kind 2 Developer's Documentation : LustreSlicing</title>
</head>
<body>
<div class="navbar"><a class="pre" href="LustreSimplify.html" title="LustreSimplify">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="LustreTransSys.html" title="LustreTransSys">Next</a>
</div>
<h1>Module <a href="type_LustreSlicing.html">LustreSlicing</a></h1>

<pre><span class="keyword">module</span> LustreSlicing: <code class="code"><span class="keyword">sig</span></code> <a href="LustreSlicing.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info module top">
Cone of influence reduction and dependency ordering of equations<br>
<b>Author(s):</b> Christoph Sticksel<br>
</div>
<hr width="100%">
<br>
<h1 id="1_Dependencyorder">Dependency order</h1><br>

<pre><span id="VALorder_equations"><span class="keyword">val</span> order_equations</span> : <code class="type">bool -><br>       (<a href="LustreIdent.html#TYPEt">LustreIdent.t</a> *<br>        (<a href="LustreIndex.html#TYPEindex">LustreIndex.index</a> list LustreIndex.t * <a href="LustreIndex.html#TYPEindex">LustreIndex.index</a> list LustreIndex.t))<br>       list -><br>       <a href="LustreNode.html#TYPEt">LustreNode.t</a> -><br>       <a href="LustreNode.html#TYPEequation">LustreNode.equation</a> list * <a href="LustreIndex.html#TYPEindex">LustreIndex.index</a> list LustreIndex.t</code></pre><div class="info ">
Return equations of node in topological order of their dependencies 
<p>

    <code class="code">order_equations i d n</code> takes as input a Lustre node <code class="code">n</code> and an
    association list <code class="code">d</code> of node names to a map from output indexes to
    the list of input indexes the output variable depends on. Return
    the equations of <code class="code">n</code> ordered such that each equation comes after
    the equations defining the variables occurring on its right-hand.
<p>

    Along with the list of equations return a map that for each output
    identified by its position indicates which positions in the inputs
    it depends on. The input parameter <code class="code">d</code> must contain such a map for
    each called node.
<p>

    If the flag <code class="code">i</code> is true, consider the equations for the inital
    state only, otherwise consider the equations for post-initial
    states only. 
<p>

    Fail with a parse error if a variable definition is cyclic, that
    is, the variable on the left-hand side of the equation occurs in
    the definition of a variable on the right-hand side. 
<p>

    For the detection of cycles also consider definitions of called nodes
    by using the map of outputs to their dependent inputs. If in the
    node <pre class="codepre"><code class="code">node&nbsp;<span class="constructor">N</span>&nbsp;(i:&nbsp;t)&nbsp;returns&nbsp;(o:&nbsp;t)</code></pre> the output <code class="code">o</code> depends on
    the input <code class="code">i</code>, then the node call <code class="code"><span class="constructor">N</span>(x)</code> must not occur in the
    definition of <code class="code">x</code>. If the output <code class="code">o</code> does not depend on the input
    <code class="code">i</code>, <code class="code"><span class="constructor">N</span>(x)</code> may occur in the definition of <code class="code">x</code>.
<p>

    In particular, if a node is viewed as its contract only, the
    implemention is omitted and node calls never cause cycles in
    defintions. One could argue that since the implementation is not
    known, the outputs should depend on all inputs, but this might
    trigger spurious cycles. We view this more as a realizability
    issue and we could implement separately a check if a node as
    specified by its contract can be implemented without introducing a
    depency on the inputs.
<p>

    Array typed variables are not considered in the cycle detection,
    and this may lead to actual cycles not rejected. This is
    difficult, because we would need to consider each occurrence of an
    array typed variable together with its indexes. Then we would need
    to compare indexes if a state variable occurs on a path with the
    same index. A syntactic comparison would again miss some cycles,
    and we would need to evaluate the indexes for a precise
    comparison. This is probably too much effort for what it is worth.<br>
</div>
<br>
<h1 id="1_Coneofinfluencereduction">Cone of influence reduction</h1><br>

<pre><span id="VALnode_is_abstract"><span class="keyword">val</span> node_is_abstract</span> : <code class="type"><a href="Analysis.html#TYPEparam">Analysis.param</a> -> <a href="LustreNode.html#TYPEt">LustreNode.t</a> -> bool</code></pre><div class="info ">
Return <code class="code"><span class="keyword">true</span></code> if the node is flagged as abstract in
    <code class="code">abstraction_map</code>. Default to <code class="code"><span class="keyword">false</span></code> if the node is not in the
    map.<br>
</div>

<pre><span id="VALslice_to_abstraction"><span class="keyword">val</span> slice_to_abstraction</span> : <code class="type">?preserve_sig:bool -><br>       <a href="Analysis.html#TYPEparam">Analysis.param</a> -><br>       <a href="LustreNode.html#TYPEt">LustreNode.t</a> <a href="SubSystem.html#TYPEt">SubSystem.t</a> -><br>       LustreGlobals.t -> <a href="LustreNode.html#TYPEt">LustreNode.t</a> <a href="SubSystem.html#TYPEt">SubSystem.t</a> * LustreGlobals.t</code></pre><div class="info ">
Return a node hierarchy reduced to the cone of influence of
    properties and contracts, given a list of which nodes should be
    abstracted. 
<p>

    <code class="code">slice_to_abstraction a s</code> takes the parameters of an analysius,
    which contains an association map <code class="code">m</code> of scopes to a flag that is
    <code class="code"><span class="keyword">true</span></code> if the node of that name is to be abstracted to its
    contract by omitting its implemenation. Return a node hierarchy
    based on <code class="code">s</code>, reduced to the cone of influence of the properties
    and contracts.
<p>

    For each node, start with a copy of the node without equations and
    node calls. Maintain a set of state variables, called the roots of
    the cone of influence, and move all equations and node calls that
    define a root to the copy of the node. Add all state variables as
    new roots that occur on the right-hand side of a moved equation,
    or are an inputs, oracles or the clock of a moved node call. Slice
    called nodes before the calling nodes. If an equation defines a
    record, tuple or array, the equations for each element are kept as
    soon as one of the elements is in the cone of influence.
<p>

    The roots of a node always contain its outputs and the state
    variables occurring in contracts, except for the top node. The top
    node is never called and we can safely change its signature. It
    would be possible to analyze each call of a node to see exactly
    which of its inputs and outputs of are in the cone of influence,
    then modify the signature appropriately, and adjust all calls to
    this modified signature. However, this non-local analyisis is
    probably more complicated and error-prone than it is worth.
<p>

    If a node is sliced to its implementation, add the property state
    variables and all state variables in assertions.
<p>

    State variables in assertions are considered to be roots, because
    they potentially constrain a state variable in the cone of
    influence together with a state variable not in the cone of
    influence. In this case, both state variables are in the cone of
    influence. We may add a better analysis later.<br>
</div>

<pre><span id="VALslice_to_abstraction_and_property"><span class="keyword">val</span> slice_to_abstraction_and_property</span> : <code class="type">?preserve_sig:bool -><br>       <a href="Analysis.html#TYPEparam">Analysis.param</a> -><br>       StateVar.StateVarSet.t -><br>       <a href="LustreNode.html#TYPEt">LustreNode.t</a> <a href="SubSystem.html#TYPEt">SubSystem.t</a> -><br>       LustreGlobals.t -> <a href="LustreNode.html#TYPEt">LustreNode.t</a> <a href="SubSystem.html#TYPEt">SubSystem.t</a> * LustreGlobals.t</code></pre></body></html>