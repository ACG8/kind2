<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="include/style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Ltree.BaseTypes.html">
<link rel="Up" href="Ltree.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Unroller" rel="Chapter" href="Unroller.html">
<link title="Log" rel="Chapter" href="Log.html">
<link title="Event" rel="Chapter" href="Event.html">
<link title="Strategy" rel="Chapter" href="Strategy.html">
<link title="Analysis" rel="Chapter" href="Analysis.html">
<link title="Flags" rel="Chapter" href="Flags.html">
<link title="InvarManager" rel="Chapter" href="InvarManager.html">
<link title="Kind2" rel="Chapter" href="Kind2.html">
<link title="Kind2Flow" rel="Chapter" href="Kind2Flow.html">
<link title="PostAnalysis" rel="Chapter" href="PostAnalysis.html">
<link title="InputSystem" rel="Chapter" href="InputSystem.html">
<link title="Eval" rel="Chapter" href="Eval.html">
<link title="Ident" rel="Chapter" href="Ident.html">
<link title="Ltree" rel="Chapter" href="Ltree.html">
<link title="Model" rel="Chapter" href="Model.html">
<link title="Scope" rel="Chapter" href="Scope.html">
<link title="Simplify" rel="Chapter" href="Simplify.html">
<link title="StateVar" rel="Chapter" href="StateVar.html">
<link title="Symbol" rel="Chapter" href="Symbol.html">
<link title="TermAttr" rel="Chapter" href="TermAttr.html">
<link title="Term" rel="Chapter" href="Term.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="UfSymbol" rel="Chapter" href="UfSymbol.html">
<link title="Var" rel="Chapter" href="Var.html">
<link title="Property" rel="Chapter" href="Property.html">
<link title="SubSystem" rel="Chapter" href="SubSystem.html">
<link title="TransSys" rel="Chapter" href="TransSys.html">
<link title="Actlit" rel="Chapter" href="Actlit.html">
<link title="Base" rel="Chapter" href="Base.html">
<link title="Compress" rel="Chapter" href="Compress.html">
<link title="Step" rel="Chapter" href="Step.html">
<link title="Clause" rel="Chapter" href="Clause.html">
<link title="CooperQE" rel="Chapter" href="CooperQE.html">
<link title="Extract" rel="Chapter" href="Extract.html">
<link title="IC3" rel="Chapter" href="IC3.html">
<link title="Poly" rel="Chapter" href="Poly.html">
<link title="Presburger" rel="Chapter" href="Presburger.html">
<link title="QE" rel="Chapter" href="QE.html">
<link title="InvGenMiner" rel="Chapter" href="InvGenMiner.html">
<link title="InvGenDomain" rel="Chapter" href="InvGenDomain.html">
<link title="InvGenGraph" rel="Chapter" href="InvGenGraph.html">
<link title="InvGen" rel="Chapter" href="InvGen.html">
<link title="LockStepDriver" rel="Chapter" href="LockStepDriver.html">
<link title="InputParser" rel="Chapter" href="InputParser.html">
<link title="Interpreter" rel="Chapter" href="Interpreter.html">
<link title="LustreLexer" rel="Chapter" href="LustreLexer.html">
<link title="LustreParser" rel="Chapter" href="LustreParser.html">
<link title="LustreAst" rel="Chapter" href="LustreAst.html">
<link title="LustreIdent" rel="Chapter" href="LustreIdent.html">
<link title="LustreIndex" rel="Chapter" href="LustreIndex.html">
<link title="LustreExpr" rel="Chapter" href="LustreExpr.html">
<link title="LustreNode" rel="Chapter" href="LustreNode.html">
<link title="LustreContext" rel="Chapter" href="LustreContext.html">
<link title="LustreContract" rel="Chapter" href="LustreContract.html">
<link title="LustreDeclarations" rel="Chapter" href="LustreDeclarations.html">
<link title="LustreSimplify" rel="Chapter" href="LustreSimplify.html">
<link title="LustreSlicing" rel="Chapter" href="LustreSlicing.html">
<link title="LustreTransSys" rel="Chapter" href="LustreTransSys.html">
<link title="LustreInput" rel="Chapter" href="LustreInput.html">
<link title="LustrePath" rel="Chapter" href="LustrePath.html">
<link title="NativeInput" rel="Chapter" href="NativeInput.html">
<link title="Pretty" rel="Chapter" href="Pretty.html">
<link title="SMTExpr" rel="Chapter" href="SMTExpr.html">
<link title="SMTLIBSolver" rel="Chapter" href="SMTLIBSolver.html">
<link title="SMTSolver" rel="Chapter" href="SMTSolver.html">
<link title="SolverDriver" rel="Chapter" href="SolverDriver.html">
<link title="SolverResponse" rel="Chapter" href="SolverResponse.html">
<link title="SolverSig" rel="Chapter" href="SolverSig.html">
<link title="CVC4Driver" rel="Chapter" href="CVC4Driver.html">
<link title="GenericSMTLIBDriver" rel="Chapter" href="GenericSMTLIBDriver.html">
<link title="Z3Driver" rel="Chapter" href="Z3Driver.html">
<link title="Yices2SMT2Driver" rel="Chapter" href="Yices2SMT2Driver.html">
<link title="YicesDriver" rel="Chapter" href="YicesDriver.html">
<link title="YicesLexer" rel="Chapter" href="YicesLexer.html">
<link title="YicesNative" rel="Chapter" href="YicesNative.html">
<link title="YicesResponse" rel="Chapter" href="YicesResponse.html">
<link title="Debug" rel="Chapter" href="Debug.html">
<link title="Decimal" rel="Chapter" href="Decimal.html">
<link title="Hashcons" rel="Chapter" href="Hashcons.html">
<link title="HString" rel="Chapter" href="HString.html">
<link title="HStringSExpr" rel="Chapter" href="HStringSExpr.html">
<link title="Kind2Config" rel="Chapter" href="Kind2Config.html">
<link title="Lib" rel="Chapter" href="Lib.html">
<link title="Res" rel="Chapter" href="Res.html">
<link title="Messaging" rel="Chapter" href="Messaging.html">
<link title="Numeral" rel="Chapter" href="Numeral.html">
<link title="SExprBase" rel="Chapter" href="SExprBase.html">
<link title="SExprLexer" rel="Chapter" href="SExprLexer.html">
<link title="Stat" rel="Chapter" href="Stat.html">
<link title="TermLib" rel="Chapter" href="TermLib.html">
<link title="Trie" rel="Chapter" href="Trie.html">
<link title="Version" rel="Chapter" href="Version.html">
<link title="LustreToRust" rel="Chapter" href="LustreToRust.html">
<link title="TestgenDF" rel="Chapter" href="TestgenDF.html">
<link title="TestgenIO" rel="Chapter" href="TestgenIO.html">
<link title="TestgenModes" rel="Chapter" href="TestgenModes.html">
<link title="TestgenSolver" rel="Chapter" href="TestgenSolver.html">
<link title="TestgenStrategies" rel="Chapter" href="TestgenStrategies.html">
<link title="TestgenTree" rel="Chapter" href="TestgenTree.html">
<link title="TestgenLib" rel="Chapter" href="TestgenLib.html">
<link title="Certificate" rel="Chapter" href="Certificate.html"><title>Kind 2 Developer's Documentation : Ltree.S</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Ltree.BaseTypes.html" title="Ltree.BaseTypes">Previous</a>
&nbsp;<a class="up" href="Ltree.html" title="Ltree">Up</a>
&nbsp;</div>
<h1>Module type <a href="type_Ltree.S.html">Ltree.S</a></h1>

<pre><span class="keyword">module type</span> S = <code class="code"><span class="keyword">sig</span></code> <a href="Ltree.S.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><div class="info modtype top">
Output signature of functor<br>
</div>
<hr width="100%">

<pre><span id="TYPEsymbol"><span class="keyword">type</span> <code class="type"></code>symbol</span> </pre>
<div class="info ">
Symbol<br>
</div>


<pre><span id="TYPEvar"><span class="keyword">type</span> <code class="type"></code>var</span> </pre>
<div class="info ">
Variable<br>
</div>


<pre><span id="TYPEsort"><span class="keyword">type</span> <code class="type"></code>sort</span> </pre>
<div class="info ">
Sort<br>
</div>


<pre><span id="TYPEattr"><span class="keyword">type</span> <code class="type"></code>attr</span> </pre>
<div class="info ">
Attribute<br>
</div>


<pre><code><span id="TYPElambda_node"><span class="keyword">type</span> <code class="type"></code>lambda_node</span> = private </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlambda_node.L"><span class="constructor">L</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPEsort">sort</a> list * <a href="Ltree.S.html#TYPEt">t</a></code></code></td>

</tr></table>

<div class="info ">
Lambda abstraction over symbols, variables and sort of the types
      given. Values of the type cannot be constructed outside this
      module in order to maintain invariants about the data type.<br>
</div>


<pre><span id="TYPElambda"><span class="keyword">type</span> <code class="type"></code>lambda</span> = private <code class="type">(<a href="Ltree.S.html#TYPElambda_node">lambda_node</a>, unit) <a href="Hashcons.html#TYPEhash_consed">Hashcons.hash_consed</a></code> </pre>
<div class="info ">
Hashconsed lambda abstraction<br>
</div>


<pre><code><span id="TYPEt_node"><span class="keyword">type</span> <code class="type"></code>t_node</span> = private </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt_node.FreeVar"><span class="constructor">FreeVar</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPEvar">var</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt_node.BoundVar"><span class="constructor">BoundVar</span></span> <span class="keyword">of</span> <code class="type">int</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt_node.Leaf"><span class="constructor">Leaf</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPEsymbol">symbol</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt_node.Node"><span class="constructor">Node</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPEsymbol">symbol</a> * <a href="Ltree.S.html#TYPEt">t</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt_node.Let"><span class="constructor">Let</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPElambda">lambda</a> * <a href="Ltree.S.html#TYPEt">t</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt_node.Exists"><span class="constructor">Exists</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPElambda">lambda</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt_node.Forall"><span class="constructor">Forall</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPElambda">lambda</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt_node.Annot"><span class="constructor">Annot</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPEt">t</a> * <a href="Ltree.S.html#TYPEattr">attr</a></code></code></td>

</tr></table>

<div class="info ">
Abstract syntax term over symbols, variables and sort of the
      types given. Values of the type cannot be constructed outside
      this module in order to maintain invariants about the data
      type. Use the constructors <a href="Ltree.S.html#VALmk_var"><code class="code"><span class="constructor">Ltree</span>.<span class="constructor">S</span>.mk_var</code></a>, <a href="Ltree.S.html#VALmk_const"><code class="code"><span class="constructor">Ltree</span>.<span class="constructor">S</span>.mk_const</code></a>, <a href="Ltree.S.html#VALmk_app"><code class="code"><span class="constructor">Ltree</span>.<span class="constructor">S</span>.mk_app</code></a>,
      <a href="Ltree.S.html#VALmk_let"><code class="code"><span class="constructor">Ltree</span>.<span class="constructor">S</span>.mk_let</code></a>, <a href="Ltree.S.html#VALmk_exists"><code class="code"><span class="constructor">Ltree</span>.<span class="constructor">S</span>.mk_exists</code></a> and <a href="Ltree.S.html#VALmk_forall"><code class="code"><span class="constructor">Ltree</span>.<span class="constructor">S</span>.mk_forall</code></a>.<br>
</div>


<pre><code><span id="TYPEt_prop"><span class="keyword">type</span> <code class="type"></code>t_prop</span> = private {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTt_prop.bound_vars">bound_vars</span>&nbsp;: <code class="type">int list</code>;</code></td>

</tr></table>
}

<div class="info ">
Properties of a term<br>
</div>


<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = private <code class="type">(<a href="Ltree.S.html#TYPEt_node">t_node</a>, <a href="Ltree.S.html#TYPEt_prop">t_prop</a>) <a href="Hashcons.html#TYPEhash_consed">Hashcons.hash_consed</a></code> </pre>
<div class="info ">
Hashconsed abstract syntax term<br>
</div>


<pre><code><span id="TYPEflat"><span class="keyword">type</span> <code class="type"></code>flat</span> = private </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTflat.Var"><span class="constructor">Var</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPEvar">var</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTflat.Const"><span class="constructor">Const</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPEsymbol">symbol</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTflat.App"><span class="constructor">App</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPEsymbol">symbol</a> * <a href="Ltree.S.html#TYPEt">t</a> list</code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTflat.Attr"><span class="constructor">Attr</span></span> <span class="keyword">of</span> <code class="type"><a href="Ltree.S.html#TYPEt">t</a> * <a href="Ltree.S.html#TYPEattr">attr</a></code></code></td>

</tr></table>

<div class="info ">
Term over symbols, variables and sort of the types given where
      the topmost symbol is not a binding 
<p>

      This type must remain private, because <a href="Ltree.S.html#VALconstruct"><code class="code"><span class="constructor">Ltree</span>.<span class="constructor">S</span>.construct</code></a> does not
      check the invariants and would be a backdoor to construct unsafe
      terms.<br>
</div>


<pre><span id="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type"><a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Comparison function on terms<br>
</div>

<pre><span id="VALequal"><span class="keyword">val</span> equal</span> : <code class="type"><a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Equality function on terms<br>
</div>

<pre><span id="VALhash"><span class="keyword">val</span> hash</span> : <code class="type"><a href="Ltree.S.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Hash function on terms<br>
</div>

<pre><span id="VALtag"><span class="keyword">val</span> tag</span> : <code class="type"><a href="Ltree.S.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Unique identifier for term<br>
</div>

<pre><span id="VALmk_lambda"><span class="keyword">val</span> mk_lambda</span> : <code class="type"><a href="Ltree.S.html#TYPEvar">var</a> list -> <a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPElambda">lambda</a></code></pre><div class="info ">
Constructor for a lambda expression<br>
</div>

<pre><span id="VALeval_lambda"><span class="keyword">val</span> eval_lambda</span> : <code class="type"><a href="Ltree.S.html#TYPElambda">lambda</a> -> <a href="Ltree.S.html#TYPEt">t</a> list -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Beta-evaluate a lambda expression<br>
</div>

<pre><span id="VALpartial_eval_lambda"><span class="keyword">val</span> partial_eval_lambda</span> : <code class="type"><a href="Ltree.S.html#TYPElambda">lambda</a> -> <a href="Ltree.S.html#TYPEt">t</a> list -> <a href="Ltree.S.html#TYPElambda">lambda</a></code></pre><div class="info ">
Partialy Beta-evaluate a lambda expression<br>
</div>

<pre><span id="VALmk_term"><span class="keyword">val</span> mk_term</span> : <code class="type"><a href="Ltree.S.html#TYPEt_node">t_node</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Constructor for a term<br>
</div>

<pre><span id="VALmk_var"><span class="keyword">val</span> mk_var</span> : <code class="type"><a href="Ltree.S.html#TYPEvar">var</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Constructor for a free variable with indexes<br>
</div>

<pre><span id="VALmk_const"><span class="keyword">val</span> mk_const</span> : <code class="type"><a href="Ltree.S.html#TYPEsymbol">symbol</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Constructor for a constant<br>
</div>

<pre><span id="VALmk_app"><span class="keyword">val</span> mk_app</span> : <code class="type"><a href="Ltree.S.html#TYPEsymbol">symbol</a> -> <a href="Ltree.S.html#TYPEt">t</a> list -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Constructor for a function application<br>
</div>

<pre><span id="VALmk_let"><span class="keyword">val</span> mk_let</span> : <code class="type">(<a href="Ltree.S.html#TYPEvar">var</a> * <a href="Ltree.S.html#TYPEt">t</a>) list -> <a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Constructor for a let binding<br>
</div>

<pre><span id="VALmk_let_elim"><span class="keyword">val</span> mk_let_elim</span> : <code class="type">(<a href="Ltree.S.html#TYPEvar">var</a> * <a href="Ltree.S.html#TYPEt">t</a>) list -> <a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Constructor for a let binding<br>
</div>

<pre><span id="VALmk_exists"><span class="keyword">val</span> mk_exists</span> : <code class="type"><a href="Ltree.S.html#TYPEvar">var</a> list -> <a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Constructor for an existential quantification over an indexed
      free variable<br>
</div>

<pre><span id="VALmk_forall"><span class="keyword">val</span> mk_forall</span> : <code class="type"><a href="Ltree.S.html#TYPEvar">var</a> list -> <a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Constructor for a universal quantification over an indexed
      free variable<br>
</div>

<pre><span id="VALmk_annot"><span class="keyword">val</span> mk_annot</span> : <code class="type"><a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEattr">attr</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Constructor for an annotated term<br>
</div>

<pre><span id="VALnode_of_t"><span class="keyword">val</span> node_of_t</span> : <code class="type"><a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEt_node">t_node</a></code></pre><div class="info ">
Return the node of a hashconsed term<br>
</div>

<pre><span id="VALnode_of_lambda"><span class="keyword">val</span> node_of_lambda</span> : <code class="type"><a href="Ltree.S.html#TYPElambda">lambda</a> -> <a href="Ltree.S.html#TYPElambda_node">lambda_node</a></code></pre><div class="info ">
Return the node of a hashconsed lamda abstraction<br>
</div>

<pre><span id="VALsorts_of_lambda"><span class="keyword">val</span> sorts_of_lambda</span> : <code class="type"><a href="Ltree.S.html#TYPElambda">lambda</a> -> <a href="Ltree.S.html#TYPEsort">sort</a> list</code></pre><div class="info ">
Return the sorts of a hashconsed lambda abstraction<br>
</div>

<pre><span id="VALtag_of_t"><span class="keyword">val</span> tag_of_t</span> : <code class="type"><a href="Ltree.S.html#TYPEt">t</a> -> int</code></pre><div class="info ">
Return the unique tag of a hashconsed term<br>
</div>

<pre><span id="VALeval_t"><span class="keyword">val</span> eval_t</span> : <code class="type">?fail_on_quantifiers:bool -><br>       (<a href="Ltree.S.html#TYPEflat">flat</a> -> 'a list -> 'a) -> <a href="Ltree.S.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
Evaluate the term bottom-up and right-to-left. The evaluation
      function is called at each node of the term with the term being
      evaluated and the list of values computed for the subterms. Let
      bindings are lazily unfolded.<br>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">(int -> <a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEt">t</a>) -> <a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Tail-recursive bottom-up right-to-left map on the term
<p>

      Not every subterm is a proper term, since the de Bruijn indexes are
      shifted. Therefore, the function <code class="code">f</code> is called with the number of
      let bindings the subterm is under as first argument, so that the
      indexes can be adjusted in the subterm if necessary.<br>
</div>

<pre><span id="VALdestruct"><span class="keyword">val</span> destruct</span> : <code class="type"><a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEflat">flat</a></code></pre><div class="info ">
Return the top symbol of a term along with its subterms
<p>

      If the top symbol of a term is a let binding, the binding is
      distributed over the subterms.<br>
</div>

<pre><span id="VALhas_quantifier"><span class="keyword">val</span> has_quantifier</span> : <code class="type"><a href="Ltree.S.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
Returns <code class="code"><span class="keyword">true</span></code> if the term has quantifiers<br>
</div>

<pre><span id="VALinstantiate"><span class="keyword">val</span> instantiate</span> : <code class="type"><a href="Ltree.S.html#TYPElambda">lambda</a> -> <a href="Ltree.S.html#TYPEt">t</a> list -> <a href="Ltree.S.html#TYPEt">t</a></code></pre>
<pre><span id="VALconstruct"><span class="keyword">val</span> construct</span> : <code class="type"><a href="Ltree.S.html#TYPEflat">flat</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Convert the flattened representation back into a term<br>
</div>

<pre><span id="VALimport"><span class="keyword">val</span> import</span> : <code class="type"><a href="Ltree.S.html#TYPEt">t</a> -> <a href="Ltree.S.html#TYPEt">t</a></code></pre><div class="info ">
Import a term into the hashcons table by rebuilding it bottom
      up<br>
</div>

<pre><span id="VALimport_lambda"><span class="keyword">val</span> import_lambda</span> : <code class="type"><a href="Ltree.S.html#TYPElambda">lambda</a> -> <a href="Ltree.S.html#TYPElambda">lambda</a></code></pre><div class="info ">
Import a lambda abstraction into the hashcons table by
      rebuilding it bottom up<br>
</div>

<pre><span id="VALpp_print_term"><span class="keyword">val</span> pp_print_term</span> : <code class="type">?db:int -> Format.formatter -> <a href="Ltree.S.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Pretty-print a term<br>
</div>

<pre><span id="VALpp_print_term"><span class="keyword">val</span> pp_print_term</span> : <code class="type">?db:int -> Format.formatter -> <a href="Ltree.S.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Pretty-print a term<br>
</div>

<pre><span id="VALpp_print_lambda_w"><span class="keyword">val</span> pp_print_lambda_w</span> : <code class="type">(?arity:int -> Format.formatter -> <a href="Ltree.S.html#TYPEsymbol">symbol</a> -> unit) -><br>       (Format.formatter -> <a href="Ltree.S.html#TYPEvar">var</a> -> unit) -><br>       (Format.formatter -> <a href="Ltree.S.html#TYPEsort">sort</a> -> unit) -><br>       ?db:int -> Format.formatter -> <a href="Ltree.S.html#TYPElambda">lambda</a> -> unit</code></pre>
<pre><span id="VALpp_print_term_w"><span class="keyword">val</span> pp_print_term_w</span> : <code class="type">(?arity:int -> Format.formatter -> <a href="Ltree.S.html#TYPEsymbol">symbol</a> -> unit) -><br>       (Format.formatter -> <a href="Ltree.S.html#TYPEvar">var</a> -> unit) -><br>       (Format.formatter -> <a href="Ltree.S.html#TYPEsort">sort</a> -> unit) -><br>       ?db:int -> Format.formatter -> <a href="Ltree.S.html#TYPEt">t</a> -> unit</code></pre>
<pre><span id="VALprint_term"><span class="keyword">val</span> print_term</span> : <code class="type">?db:int -> <a href="Ltree.S.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
Pretty-print a term<br>
</div>

<pre><span id="VALpp_print_lambda"><span class="keyword">val</span> pp_print_lambda</span> : <code class="type">?db:int -> Format.formatter -> <a href="Ltree.S.html#TYPElambda">lambda</a> -> unit</code></pre><div class="info ">
Pretty-print a lambda abstraction<br>
</div>

<pre><span id="VALprint_lambda"><span class="keyword">val</span> print_lambda</span> : <code class="type">?db:int -> <a href="Ltree.S.html#TYPElambda">lambda</a> -> unit</code></pre><div class="info ">
Pretty-print a lambda abstraction<br>
</div>

<pre><span id="VALstats"><span class="keyword">val</span> stats</span> : <code class="type">unit -> int * int * int * int * int * int</code></pre></body></html>