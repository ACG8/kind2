
--===============================================
-- Shared Buffer Controller
--===============================================



-------------------------------------------------
-- Useful temporal (and non-temporal) operators
-------------------------------------------------

-- Sofar(X) is true at any point iff X has been true from 
-- the beginning until that point
node Sofar( X : bool ) returns ( Y : bool );
let
  Y = X and (true -> pre Y);
tel

-- First(X) is the constant stream consisting of the first value of X
node First( X : int ) returns ( a : int );
let
  a = X -> pre a;
tel

-- Since(X,Y) is true precisely when X has been true at some point, 
-- and Y has been continuously true afterwards
node Since( X, Y : bool ) returns ( SinceXY : bool );
let
  SinceXY = X or (Y and (false -> pre SinceXY));
tel

node Since_array(const n: int; X: bool^n; Y : bool ) returns ( SinceXY : bool^n );
let
  SinceXY[i] = X[i] or (Y and (false -> pre SinceXY[i]));
tel

-- SinceIncl(X,Y) is true iff X has been true at some point, 
-- and Y has been continuously true from then on.
node SinceIncl( X, Y : bool ) returns ( SinceXY : bool );
let
  SinceXY = Y and (X or (false -> pre SinceXY));
tel

-- HasHappened(X) is true iff X has been true at least once so far.
node HasHappened(X : bool) returns (Y : bool);
let
  Y = X or (false -> pre Y) ;
tel

-- min(n, X) returns the first index i such as X[i] is true,
-- if any; otherwise it returns -1
node min( const n: int; X: bool^n ) returns ( index: int ) ;
  var A : int^n ;
let
  A[i] = if i > 0 and A[i-1] <> -1 then A[i-1]
         else if X[i] then i else -1 ;
  index = A[n-1] ;
tel


node boolToInt( B : bool ) returns ( N : int );
let
  N = if B then 1 else 0 ;
tel

node boolToInt_array( const n: int; B : bool^n ) returns ( N : int^n );
let
  N[i] = if B[i] then 1 else 0 ;
tel

-- count(n, B) ounts how many elements of B are true
node count( const n : int ; B : bool^n ) returns ( C : int ) ;
  var A : int^n ;
let
  A[i] = if i = 0 then if B[i] then 1 else 0
         else A[i-1] + (if B[i] then 1 else 0);
  C = A[n-1] ;
tel


-------------------
-- Main component
-------------------


node Buffer( const n : int; Init : int ; Request: bool^n; Turn : bool^n; Value : int^n )
returns ( Accepted : bool^n; SharedValue : int ) ;
var index : int ;
    NoOtherRequests : bool ;
    LastWrite : int^n;
    since_count0: bool^n;
let
  assert (n > 0) ;

  -- LastWrite remembers the last value that was written by each component, if any
  LastWrite[i] = if Accepted[i] then Value[i] else (Init -> pre LastWrite[i]) ;

  Accepted[i] = Request[i] and (Turn[i]  or count(n, Request) = 1) ;

  index = min(n, Accepted) ;

  SharedValue  = if index >= 0 then Value[index]
                 else (Init -> pre SharedValue) ; 

  since_count0 = Since_array(n, Accepted, count(n,Request) = 0);

  --%PROPERTY "One accept" forall (i,j:int) 0 <= i and i < n and 0 <= j and j < n and i <> j and Accepted[i] => not Accepted[j] ;

  -- An update is granted to a component only if that component is requesting it.
  --%PROPERTY "accept requested" forall (i:int) 0 <= i and i < n => Accepted[i] => Request[i] ;

  -- Whenever there are more than one update requests at the same time,
  -- exactly one will be accepted.
  --%PROPERTY "accept one request" (exists (i,j:int) 0 <= i and i < n and  0 <= j and j < n and i <> j and Request[i] and Request[j]) => count(n,Accepted) = 1 ;

  -- At most one update request is accepted at any time.
  --%PROPERTY "at most one accept" count(n,Accepted) <= 1;
  
  -- Whenever there is only one update request, that request is accepted.
  --%PROPERTY "one request accept" count(n,Request) = 1 => forall (i:int) 0 <= i and i < n => Request[i] => Accepted[i] ;
       
  -- When an update request is accepted,
  -- the value of the buffer changes accordingly.
  --%PROPERTY "correct update" forall (i:int) 0 <= i and i < n => Accepted[i] => SharedValue = Value[i] ;

  -- A repeated request by the same component cannot be denied twice in a row.
  -- (this property is violated)
  --%PROPERTY "fair" true -> forall (i:int) 0 <= i and i < n => pre Request[i] and not pre Accepted[i] => Accepted[i] ;

  -- When there are no requests at all, the buffer maintains its initialization value.
  -- (interpreted as "where there have been no requests at all, ...")
  --%PROPERTY "init buffer" Sofar(count(n,Request) = 0) => SharedValue = First(Init);

  -- In the absence of current requests, the buffer remains unchanged.
  --%PROPERTY "unchanged buffer" true -> ( count(n,Request) = 0 ) => SharedValue = pre SharedValue;

  -- If the value of the buffer is different from the value a component 
  -- wanted to write, it means that that component's request was denied.
  --%PROPERTY "denied" forall (i:int) 0 <= i and i < n => Request[i] and SharedValue <> Value[i] => not Accepted[i] ;

  -- If there were no requests from the other components since the last write
  -- by the one of them, the buffer maintains the value of that last write.
  --%PROPERTY "maintain" true -> forall (i:int) 0 <= i and i < n => since_count0[i] => SharedValue = LastWrite[i];
 
tel
