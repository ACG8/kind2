type rational = { n: int; d: int };

const C1 = [1, 2, 3];
const C2 = 1^3;
-- const C3[i] : int^3 = i;

node X(s: int; const array_size: int) returns (A8: int^2);
const array_default = 0;
var 
  A1, A2, A7: int^array_size;
  A3, A4: int^array_size^array_size;
  A5: [int, bool]^array_size;
  A6: rational^array_size;
  A9, A10: int^3;
  -- i: real;
  -- j: bool;
  x:  int;

let
  assert(array_size > 0);
  x= 0 + 0 + 1 - 1 + (s*0) + (array_size*0);
  -- These identifiers are hidden in the array definitions
  -- i = 0.0;
  -- j = true;
  
  -- A sliding window over input stream s
  A2[k] = if k = 0 then s else (k -> pre A1[k-1]);
  
  -- A pointwise definition of an array
  -- A1[i] = array_default;

  --%PROPERTY A2[0] = s;
 -- --%PROPERTY A3[0][0] =s; 
  --%PROPERTY x = 0;

  -- -- A multi-dimensional array
  -- A3[i][j] = s;
  
  -- -- A multi-dimensional array, the second i masks the first 
  -- A4[i][i] = i;
  
  -- -- Structural assignment involving recursive array definition
  -- -- (i, A1[i]) = (0, s);

  -- -- Array of tuples 
  -- A5[i] = { i, i mod 2 = 0 };

  -- -- Array of records
  -- A6[i] = rational { n=i; d=i+1 };

  -- -- Temporal operator applied to running variable: legal?
  -- A7[i] = 0 -> pre i;

  -- -- Return an array from a node call
  -- A8[i] = 0;

  -- A9[i] = C1[i] -> pre A9[i] + 1;

  -- A10[i] = C2[i] -> pre A10[i] + 1;

tel