
node Pilot_Flying_Pilot_Flying_Side_Logic_Pilot_Flying_Side_Logic_Impl(
  riseTS : bool; riseOSPF : bool; QS_Properties_Clock_Name : bool; const QS_Properties_Primary_Side : bool; const PFS_Data_Model_Initial_Value : bool
) returns (PFS : bool);

var
  T232 : bool;
  St_Start : int;
  T229 : bool;
  T228 : bool;
  T227 : bool;
  St_Stop : int;
  St_Inhibited : int;
  St_Pilot_Flying : int;
  T3 : bool;
  St_Listening : int;
  inhibit_count : int;
  Do_St_Inhibited : bool;
  state_bounded : bool;
  inhibit_count_bounded : bool;
  pfs_state_consistency : bool;


  state : subrange [1,5] of int;
  -- state : int;

  const St_Inhibited = 2;
  const St_Listening = 3;
  const St_Pilot_Flying = 4;
  const St_Start = 1;
  const St_Stop = 5;
  

let

  Do_St_Inhibited = QS_Properties_Clock_Name and (1 -> pre(state)) = 2 and not T229;
  T229 = QS_Properties_Clock_Name and (1 -> pre(state)) = 2 and (0 -> pre(inhibit_count)) >= 2;
  T232 = QS_Properties_Clock_Name and (1 -> pre(state)) = 3 and riseTS;
  T3 = QS_Properties_Clock_Name and (1 -> pre(state)) = 4 and riseOSPF;
  T227 = QS_Properties_Clock_Name and (1 -> pre(state)) = 1 and QS_Properties_Primary_Side;
  T228 = QS_Properties_Clock_Name and (1 -> pre(state)) = 1 and (not QS_Properties_Primary_Side);

  state =  if Do_St_Inhibited or T3 or T228 then 2 
               else if T229 then 3 
               else if T232 or T227 then 4 
               else (1 -> pre(state));

  PFS =  if T232 then true
       else if T3 then false
       else if T227 then true
       else if T228 then false
       else PFS_Data_Model_Initial_Value -> pre(PFS);
  inhibit_count =  if Do_St_Inhibited then (0 -> pre(inhibit_count))+1
       else if T3 then 0
       else if T228 then 0
       else 0 -> pre(inhibit_count);
       
  pfs_state_consistency = not (state = St_Start) => (PFS = (state = St_Pilot_Flying));
  
  --%PROPERTY pfs_state_consistency;
       
  state_bounded = state >= St_Start and state < St_Stop;
  
  	--%PROPERTY state_bounded;
  	
    inhibit_count_bounded = inhibit_count >= 0 and inhibit_count <= 2;
  
  --%PROPERTY inhibit_count_bounded;

tel;

node Pilot_Flying_Side_Side_Impl(
  TS : bool; OSPF : bool; QS_Properties_Clock_Name : bool; QS_Properties_Primary_Side : bool; PFS_Data_Model_Initial_Value : bool
) returns (PFS : bool);

var
  PFSL_PFS : bool;
  riseTS_O : bool;
  riseOSPF_O : bool;

let
  PFSL_PFS = Pilot_Flying_Pilot_Flying_Side_Logic_Pilot_Flying_Side_Logic_Impl(riseTS_O, riseOSPF_O, QS_Properties_Clock_Name, QS_Properties_Primary_Side, PFS_Data_Model_Initial_Value);
  riseTS_O = Signals_Rise(TS, QS_Properties_Clock_Name);
  riseOSPF_O = Signals_Rise(OSPF, QS_Properties_Clock_Name);
  PFS = PFSL_PFS;


tel;

node Pilot_Flying_Cross_Channel_Bus_Cross_Channel_Bus_Impl(
  I : bool; QS_Properties_Clock_Name : bool; O_Data_Model_Initial_Value : bool; prev_I_Data_Model_Initial_Value : bool
) returns (O : bool);

var
  St_Step : int;
  prev_I : bool;
  T2 : bool;
  T1 : bool;
  St_Stop : int;
  St_Start : int;
  state_bounded : bool;


  --state : subrange [1,3] of int;
  state : int;

let

  St_Step = 2;
  St_Start = 1;
  St_Stop = 3;

  T2 = QS_Properties_Clock_Name and (1 -> pre(state)) = 2;
  T1 = QS_Properties_Clock_Name and (1 -> pre(state)) = 1;

  state =  if T2 or T1 then 2 
               else (1 -> pre(state));

  prev_I =  if T2 then I
       else if T1 then I
       else prev_I_Data_Model_Initial_Value -> pre(prev_I);
  O =  if T2 then prev_I_Data_Model_Initial_Value -> pre(prev_I)
       else if T1 then prev_I_Data_Model_Initial_Value -> pre(prev_I)
       else O_Data_Model_Initial_Value -> pre(O);
      
  state_bounded = state >= St_Start and state < St_Stop;
  
  --%PROPERTY state_bounded;
  

tel;

node Pilot_Flying_PilotFlying_Pilot_Flying_Impl(
  TS : bool; CLK1 : bool; CLK3 : bool; CLK2 : bool; CLK4 : bool
) returns (LPFS : bool; RPFS : bool);

var
  RL_O : bool;
  RS_PFS : bool;
  LR_O : bool;
  LS_PFS : bool;
  L1 : bool;

let
  LS_PFS = Pilot_Flying_Side_Side_Impl(TS, RL_O, CLK1, true, true);
  RS_PFS = Pilot_Flying_Side_Side_Impl(TS, LR_O, CLK3, false, false);
  LR_O = Pilot_Flying_Cross_Channel_Bus_Cross_Channel_Bus_Impl(LS_PFS, CLK2, true, true);
  RL_O = Pilot_Flying_Cross_Channel_Bus_Cross_Channel_Bus_Impl(RS_PFS, CLK4, false, false);
  LPFS = LS_PFS;
  RPFS = RS_PFS;
  
  L1 = 
     true ;
     
   --%PROPERTY L1;


tel;


node Signals_Rise 
(I : bool;  clk : bool) 
returns 
  (O : bool);
var
  pre_I: bool;
let 
  pre_I = (clk => I) and (not clk => (false -> pre(pre_I)));
  O = false -> not pre(pre_I) and I;
tel;


node main(
	TS : bool;
	CLK1 : bool;
	CLK3 : bool;
	CLK2 : bool;
	CLK4 : bool)returns (
  LPFS : bool;
  RPFS : bool);

var
  all_clocks_ticked_once : bool;
  clocks_are_synchronous : bool;
  quiescent : bool;
  clocks_are_quasi_synchronous : bool;
 
  at_least_one_pilot_flying_side : bool;
  agree_on_pilot_flying_side : bool;
  transfer_switch_changes_sides : bool;
  left_side_initial_pilot_flying_side : bool;
  pilot_flying_side_unchanged_unless_transfer_switch_pressed : bool;

let

  --%MAIN
  clocks_are_quasi_synchronous = calendar(CLK1, CLK3, CLK2, CLK4);

  assert clocks_are_quasi_synchronous;
  assert (CLK1 or CLK3 or CLK2 or CLK4);

  LPFS, RPFS =
    Pilot_Flying_PilotFlying_Pilot_Flying_Impl(TS,CLK1,CLK3,CLK2,CLK4);

  all_clocks_ticked_once = ticked(CLK1) and ticked(CLK2) and ticked(CLK3) and ticked(CLK4);
  clocks_are_synchronous = CLK1 = CLK2 and CLK2 = CLK3 and CLK3 = CLK4;
  quiescent = false_longer_than(PRESSED(TS), 39);
     
  
----------------------------------------------------------------------------------------------------
-- R1. At least one side shall always be the pilot flying side.
----------------------------------------------------------------------------------------------------
  at_least_one_pilot_flying_side = LPFS or RPFS;   
  
      
----------------------------------------------------------------------------------------------------
-- R2. Both sides shall agree on the pilot flying side 
-- except while the system is switching sides.
----------------------------------------------------------------------------------------------------
   agree_on_pilot_flying_side = 
     quiescent => LPFS = not RPFS;
     
      
----------------------------------------------------------------------------------------------------
-- R3. Pressing the transfer switch shall always change the pilot flying side.
----------------------------------------------------------------------------------------------------
   transfer_switch_changes_sides = 
      pre quiescent => 
          (not pre LPFS and PRESSED_SEEN(TS,CLK1) => LPFS) and 
          (not pre RPFS and PRESSED_SEEN(TS,CLK3) => RPFS);
        
   
----------------------------------------------------------------------------------------------------
-- R4. The system shall start with the left side as the pilot flying side.
----------------------------------------------------------------------------------------------------
   left_side_initial_pilot_flying_side = LPFS  -> true;
   
       
----------------------------------------------------------------------------------------------------
-- R5. If the transfer switch is not pressed the system shall not change the pilot flying side.
----------------------------------------------------------------------------------------------------
   pilot_flying_side_unchanged_unless_transfer_switch_pressed = 
    quiescent => not (CHANGED(RPFS) or CHANGED(LPFS));   
       
   --assert at_least_one_pilot_flying_side;
   --assert agree_on_pilot_flying_side;

	--%PROPERTY at_least_one_pilot_flying_side;
	--%PROPERTY agree_on_pilot_flying_side;
	--%PROPERTY transfer_switch_changes_sides;
	--%PROPERTY left_side_initial_pilot_flying_side;
	--%PROPERTY pilot_flying_side_unchanged_unless_transfer_switch_pressed;
tel;

---------------------------------------------------------------------------------------------------
-- PRESSED - returns true when predicate p changes from false to true
----------------------------------------------------------------------------------------------------
node PRESSED (p : bool) returns (b : bool);
let
   b = false -> (not pre p and p);
tel;

---------------------------------------------------------------------------------------------------
-- PRESSED_SEEN - returns true when predicate p changes from false to true
--                while clock c is true
----------------------------------------------------------------------------------------------------
node PRESSED_SEEN (p, c : bool) returns (b : bool);
let
   b = false -> (not pre p and pre c) and (p and c);
tel;

---------------------------------------------------------------------------------------------------
-- CHANGED - returns true when predicate p changes value
----------------------------------------------------------------------------------------------------
node CHANGED (p : bool) returns (b : bool);
let
   b = false ->  not (p = pre p);
tel;

node ticked(c: bool) returns (b: bool);
let 
   b = (false -> pre b) or c;
tel;

-- Return true if the input p has been false for more than n instants
--
-- The input n must be constant, only its value at the first 
-- instant is considered. Values at later instants are ignored.
node false_longer_than (p: bool; n: int) returns (ok: bool);

var
  n_is_constant: bool;
  c: int;

let

  n_is_constant = true -> n = pre n;

  --%PROPERTY n_is_constant;

  -- Count the number of instants p was true last, start with u initially
  c = if p then 0 else (1 -> pre c + 1);

  -- Output true if p was last true more than n instants ago
  ok = c > n;

tel;


------------------------------------------------------------------------
-- Quasi-synchronous clocks
------------------------------------------------------------------------


------------------------------------------------------------------------
-- Quasi-synchronous clocks
------------------------------------------------------------------------

node qs_dfa (p, q : bool) returns (ok : bool);
var
--  r : subrange [-2, 2] of int;
  r : int;
  r_is_bounded : bool;
let
  ok = not (((0 -> pre r) = 2 and p) or ((0 -> pre r) = -2 and q));
  
  r = if p and q then 0 
      else if p then (if (0 -> pre r) < 0 then 1 else ((0 -> pre r)) + 1)
      else if q then (if (0 -> pre r) > 0 then -1 else ((0 -> pre r)) - 1)
      else (0 -> pre r);

  r_is_bounded = r <= 2 and r >= -2;

  --%PROPERTY r_is_bounded;

tel;


node calendar(
	CLK1 : bool;
	CLK3 : bool;
	CLK2 : bool;
	CLK4 : bool)
returns (ok : bool);
let
	ok = 
		qs_dfa(CLK1, CLK3) and
		qs_dfa(CLK1, CLK2) and
		qs_dfa(CLK1, CLK4) and
		qs_dfa(CLK3, CLK2) and
		qs_dfa(CLK3, CLK4) and
		qs_dfa(CLK2, CLK4);
tel;
