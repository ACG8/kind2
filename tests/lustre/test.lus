/* This is a comment 
  over several lines */ 

(* Pascal-style comments are 
  also valid - and that officially *)

-- Include file, the name must be in quotes, the path is relative to this file, 
-- can be anywhere in the file
include "inc.lus"

-- Fail: type must be declared
-- type a = a;

-- Predefined type bool
type a = bool;

-- Declaration of multiple aliases for predefined type int
type b, c = int;


-- Predefined type integer range (our extension)
type r1 = subrange [1, 2] of int;
type r2 = subrange [-2, 2] of int;

const r3_l = 1;
const r3_u = 2;
type r3 = subrange [r3_l, r3_u] of int;

-- Predefined type real
type d = real;

-- User-defined type
type e = a;

-- Tuple type
type f = [int, real, bool];

-- Nested tuple type
type g = [d, [int, bool]];

-- Record type (V6)
type h = struct { one : int; two : bool };

-- Record types can be nested, struct is optional
type i2 = struct { a : int; b: bool };
type i = { one: i2;  two : bool; };

/*
-- Enum type (V6) 
type j = enum { st_init, st_step, st_stop };
*/

-- Array types
type k = int^5;
-- type l = int^5^3; -- ^ is left-associative

-- const l : l = 1^5^3;
-- const l_1 = l[2];

const h = 2;
type m = int^5*h;
-- type m = int^5*h;

-- Free constants, must have a type
-- const a1, a2, a3: a;

-- Defined constants without type
const b01 = 1;
      pi = 3.14;

-- Defined constant with optional type 
const c1 : bool = true;
      c2 = 5;
--      c3, c4 : real;

-- A node declaration
node x 
  (a, b: [int, [bool, bool]]; 
   const c: k;
   d, e: int) 
returns 
  (x: k; 
   y, z: [int, [bool, real]]; u: i2;
   v: int);
-- Variable declarations are optional
let 
-- Node equations are optional
tel;

type y_t = { a: int; b: real };

/*
node y (const a: bool) returns (b: int);
-- Local constant declarations
const c : int = 1; d = 2;
var t : y_t;
    e, f: int;

let

  e = 1;
  (f) = 2;

  -- Main node annotation, anything can follow, semicolon is not
  --necessary,  can be anywhere in the node body 

  --%MAIN 
  --%MAIN; 
  --%MAIN xyz

  -- Assignment to a list
  g, h, i = x(c);

  -- List can be in parentheses
  (j, k, l, m) = (true, false, 1, 2.0);

  -- Structural assignment from array
  [n, o, p] = 1^3;

  -- Structural assignment
  [c, [A[0], A[1]]] = e;

  -- Structural assignment to tuple 
  [q, r] = [true, 5];

  -- Assignment to array slices 
  A[i..j] = 3^(i-j);
  B[i..j, k..l] = 3^(j-i)^(l-k);

  -- Assignment to record field
  t.a = y(5);
  
  -- Record construction
  t = y_t { b = 2.0; a = 1 };
  
  t.b = if a xor d then #(a, b, c) else false; 
  
  -- Assertion
  assert x;

  -- Property, must be terminated with a semicolon
  --%PROPERTY k; 

  -- Annotations can be commented 
  -- --%PROPERTY j;

-- A node can end with tel; tel. or tel
tel.
*/

-- Node contracts right after its signature 
node g () returns ();
--@requires true;
--@ensures false;
const n = 5;
var t : int;
let t = n; tel;

/*
-- A node with a type parameter 
node changed<<type t>> (b: t) returns (ok: bool); 
let ok = false ->  not (pre b = b); tel; 

-- A node using a parametric node
node x (x: bool; y: int;) returns (z: bool);
let z = changed<<bool>>(x) or changed<<int>>(y); tel

-- Nodes defined as instances of a parametric node 
node changed_int = changed<<int>>;
node changed_bool = changed<<bool>>;



-- An uninterpreted function, parameters cannot be clocked or have
-- constant parameters
function y (a: bool; c: int) returns (b: int);
function y (a: bool; c: int; ) returns (b: int);
*/



type t = { one: int; two: real; three: bool };

node Z(x: bool) returns (y: t);
let
  y = if x then
        t { one=0; two=1.0; three = true } 
      else
        t { one=1; two=2.0; three = false };
tel;

node X(x: int) returns (y: int);
var z: int; v: t; 
let 
  -- Indexed return value
  v = Z(true);

  -- Abstracted to two new variables, and guarded with oracle
  y = pre pre x + v.one;

tel;

-- Two return values
node nodecall (x: int) returns (f: bool; v: int);
let
  f = false;
  v = 0;
tel;

node Y(x: int; r: real) returns (y: int; value: int);
var
  flag: bool;
  v: t;
let
  v = Z(true);

  -- Node call with pre in input parameter 
  y = X(pre x + v.one);

  -- Node call with two return values
  (flag, value) = if x > 0 then nodecall(x) else (true, 0);

  --%MAIN

  -- Non-variable property
  --%PROPERTY y > 0;
tel; 

-- Array-valued node 
node V(x: int) returns (y: int^3);
let
  y = (x + 1)^3;
tel

-- Nodes with array-valued node calls 
node W(x: int) returns (y: int);
var y_3 : int^3;
let

  -- Node call not top level of expression
  y_3 = 1^3 + V(x);
  y = y_3[0];
tel;

  
node U1(x0: int; y0: real) returns (x1: int; y1:  real);
let x1, y1 = [x0, y0]; tel;

node U2() returns ();
var x: int; y: real;
let
  -- Node call with tuple input 
  x, y = U1(U1(1, 2.0));
tel;


node Rise (x: bool) returns (y: bool);
let y = false -> x and not pre x; tel;

node Count() returns (y: int);
let y = 0 -> pre y + 1; tel;

node CountRise(x: bool) returns (y: int);
let y = condact(Rise(x), Count(), 0); tel;


------------------------------------------------------------------------
-- Examples from the reference manual

-- Section 1

node count (x, y: int) returns (s: int);
let
  s = 2 * (x+y);
tel

node EDGE (X: bool) returns (Y: bool);
let
  Y = false -> X and not pre(X);
tel

node FALLING_EDGE (X: bool) returns (Y: bool);
let
  Y = EDGE(not X);
tel

node SWITCH1 (set, reset, initial: bool) returns (level: bool);
let
  level = initial -> if set then true else if reset then false else pre(level);
  assert not (set and reset);
tel


node SWITCH (set, reset, initial: bool) returns (level: bool);
let
  level = initial -> if set and not pre(level) then true else if reset then false else pre(level);
tel

node x1 (X: bool; N: int) returns ();
var
  N1, PN, N2, N3, N4: int;
let
  N1 = 0 -> if X then pre N + 1 else pre N;
  PN = 0 -> pre N;
  N2 = if X then PN + 1 else PN;
  N3 = if X then (0 -> pre N) + 1 else (0 -> pre N);
  N4 = (0 -> pre N) + if X then 0 else 1;
tel

node COUNTER (init, incr: int; X, reset: bool) returns (N: int);
var PN: int;
let
  PN = init -> pre N;
  N = if reset then init else if X then PN + incr else PN;
tel

node x2 () returns (odds, mod10: int);
var reset: bool;
let
  odds = COUNTER(0, 2, true, false);
  mod10 = COUNTER(0, 1, true, reset);
  reset = true -> pre(mod10) = 9;
tel

node integrator (F, STEP, init: real) returns (Y: real);
let
  Y = init -> pre(Y) + ((F + pre(F))*STEP)/2.0;
tel

/*
-- This has a dependency loop
node sincos(omega: real) returns (sin, cos: real);
let
  sin = omega * integrator(cos, 0.1, 0.0);
  cos = omega * integrator(-sin, 0.1, 1.0);
tel
*/

node sincos (omega: real) returns(sin, cos: real);
let
  sin = omega * integrator(cos, 0.1, 0.0);
  cos = omega * integrator(0.0 -> -pre(sin), 0.1, 1.0);
tel

node x3 (omega: real) returns (min, max: real);
var s, c: real;
let 
  (s, c) = sincos(omega);
  (min, max) = if s > c then (s, c) else (c, s);
tel

node STABLE (set: bool; delay: int) returns (level: bool);
var count: int;
let 
  level = (count > 0);
  count = if set then delay 
          else if false -> pre(level) then pre(count) -1
               else 0;
tel

node TIME_STABLE (set, second: bool; delay: int) returns (level: bool);
var count: int;
let
  level = (count > 0);
  count = if set then delay
          else if second then 
                 if false -> pre(level) then pre(count) - 1 
                 else 0
               else (0 -> pre(count));
tel

/*
node TIME_STABLE (set, second: bool; delay: int) returns (level: bool);
var ck: bool;
let
  level = current(STABLE((set, delay) when ck));
  ck = true -> set or second;
tel
*/

-- Section 2

/*
type TIME, DAY;
type DISPLAY = [TIME, DAY];
const initial_time: TIME;
const Mo, Tu, We, Th, Fr, Sa, Su: DAY;
function Increment_Time (time: TIME) returns (new_time: TIME; change_day: bool);
function ToMorrow (today: DAY) returns (tomorrow: DAY);
node Timer (second: bool) returns (display: DISPLAY);
var time: TIME; day: DAY; change_day: bool;
let
  display = [time, day];
  (time, change_day) = 
    (initial_time, false) -> if second then Increment_Time(pre time)
                             else pre(time, change_day);
  day = Mo -> if change_day then ToMorrow(pre day) else pre day;
tel
*/

/*
const 
  size = 32;
  -- unknown: int;
type T;
node N (const n: int) returns (x: int);
var V: T^(2*n);
let
tel;


node x21 () returns ();
var X1, X2: int;
let
  X = N(size+1); -- is correct
  X = N(unknown); -- is rejected
tel
*/

type T2 = int^3^5;
type complex = [real, real];

node x22 () returns ();
var x, y: complex;
let tel;

const 
  PI = 3.1416;
  RightAngle = PI/2.0;

const size = 64;
type vector = int^size;

/*
node x23 () returns ();
var 
  state: bool;
  coordinates: [real, real] when state;
let tel;
*/

-- Section 5

/*
function increment (time: time) returns (newtime: time);
function decompose (time: time) returns (hours, minute, second: int);

node x51 (updated_time, actual_time: time) returns (H, M, S: int);
let
  (H, M, S) = if update 
              then decompose(updated_time) 
              else decompose(increment(actual_time));
tel
*/

node N (x, y: bool; const low, high: int) returns ();
let tel;

/*
node M (x, y: bool; a: int when x; (b: int; r: real) when y) returns ();
let tel;

node N2 (c: bool; a: int when c) returns (d: bool when c; b: int when d);
let tel;

node x52 (E1: bool; E2: int when E1) returns (F1: bool; F2: int);
let 
  (F1, F2) = N(E1, E2);
tel;
*/

-- Section 6

node N (U, V, W: int) returns (X: int; Y: real); let tel;

node x61 (C: bool; E, E1: int; F, F1: real) returns (X: int; Y: real);
let 
  (X, Y) = if C then (E, F) else (E1, F1);
  (X, Y) = (E, F) -> pre (X, Y);
  -- (X, Y) = (E, F) when C;
  (X, Y) = N(1, 2, 3);
tel


node N (a, b: int) returns (c, d: int);
let (c, d) = (a, b); tel

node x62 (E, F, G, H: int) returns (A, B, C, D: int);
let 
  (A, B, C, D) = (N(E, F), N(G, H));
tel;

node x63 (e: [bool, [int, int]]) returns (c: bool; a, b: int; A: [int, int]);
let
  -- [c, [a, b]] = e;
  -- [c, A] = e;
  c = e[0]; -- a = e[1][0]; b = e[1][1];
  c = e[0]; -- A = e[1];
  -- [c, [A[0], A[1]]] = e;
tel;


-- Section 7

node N (x1, x2, x3: int) returns (y1, y2, y3: int);
let 
  (y1, y2, y3) = (x1, x2, x3);
tel

node x71 (C: bool; x1, x2, x3: int; v1, v2, v3: int) returns (y1, y2, y3: int);
let 
  (y1, y2, y3) = condact(C, N(x1, x2, x3), v1, v2, v3);
  -- (y1, y2, y3) = if C then current(N((x1, x2, x3) when C)) 
  --                else (v1, v2, v3) -> pre(y1, y2, z3);
tel

node x72 (e1 : int; e2: real; e3: bool) returns (e: [int, real, bool]; f: real);
let
  e = [e1, e2, e3];
  f = e[1];
tel

node x73 (a, b, c, e, f: int; d: bool) returns (e1, e2, e4: int; e3: bool);
let
  e1 = a + 2 * b;
  e2 = a + b - c;
  e3 = not (a = b);
  e4 = if d then a else e -> f;
tel

node x74 (e1, e2, e3: int; f2: bool) returns (e: int^3; f: [int, bool, int]);
let
  e = [e1, e2, e3];
tel

node x75 (a: int^5) returns (a1: int; a23: int^2);
const A = [1, 2, 3, 4, 5, 6];
var
  b1 : int;
  b2, b3: int^3;
  b4 : int^1;
  b5: int; 
let
  a1 = a[0];
  -- a23 = a[2..3];
  b1 = A[1];
  -- b2 = A[2..4];
  -- b3 = A[4..2];
  -- b4 = A[2..2];
  -- b5 = A[2..4][0];
tel

type T = int;

node x76 (A: T^10^5) returns (B1: T^10^2; B2: T^2^4; B3: int^5 );
let
  -- B1 = A[1..4][1..2];
  -- B2 = A[1..4, 1..2];
  -- B3 = [1, 2, 3] | [4, 3];
tel

/*
node EQ (const n: int; A, B: int^n) returns (equal: bool);
var C, E: bool^n;
let
  equal = C[n-1];
  C = [E[0]]|C[0..n-2] and E[1..n-1];
  E = (A = B);
tel

node DELAY (const n, default: int;X: int) returns (delayed: int);
var window: int^n;
let
  delayed = window[n-1];
  window = [X]|(default^(n-1) -> pre(window[0..n-2]));
tel
*/

/*
-- Examples from the V6 draft manual
type color1 = enum { blue, white, black };
type color2 = enum { green, orange, yellow };

node enum0 (x: color1) returns (y: color2);
let
  y = if x = blue then green else if x = white then orange else yellow;
tel
*/

type complex1 = { re: real; im: real };
const j = complex1 { re = -(3.0)/2.0; im = 3.0/2.0 };

node get_im(c: complex1) returns (x: real);
let
  x = c.im;
tel

type matrix_3_3 = int^3^3;
const m1 = 0^3^3;
const m2 = [1, 2, 3]^3;
-- const sm2 = m2[2];


